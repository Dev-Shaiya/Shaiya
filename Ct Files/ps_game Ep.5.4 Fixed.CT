<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="42">
  <Forms>
    <UDF1 Class="TCEForm" Encoding="Ascii85">Yhz$w2nldAU:MM2b.}cxWeIh0Gi32eO*FuxWMuP5%{mcIVgA6t9Fkwa6vP@ynNpI$=7,z9n3I!V=oyOr.Fg)[TFlAim^X9E:#-P1m%[;6SXz:FoLQC1$=lw3P=DLS#_Ac)!zDjCJ2/l;m6OZI+)WTus2C+0Zlq[RXQpSszyJU</UDF1>
    <UDF1_1 Class="TCEForm" Encoding="Ascii85">;tJAD2nldAU:MM2b.}cxWeat2GmJN6?kvc9VYXys@GMB1(nRL3z]z]mU%)W@8lIU[lELi2$mf]olV9#qlwaVMnUh,}$;o=,kdf$:lbV.p$;CU9k^[H_mCDKPoLEqjnV-kT0y37vB_kYkII_;]lgr21CoHw77$n7Rq-UUKrf0yw000</UDF1_1>
  </Forms>
  <CheatEntries>
    <CheatEntry>
      <ID>523</ID>
      <Description>"Click Me To Active All"</Description>
      <Options moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
      <GroupHeader>1</GroupHeader>
      <CheatEntries>
        <CheatEntry>
          <ID>88</ID>
          <Description>"Confirm Button Fix"</Description>
          <Options moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>81</ID>
              <Description>"Confirm Button Fix 1"</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,512)
label(returnhere)
label(originalcode)
label(confirm)
label(confirm_set_1)
label(confirm_set_0)

newmem:
cmp ecx,0A0A
je confirm

originalcode:
mov edx,edi
mov ecx,ebx
call 0047D940
jmp returnhere

// ebx = player
// edi = packet
// player+15C4 = Trading With
// player+15E4 = Trade OK Button State
// player+6310 = Trade Confirm Button State
confirm:
cmp dword ptr [ebx+15C4],0
je returnhere

cmp byte ptr [edi+2],1
je confirm_set_1
cmp byte ptr [edi+2],0
je confirm_set_0
jmp returnhere

confirm_set_1:
sub esp,4

mov ecx,ebx

mov dword ptr [ecx+6310],1

mov word ptr [esp],0A0A
mov byte ptr [esp+2],1
mov byte ptr [esp+3],1

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Confirm1 On

mov ecx, dword ptr [ebx+15C4]

mov word ptr [esp],0A0A
mov byte ptr [esp+2],2
mov byte ptr [esp+3],1

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Confirm1 On

add esp,4

jmp returnhere

confirm_set_0:
sub esp,4

mov ecx,ebx
mov dword ptr [ecx+6310],0

mov word ptr [esp],0A0A
mov byte ptr [esp+2],1
mov byte ptr [esp+3],0

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Confirm1 Off

mov ecx,ebx
mov byte ptr [esp+2],2
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Confirm2 Off

mov ecx,ebx

mov byte ptr [ecx+15E4],0

mov word ptr [esp],0A05
mov byte ptr [esp+2],3
mov byte ptr [esp+3],1

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Cancel OK

mov ecx, dword ptr [ebx+15C4]

mov dword ptr [ecx+6310],0

mov word ptr [esp],0A0A
mov byte ptr [esp+2],1
mov byte ptr [esp+3],0

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Confirm1 Off

mov ecx, dword ptr [ebx+15C4]
mov byte ptr [esp+2],2
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Confirm2 Off

mov ecx, dword ptr [ebx+15C4]

mov byte ptr [ecx+15E4],0

mov word ptr [esp],0A05
mov byte ptr [esp+2],3
mov byte ptr [esp+3],1
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Cancel OK

add esp,4

jmp returnhere

00474E07:
jmp newmem
nop
nop
nop
nop
returnhere:

[DISABLE]
dealloc(newmem)

00474E07:
mov edx,edi
mov ecx,ebx
call 0047D940
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>200</ID>
              <Description>"Confirm Button Fix 2"</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,128)
label(returnhere)
label(originalcode)

newmem:
cmp [ecx+6310],al
jne 0047E263
cmp [esi+6310],al
jne 0047E263

originalcode:
cmp [ecx+000015E4],al
jne 0047E263
jmp returnhere

0047E253:
jmp newmem
nop
nop
nop
returnhere:

[DISABLE]
dealloc(newmem)

0047E253:
cmp [ecx+000015E4],al
jne 0047E263
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>82</ID>
              <Description>"Confirm Button Fix 3"</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,512)
label(returnhere)
label(originalcode)

newmem:
mov dword ptr [ecx+6310],0
mov dword ptr [esi+6310],0

push ecx
push edx

sub esp,4

mov word ptr [esp],0A0A
mov byte ptr [esp+2],1
mov byte ptr [esp+3],0

mov edx,esp

push ecx

push 4
push edx
call 004ED0E0
// Send P1 Confirm1 Off

pop ecx

mov byte ptr [esp+2],2

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Confirm2 Off

mov ecx,esi
mov byte ptr [esp+2],1
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Confirm1 Off

mov ecx,esi
mov byte ptr [esp+2],2
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Confirm2 Off

add esp,4

pop edx
pop ecx

originalcode:
push 04
lea edx,[esp+04]

jmp returnhere

0047E26F:
jmp newmem
nop
returnhere:

[DISABLE]
dealloc(newmem)

0047E26F:
push 04
lea edx,[esp+04]
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>85</ID>
              <Description>"Confirm Button Fix 4"</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,256)
label(returnhere)
label(originalcode)
label(remove_confirm_ok)

// player = ebx
// usable: eax, edx, ecx
newmem:
cmp dword ptr [ebx+6310],0
jne remove_confirm_ok
mov ecx, dword ptr [ebx+15C4]
cmp dword ptr [ecx+6310],0
je originalcode

remove_confirm_ok:
sub esp,4

mov ecx,ebx
mov dword ptr [ecx+6310],0

mov word ptr [esp],0A0A
mov byte ptr [esp+2],1
mov byte ptr [esp+3],0

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Confirm1 Off

mov ecx,ebx
mov byte ptr [esp+2],2
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Confirm2 Off

mov ecx,ebx

mov byte ptr [ecx+15E4],0

mov word ptr [esp],0A05
mov byte ptr [esp+2],3
mov byte ptr [esp+3],1

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Cancel OK

mov ecx, dword ptr [ebx+15C4]

mov dword ptr [ecx+6310],0

mov word ptr [esp],0A0A
mov byte ptr [esp+2],1
mov byte ptr [esp+3],0

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Confirm1 Off

mov ecx, dword ptr [ebx+15C4]
mov byte ptr [esp+2],2
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Confirm2 Off

mov ecx, dword ptr [ebx+15C4]

mov byte ptr [ecx+15E4],0

mov word ptr [esp],0A05
mov byte ptr [esp+2],3
mov byte ptr [esp+3],1
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Cancel OK

add esp,4

originalcode:
mov ecx,ebx
call 0047E250
jmp returnhere

0047DE08:
jmp newmem
returnhere:

[DISABLE]
dealloc(newmem)

0047DE08:
call 0047E250
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>86</ID>
              <Description>"Confirm Button Fix 5"</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,256)
label(returnhere)
label(originalcode)
label(remove_confirm_ok)

// player = ebx
// usable: eax, edx, ecx
newmem:
cmp dword ptr [ebx+6310],0
jne remove_confirm_ok
mov ecx, dword ptr [ebx+15C4]
cmp dword ptr [ecx+6310],0
je originalcode

remove_confirm_ok:
sub esp,4

mov ecx,ebx
mov dword ptr [ecx+6310],0

mov word ptr [esp],0A0A
mov byte ptr [esp+2],1
mov byte ptr [esp+3],0

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Confirm1 Off

mov ecx,ebx
mov byte ptr [esp+2],2
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Confirm2 Off

mov ecx,ebx

mov byte ptr [ecx+15E4],0

mov word ptr [esp],0A05
mov byte ptr [esp+2],3
mov byte ptr [esp+3],1

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Cancel OK

mov ecx, dword ptr [ebx+15C4]

mov dword ptr [ecx+6310],0

mov word ptr [esp],0A0A
mov byte ptr [esp+2],1
mov byte ptr [esp+3],0

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Confirm1 Off

mov ecx, dword ptr [ebx+15C4]
mov byte ptr [esp+2],2
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Confirm2 Off

mov ecx, dword ptr [ebx+15C4]

mov byte ptr [ecx+15E4],0

mov word ptr [esp],0A05
mov byte ptr [esp+2],3
mov byte ptr [esp+3],1
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Cancel OK

add esp,4

originalcode:
mov ecx,ebx
call 0047E250
jmp returnhere

0047DFC0:
jmp newmem
returnhere:

[DISABLE]
dealloc(newmem)

0047DFC0:
call 0047E250
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>52</ID>
          <Description>"Cross Faction Trading"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]

0047D9AA:
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop

[DISABLE]

0047D9AA:
mov cl, byte ptr [eax+12D]
cmp cl, byte ptr [ebx+12D]
jne 0047E0DA
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>397</ID>
          <Description>"Cross Faction Whisper"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
0047f629:
db 90 90 90 90 90 90

0047ff69:
db 90 90 90 90 90 90


[DISABLE]
0047f629:
db 0F 85 DF 00 00 00

0047ff69:
db 0F 85 DF 00 00 00
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>260</ID>
          <Description>"Shared PvP Kills"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)
label(M1)
label(M2)
label(M3)
label(M4)
label(M5)
label(M6)
label(M7)
label(M8)
label(M9)

newmem:
pushad
mov edi,esi
mov edx,[esi+000000E0]
xor ecx,ecx
mov cl,[esi+0000012D]
cmp ecx,01
je setzero
mov ecx,01
jmp gocall
setzero:
mov ecx,00
gocall:
push ecx
push edx
call ShareKill
popad
originalcode:

exit:
jmp 00465ACF

ShareKill:
sub esp,10 { 16 }
push ebx
push ebp
mov ebp,[esp+1C]
push esi
call dword ptr [ps_game.exe+1540D0] { -&gt;kernel32.GetTickCount }
lea esi,[ebp+0000018C]
mov ebx,eax
push esi
add ebx,000003E8 { 1000 }
mov [esp+1C],esi
call dword ptr [ps_game.exe+1540DC] { -&gt;ntdll.RtlEnterCriticalSection }
mov ecx,[ebp+00000184]
mov eax,[ecx+04]
mov [ebp+00000188],eax
cmp eax,ecx
je M1
test eax,eax
je M1
M8:
mov eax,[eax+08]
test eax,eax
je M2
lea esi,[eax-000000D0]
jmp M3
M2:
xor esi,esi
M3:
// cmp byte ptr [esi+00005808],0A { if ( *(_BYTE *)(v8 + 22376) &gt; 0xAu )}
//ja M4
//mov eax,[ebp+00000188] {  v6 = (CObjectLink *)CZone-&gt;m_listUser.cursor-&gt;next;}
//mov eax,[eax+04]
//jmp M6

M4:
cmp edi,esi
jne M5
mov ecx,[ebp+00000188]
mov eax,[ecx+04]
jmp M6
M5:
mov dl,[esp+24]
cmp byte ptr [esi+160],(int)41
je killhere
cmp [esi+0000012D],dl { if ( *(_BYTE *)(v8 + 301) == byCountry )}
jne M9

killhere:
// NEW CODE HERE //
fld dword ptr [edi+000000D0]
push ecx
fsub dword ptr [esi+000000D0]
fstp dword ptr [esp+14]
fld dword ptr [edi+000000D8]
fsub dword ptr [esi+000000D8]
fstp dword ptr [esp+24]
fld dword ptr [esp+24]
fld dword ptr [esp+14]
fmul st(0),st(0)
fld st(1)
fmulp st(2),st(0)
faddp
fstp dword ptr [esp+24]
fld dword ptr [esp+24]
fstp dword ptr [esp]
call ps_game.exe+1B8A0
fcomp dword ptr [RangeFloat] { [700.00] }
add esp,04 { 00000004 }
fnstsw ax
sahf
//test ah,41 { 65 }
jae M9 { if ( v11 &gt; 10.0 )}
//Need check party
cmp [esi+000017F4],00
je M9
mov ecx,esi
push edi
call ps_game.exe+67CE0
//               //
M9:
mov edx,[ebp+00000188]
mov eax,[edx+04]
M6:
cmp eax,[ebp+00000184] { while ( v6 != CZone-&gt;m_listUser.head &amp;&amp; v6 );}
mov [ebp+00000188],eax
je M7
test eax,eax
jne M8
M7:
mov esi,[esp+18] { v4 = &amp;this-&gt;m_listUser.m_csList.m_cs;}
M1:
push esi
call dword ptr [ps_game.exe+1540D4] { -&gt;ntdll.RtlLeaveCriticalSection }
pop esi
pop ebp
pop ebx
add esp,10 { 16 }
ret 0008 { 00000008 }

RangeFloat:
dd 42C80000

"ps_game.exe"+65AAD:
jmp newmem
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+65AAD:
call ps_game.exe+67EE0
//Alt: db E8 2E 24 00 00
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>54</ID>
          <Description>"Cross Faction Area Chat (AH)"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,128)

newmem:
cmp byte ptr [ecx+5808],2
jbe 004270ED

cmp byte ptr [ecx+160],#42
je 004270ED

mov dl, byte ptr [esp+18]
cmp dl, byte ptr [ecx+12D]
jmp returnhere

004270E1:
jmp newmem
nop
nop
nop
nop
nop
returnhere:

[DISABLE]

004270E1:
mov dl, byte ptr [esp+18]
cmp dl, byte ptr [ecx+12D]

dealloc(newmem)
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>231</ID>
          <Description>"Cross Faction Inspect"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]

00477D3D:
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop

[DISABLE]

00477D3D:
mov cl, byte ptr [edi+12D]
cmp cl, byte ptr [eax+12D]
jne 00478048
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>461</ID>
          <Description>"Skill Cut Fix."</Description>
          <Options moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>465</ID>
              <Description>"Block 1"</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>//delays using arena recall runes after using skills
[ENABLE]
alloc(newmem,128)
label(return)
label(exit)

newmem:
cmp dword ptr [ebp+00001270],02
je 0047468A
cmp dword ptr [eax+000001A4],00

exit:
jmp return

00473FFD:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00473FFD:
cmp dword ptr [eax+000001A4],00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>464</ID>
              <Description>"block 2"</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>//delays using bootleggery runes after using skills
[ENABLE]
alloc(newmem,128)
label(return)
label(exit)

newmem:
cmp dword ptr [ebp+00001270],02
je 0047468A
cmp dword ptr [eax+000001A4],00

exit:
jmp return

00473ED7:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00473ED7:
cmp dword ptr [eax+000001A4],00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>463</ID>
              <Description>"block 3"</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>//delays using capital recall runes after using skills
[ENABLE]
alloc(newmem,128)
label(return)
label(exit)

newmem:
cmp dword ptr [ebp+00001270],02
je 0047468A
cmp dword ptr [eax+000001A4],00

exit:
jmp return

00473DB0:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00473DB0:
cmp dword ptr [eax+000001A4],00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>462</ID>
              <Description>"block 4"</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>//delays using guild house rune after using skills
[ENABLE]
alloc(newmem,128)
label(return)
label(exit)

newmem:
cmp dword ptr [ebp+00001270],02
je 004742B6
cmp dword ptr [eax+000001A4],06

exit:
jmp return

00474196:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00474196:
cmp dword ptr [eax+000001A4],06
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>519</ID>
          <Description>"Prevent SQL Injection"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1" moAllowManualCollapseAndExpand="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>1</ID>
              <Description>""NoticeWarning" (Credit: Cups)"</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>// Disables the call to the database for /warning (fixes SQL injection via warning)
[ENABLE]
ps_game.exe+836C6:
jmp ps_game.exe+841B8

[DISABLE]
ps_game.exe+836C6:
mov ebx,[esp+18]
push edi
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>520</ID>
              <Description>""NoticeAdmin""</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,32)

newmem:
mov ebx,00571E2F
jmp 004833C8

00482E95:
jmp newmem
nop

[DISABLE]
dealloc(newmem)
00482E95:
push ebx
mov ebx,00571E2F
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>521</ID>
              <Description>""NoticeNormal""</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,32)

newmem:
mov ebx,00571E2F
jmp 004833C8

00482F96:
jmp newmem
nop

[DISABLE]
dealloc(newmem)
00482F96:
push ebx
mov ebx,00571E2F
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>522</ID>
              <Description>""NoticeTo""</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,32)

newmem:
mov ebx,[esp+20]
jmp 004833C8

004830AD:
jmp newmem

[DISABLE]
dealloc(newmem)
004830AD:
push ebx
mov ebx,[esp+20]
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>12</ID>
              <Description>""NoticeCountry""</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,32)

newmem:
mov ebx,00571E2F
jmp 004833C8

004832AB:
jmp newmem
nop

[DISABLE]
dealloc(newmem)
004832AB:
push edi
mov ebx,00571E2F
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>11</ID>
              <Description>""NoticeMap""</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,32)

newmem:
mov ebx,00571E2F
jmp 004833C8

004831A2:
jmp newmem
nop

[DISABLE]
dealloc(newmem)
004831A2:
push edi
mov ebx,00571E2F
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>13</ID>
              <Description>""NoticeAll""</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,32)

newmem:
mov ebx,00571E2F
jmp 004833C8

004833AA:
jmp newmem
nop

[DISABLE]
dealloc(newmem)
004833AA:
push edi
mov ebx,00571E2F
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>237</ID>
          <Description>"Require only 3 people to be in the party"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
//place your code here

originalcode:
cmp eax,02

exit:
jmp returnhere

"ps_game.exe"+850A8:
jmp newmem
nop
nop
nop
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+850A8:
cmp eax,07
jg ps_game.exe+8520C
//Alt: db 83 F8 03 0F 8F 5B 01 00 00
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>239</ID>
          <Description>"Require only 3 people to accept the guild creation request"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
//place your code here

originalcode:
cmp dword ptr [esi+24],02
jl ps_game.exe+85456

exit:
jmp returnhere

"ps_game.exe"+8542C:
jmp newmem
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+8542C:
cmp dword ptr [esi+24],07
jl ps_game.exe+85456
//Alt: db 83 7E 24 03 7C 24
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>482</ID>
          <Description>"Boss Spawn Notice"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,1024)

// ebx = mob pointer
newmem:
call func_send_notice

originalcode:
lea edx, dword ptr [edi+98]
jmp returnhere

func_send_notice:
pushad

add ebx,2

sub esp,#100

mov edi,esp

push #100
push 0
push edi
call msvcrt.memset
add esp,C

mov word ptr [edi],F90B
mov byte ptr [edi+2],FF

push ebx
push edi
call msvcrt.strcat
add esp,8

push notice_text
push edi
call msvcrt.strcat
add esp,8

push edi
call msvcrt.strlen
add esp,4

mov byte ptr [edi+2],al

mov esi, dword ptr [00587960]
movzx eax, byte ptr [edi+2]
add eax,3
mov ecx,edi
call 00419120

add esp,#100

func_send_notice_exit:
popad
ret

notice_text:
db ' just spawned and awaits for the champion that will face it!'
db 0

00422F0D:
jmp newmem
nop
returnhere:

[DISABLE]

00422F0D:
lea edx, dword ptr [edi+98]

dealloc(newmem)
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>485</ID>
          <Description>"Boss Death Notice"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,1024)

// ebx = mob pointer
// eax = player pointer
newmem:
call func_send_notice

originalcode:
lea ecx, dword ptr [ebx+DD4]
jmp returnhere

func_send_notice:
pushad

mov esi,eax
add esi,184

mov ebx, dword ptr [ebx+D4]
add ebx,2

sub esp,#100

mov edi,esp

push #100
push 0
push edi
call msvcrt.memset
add esp,C

mov word ptr [edi],F90B
mov byte ptr [edi+2],FF

push ebx
push edi
call msvcrt.strcat
add esp,8

push notice_text
push edi
call msvcrt.strcat
add esp,8

push esi
push edi
call msvcrt.strcat
add esp,8

push edi
call msvcrt.strlen
add esp,4

mov byte ptr [edi+2],al

mov esi, dword ptr [00587960]
movzx eax, byte ptr [edi+2]
add eax,3
mov ecx,edi
call 00419120

add esp,#100

func_send_notice_exit:
popad
ret

notice_text:
db ' was just killed by '
db 0

004A2083:
jmp newmem
nop
returnhere:

[DISABLE]

004A2083:
lea ecx, dword ptr [ebx+DD4]

dealloc(newmem)
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>34</ID>
          <Description>"Instant Mounts"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
//place your code here
mov ecx,[eax+30]
cmp byte ptr[ecx+25],(int)17//TypeID
je 00477155
cmp byte ptr[ecx+25],(int)19//TypeID
je 00477155
cmp byte ptr[ecx+25],(int)18//TypeID
je 00477155
cmp byte ptr[ecx+25],(int)20//TypeID
je 00477155
cmp byte ptr[ecx+25],(int)21//TypeID
je 00477155
cmp byte ptr[ecx+25],(int)23//TypeID
je 00477155
cmp byte ptr[ecx+25],(int)22//TypeID
je 00477155
cmp byte ptr[ecx+25],(int)24//TypeID
je 00477155
originalcode:
cmp byte ptr [ecx+30],03

exit:
jmp returnhere

"ps_game.exe"+7713E:
jmp newmem
nop
nop
returnhere:



[DISABLE]
"ps_game.exe"+7713E:
mov ecx,[eax+30]
cmp byte ptr [ecx+30],03
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>492</ID>
          <Description>"cross faction party &amp; FFA(41)"</Description>
          <Options moRecursiveSetValue="1" moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>496</ID>
              <Description>"everyone red"</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr [ebp+160],(int)86 //MapID
jne originalcode2
push eax
mov ecx, [ebx+000017F4]
cmp ecx, 0
je code
mov eax, [ebp+000017F4]
cmp eax, 0
je code
cmp eax, ecx
jne code
movzx ecx, byte ptr [ebp+0000012D] //who
jmp originalcode
code:
movzx ecx, byte ptr [ebx+0000012D] //who
movzx eax, byte ptr [ebp+0000012D] //whom
cmp eax, ecx
jne originalcode
cmp eax, 1
jne ex
mov cl, 0
jmp originalcode
ex:
mov cl, 1
originalcode:
pop eax
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]

exit:
jmp returnhere
originalcode2:
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
jmp exit

"ps_game.exe"+26B17:
jmp newmem
nop
nop
nop
nop
nop
nop
returnhere:



[DISABLE]
dealloc(newmem)
"ps_game.exe"+26B17:
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>497</ID>
              <Description>"random respawm"</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
alloc(count,4)
label(returnhere)
label(exit)

newmem:
cmp byte ptr[edi+160],(int)86 //MapID
jne exit
cmp [count],0
je one
cmp [count],1
je two
cmp [count],2
je three
cmp [count],3
je four
cmp [count],4
je five
cmp [count],5
je six
cmp [count],6
je seven
cmp [count],7
je eight
jmp exit

exit:
fld dword ptr [ebp+08]
mov ecx,[edi+000000E0]
jmp returnhere

one:
mov [ebp+00],(float)411.047 //X
mov [ebp+04],(float)26.940//Y
mov [ebp+08],(float)335.565//Z
add [count],1
jmp exit

two:
mov [ebp+00],(float)418.342 //X
mov [ebp+04],(float)26.940//Y
mov [ebp+08],(float)303.448//Z
add [count],1
jmp exit

three:
mov [ebp+00],(float)416.382 //X
mov [ebp+04],(float)26.940 //Y
mov [ebp+08],(float)270.155//Z
add [count],1
jmp exit

four:
mov [ebp+00],(float)383.714 //X
mov [ebp+04],(float)26.940//Y
mov [ebp+08],(float)284.076//Z
add [count],1
jmp exit

five:
mov [ebp+00],(float)378.676 //X
mov [ebp+04],(float)26.940//Y
mov [ebp+08],(float)311.707//Z
add [count],1
jmp exit

six:
mov [ebp+00],(float)433.677 //X
mov [ebp+04],(float)26.940//Y
mov [ebp+08],(float)319.550//Z
add [count],1
jmp exit

seven:
mov [ebp+00],(float)432.937 //X
mov [ebp+04],(float)26.940//Y
mov [ebp+08],(float)292.961//Z
add [count],1
jmp exit

eight:
mov [ebp+00],(float)408.506 //X
mov [ebp+04],(float)26.940//Y
mov [ebp+08],(float)304.655//Z
mov [count],0
jmp exit

"ps_game.exe"+66E45:
jmp newmem
nop
nop
nop
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+66E45:
fld dword ptr [ebp+08]
mov ecx,[edi+000000E0]
//Alt: db D9 45 08 8B 8F E0 00 00 00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>517</ID>
              <Description>"heal/dispel"</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)


newmem: //this is allocated memory, you have read,write,execute access
mov al,[esi+0000012D]
cmp word ptr [esi+160],(int)86
JE 00457F41

originalcode:

jmp exit


exit:
jmp returnhere

"ps_game.exe"+57F33:
jmp newmem
nop
returnhere:


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+57F33:
mov al,[esi+0000012D]
//Alt: db 8A 86 2D 01 00 00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>518</ID>
              <Description>"buff"</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)


newmem: //this is allocated memory, you have read,write,execute access
mov dl,[esi+0000012D]
cmp word ptr [edi+160],(int)86
JE ps_game.exe+60a53

originalcode:

jmp exit


exit:
jmp returnhere

"ps_game.exe"+60A45:
jmp newmem
nop
returnhere:


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+60A45:
mov dl,[esi+0000012D]
//Alt: db 8A 96 2D 01 00 00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>3</ID>
              <Description>"PVP Abelity same faction"</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)
label(pvp)

newmem: //this is allocated memory, you have read,write,execute access
cmp word ptr [edx+160],(int)86
JE pvp

originalcode:
mov dl,[edx+0000012D]
jmp exit

pvp:
mov dl,[edx+17F4]
cmp dl,[eax+17F4]
je "ps_game.exe"+57E39
jne "ps_game.exe"+57E35

exit:
jmp returnhere

"ps_game.exe"+57E27:
jmp newmem
nop
returnhere:


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+57E27:
mov dl,[edx+0000012D]
//Alt: db 8A 92 2D 01 00 00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>498</ID>
              <Description>"attack same faction"</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr [eax+160],(int)86//MapID
je 00457E35
originalcode:
mov dl,[edx+0000012D]

exit:
jmp returnhere

"ps_game.exe"+57E27:
jmp newmem
nop
returnhere:



[DISABLE]
dealloc(newmem)
"ps_game.exe"+57E27:
mov dl,[edx+0000012D]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>524</ID>
              <Description>"Auto Loot"</Description>
              <Options moHideChildren="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>125</ID>
                  <Description>"Gold To Inventory"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
alloc(newmem,512)
label(returnhere)

label(solo)
label(solo_bonus)
label(solo_bonus_ok)
label(solo_bonus_wtc)
label(solo_bonus_rpc)

newmem:
mov eax, dword ptr [esp+44] // raid pointer
test eax,eax
je solo
jmp returnhere

solo:
mov edx, dword ptr [esp+40] // player pointer
test edx,edx
je 004BAE0D

cmp dword ptr [edx+594C],2
je solo_bonus_wtc
cmp dword ptr [edx+594C],3
je solo_bonus_rpc

solo_bonus_ok:
mov ecx, dword ptr [esp+18]
call 0046BBA0
jmp 004BAEB8

solo_bonus:
sub esp,4
fild dword ptr [esp+1C]
fld dword ptr [esp]
fmul st(1),st(0)
fstp dword ptr [esp]
fistp dword ptr [esp+1C]
add esp,4
jmp solo_bonus_ok

solo_bonus_wtc:
mov dword ptr [esp-4],(float)1.200 // White Tiger Charm = +20%
jmp solo_bonus

solo_bonus_rpc:
mov dword ptr [esp-4],(float)1.500 // Red Phoenix Charm = +50%
jmp solo_bonus

004BAD4C:
jmp newmem
nop
nop
nop
nop
nop
nop
nop
returnhere:

[DISABLE]
dealloc(newmem)

004BAD4C:
mov eax, dword ptr [esp+44]
test eax,eax
je 004BAE0D
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>127</ID>
                  <Description>"Drop To Inventory"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
alloc(newmem,128)
label(returnhere)
label(solo)

newmem:
test ebp,ebp
je solo
jmp returnhere

solo:
mov ecx, dword ptr [esp+18]
test ecx,ecx
je 004BB438
push ebx
call 0046AE60
jmp 004BB47A

004BB1D5:
jmp newmem
nop
nop
nop
returnhere:

[DISABLE]
dealloc(newmem)

004BB1D5:
test ebp,ebp
je 004BB438
</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>526</ID>
              <Description>"GM RR"</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
//place your code here

originalcode:
mov [ebp+00],dx
mov eax,#35 //change this to you stats
//movzx eax,bl original code

exit:
jmp returnhere

"ps_game.exe"+D2C20:
jmp newmem
nop
nop
returnhere:


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+D2C20:
mov [ebp+00],dx
movzx eax,bl
//Alt: db 66 89 55 00 0F B6 C3
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>227</ID>
          <Description>"Admin Read Both Trade Chats"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,32)

newmem:
cmp byte ptr [ecx+5808],2
jbe returnhere

cmp dl, byte ptr [ecx+12D]
jne 004279CE

jmp returnhere

00427938:
jmp newmem
nop
nop
nop
nop
nop
nop
nop
returnhere:

[DISABLE]

00427938:
cmp dl, byte ptr [ecx+12D]
jne 004279CE

dealloc(newmem)
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>506</ID>
          <Description>"Admin join both side raid "</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(raid_faction_override, 128)
define(allow_join, ps_game.exe+757D8)
label(return)

raid_faction_override:

cmp [ebp+5808],(int)10
jl allow_join

cmp dl,[edi+0000012D]
jmp return

ps_game.exe+757C0:
jmp raid_faction_override
db 90
return:

[DISABLE]
dealloc(raid_autojoin_override)

ps_game.exe+757C0:
cmp dl,[edi+0000012D]
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>6</ID>
          <Description>"Fix Drob helmet and Cape"</Description>
          <Color>0000FF</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>// Credits to Eric-Dutra16 and andr3y_you96
[ENABLE]
004BAFC8:
db 90 90 90 90 90 90 90 90 90

004BAFD1:
db 90 90 90 90 90 90 90 90 90

00473BBD:
db 90 90 90 90 90 90 90 90 90 90 90 90 90

[DISABLE]
004BAFC8:
cmp eax,10
je 004BB47A

004BAFD1:
cmp eax,18
je 004BB47A

00473BBD:
cmp dword ptr [eax+000000A0],18
je 0047468A
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>466</ID>
          <Description>"Skill,Jump Cut Fix - [Dev]Factory"</Description>
          <Options moAlwaysHideChildren="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>41</ID>
              <Description>"Skill Casting (Jump Cut Fix)"</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,512)

newmem:
push eax
mov eax, dword ptr [esp+28]
mov dword ptr [esi+6410],eax
pop eax

originalcode:
mov ebp,[esp+24]
push esi
jmp returnhere

0045B1C7:
jmp newmem
returnhere:

[DISABLE]

0045B1C7:
mov ebp, dword ptr [esp+24]
push esi

dealloc(newmem)
</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>528</ID>
                  <Description>"Block 1"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//delays using arena recall runes after using skills
[ENABLE]
alloc(newmem,128)
label(return)
label(exit)

newmem:
cmp dword ptr [ebp+00001270],02
je 0047468A
cmp dword ptr [eax+000001A4],00

exit:
jmp return

00473FFD:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00473FFD:
cmp dword ptr [eax+000001A4],00
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>529</ID>
                  <Description>"block 2"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//delays using bootleggery runes after using skills
[ENABLE]
alloc(newmem,128)
label(return)
label(exit)

newmem:
cmp dword ptr [ebp+00001270],02
je 0047468A
cmp dword ptr [eax+000001A4],00

exit:
jmp return

00473ED7:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00473ED7:
cmp dword ptr [eax+000001A4],00
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>530</ID>
                  <Description>"block 3"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//delays using capital recall runes after using skills
[ENABLE]
alloc(newmem,128)
label(return)
label(exit)

newmem:
cmp dword ptr [ebp+00001270],02
je 0047468A
cmp dword ptr [eax+000001A4],00

exit:
jmp return

00473DB0:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00473DB0:
cmp dword ptr [eax+000001A4],00
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>531</ID>
                  <Description>"block 4"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//delays using guild house rune after using skills
[ENABLE]
alloc(newmem,128)
label(return)
label(exit)

newmem:
cmp dword ptr [ebp+00001270],02
je 004742B6
cmp dword ptr [eax+000001A4],06

exit:
jmp return

00474196:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00474196:
cmp dword ptr [eax+000001A4],06
</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>112</ID>
      <Description>"Rank 10 mil Fix by [Dev]Beno"</Description>
      <Options moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
      <GroupHeader>1</GroupHeader>
      <CheatEntries>
        <CheatEntry>
          <ID>527</ID>
          <Description>"Perfect lapisia 0 &gt; [20]"</Description>
          <Color>FF00FF</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>// Credits to Eric-Dutra16
[ENABLE]
"ps_game.exe"+6CD97:
mov al,#20

"ps_game.exe"+6CD7D:
db 90 90 90 90 90 90

[DISABLE]
"ps_game.exe"+6CD97:
inc al

"ps_game.exe"+6CD7D:
jae "ps_game.exe"+6D11C
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>111</ID>
          <Description>"Auto Notice when kill"</Description>
          <Color>FF00FF</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
alloc(pk,64)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr[edi+160],(int)86
jne originalcode
pushad
pushfd
newmem:
cmp byte ptr[edi+160],(int)45
jne originalcode
pushad
pushfd
newmem:
cmp byte ptr[edi+160],(int)46
jne originalcode
pushad
pushfd
newmem:
cmp byte ptr[edi+160],(int)47
jne originalcode
pushad
pushfd
newmem:
cmp byte ptr[edi+160],(int)70
jne originalcode
pushad
pushfd
newmem:
cmp byte ptr[edi+160],(int)0
jne originalcode
pushad
pushfd
mov edx,[edi+000000E0]
test edx,edx
je vihod
mov eax,3
mov ebx,0
mov word ptr[pk],F90B
again1:
mov cl,[edi+ebx+184]
mov [pk+eax],cl
inc eax
inc ebx
test cl,cl
jne again1
mov byte ptr [pk+eax-1],20
mov [pk+eax],6C6C696B
add eax,4
mov [pk+eax],00206465
add eax,3
mov ebx,0
again2:
mov cl,[ebp+ebx+184]
mov [pk+eax],cl
inc eax
inc ebx
test cl,cl
jne again2
inc eax
mov byte ptr [pk+2],al
add al,2

lea ecx,[pk] // body packet
mov ebx,edx
call 004273A0

vihod:
popfd
popad
originalcode:
add [edi+00000148],ecx

exit:
jmp returnhere

"ps_game.exe"+67DC0:
jmp newmem
nop
returnhere:



[DISABLE]
dealloc(pk)
dealloc(newmem)
"ps_game.exe"+67DC0:
add [edi+00000148],ecx
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>2</ID>
      <Description>"Disable Bless Increation"</Description>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
00419979:
add esp,0x8
nop
nop
nop

00419Adc:
add esp,0x8
nop
nop
nop

00419C3b:
add esp,0x8
nop
nop
nop


[DISABLE]
00419979:
call dword ptr [00554120]

00419Adc:
call dword ptr [00554120]

00419C3b:
call dword ptr [00554120]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>138</ID>
      <Description>"Raid"</Description>
      <Options moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
      <GroupHeader>1</GroupHeader>
      <CheatEntries>
        <CheatEntry>
          <ID>139</ID>
          <Description>"Raid Tahsis Boyutu"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]

00452253:
push 610

[DISABLE]
/*
00452253:
push 150
*/
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>141</ID>
          <Description>"Raid Bellek Temizleme"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]

define(delta,3C0)

0044E08B:
mov dword ptr [eax+104+delta],ebx
mov dword ptr [eax+108+delta],ebx
mov dword ptr [eax+10C+delta],ebx

0044E0A6:
mov edx,#150

0044E0C1:
mov byte ptr [eax+114+delta],bl
mov byte ptr [eax+115+delta],bl
mov dword ptr [eax+110+delta],1

[DISABLE]
/*
0044E08B:
mov dword ptr [eax+104],ebx
mov dword ptr [eax+108],ebx
mov dword ptr [eax+10C],ebx

0044E0A6:
mov edx,1E

0044E0C1:
mov byte ptr [eax+114],bl
mov byte ptr [eax+115],bl
mov dword ptr [eax+110],1

dealloc(newmem)
*/
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>142</ID>
          <Description>"Raid Bellek Genişletme"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]

define(delta,3C0)

00450CBB:
mov [edi+104+delta],eax

00450CC2:
cmp [edi+114+delta],al

0044E170:
mov al,[edi+114+delta]

0044ED70:
cmp byte ptr [eax+114+delta],1

0044E979:
mov al,[esi+114+delta]

0044E170:
mov al,[edi+114+delta]

0044E219:
mov [edi+10C+delta],eax

0044EC06:
mov cl,[ebx+114+delta]

004A1DBE:
mov al,[edi+114+delta]

004A1F15:
mov eax,[edi+10C+delta]

004BA98B:
cmp dword ptr [eax+104+delta],4

0049BC2D:
mov al,[esi+114+delta]

0049127B:
mov al,[ebx+114+delta]

004911AE:
mov cl,[ebx+114+delta]

0044E8C4:
mov al,[edi+114+delta]

0044EC75:
mov byte ptr [esi+114+delta],1

0044ECA8:
cmp eax,[esi+110+delta]

0044ECBF:
mov [esi+110+delta],eax

004758C7:
mov [edx+114+delta],al

004758D6:
mov [ecx+104+delta],edx

004758E6:
mov [eax+115+delta],cl

004758FC:
movzx eax,byte ptr [esi+114+delta]

00475907:
movzx ecx,byte ptr [esi+115+delta]

00475912:
mov edx,[esi+104+delta]

00475927:
mov edx,[esi+110+delta]

004759E4:
cmp byte ptr [eax+114+delta],0

004759F4:
mov [eax+115+delta],cl

00475A0A:
mov al,[esi+115+delta]

00475976:
cmp byte ptr [eax+114+delta],0

00475986:
mov [eax+104+delta],edx

00475D46:
cmp byte ptr [edi+114+delta],0

00475DA2:
mov ecx,[esi+110+delta]

00475A99:
cmp byte ptr [eax+114+delta],0

0044E5CE:
mov [esi+110+delta],eax
mov ecx,[esi+110+delta]

00475A4C:
cmp byte ptr [eax+114+delta],0

0044E6E5:
cmp edi,[esi+110+delta]

0044E708:
mov [esi+110+delta],eax
mov ecx,[esi+110+delta]

00475DF5:
cmp byte ptr [esi+114+delta],0

0044DFD5:
lea eax,[esi+118+delta]

00450719:
add esi,130+delta

0044F4E7:
lea eax,[ebp+118+delta]

0049B131:
lea edi,[esi+118+delta]

0049B15B:
lea ebx,[edi+118+delta]

0049B184:
add esi,118+delta

0044F24C:
lea eax,[ebp+118+delta]

0044DFE7:
lea eax,[esi+130+delta]

0044E967:
lea eax,[esi+118+delta]

004509DE:
add edi,130+delta

0049B1A6:
add esi,118+delta

0044E0E0:
add eax,118+delta

0044E0F0:
add eax,118+delta

0044E11C:
add eax,118+delta

0044E133:
add eax,118+delta

0044E156:
add eax,118+delta

0044EC8D:
lea edi,[esi+118+delta]

00475423:
add eax,118+delta

0044EB85:
lea edi,[ebx+118+delta]

00478862:
add eax,118+delta

0044E4C3:
lea ebx,[edi+118+delta]

0044E669:
lea ebx,[esi+118+delta]

0044E261:
lea edi,[esi+118+delta]

0044EDBE:
lea esi,[ebp+118+delta]

0044EF59:
mov ecx,[ebp+110+delta]

0044EF6B:
mov cl,[ebp+115+delta]

0044EF78:
mov cx,[ebp+104+delta]

0044EF88:
movzx eax,byte ptr [ebp+114+delta]

0044E1CB:
mov [edi+10C+delta],edx

0044F17A:
lea eax,[ebp+118+delta]

0044EA14:
lea edi,[ebx+118+delta]

0044F5F6:
cmp byte ptr [ecx+114+delta],1

0044F641:
lea eax,[ebx+118+delta]

0044F6B3:
cmp edi,[ebx+110+delta]

00450622:
add edi,130+delta

0044FA81:
lea eax,[ebx+118+delta]

0044FB22:
mov eax,[ebx+108+delta]

0044E8B7:
lea ebx,[edi+118+delta]

00450238:
lea eax,[ebx+118+delta]

0044E597:
lea edi,[esi+118+delta]

0047583A:
cmp byte ptr [esi+114+delta],0

0044FDEB:
lea eax,[ebx+118+delta]

0044FE57:
cmp edi,[ebx+110+delta]

0044FEE2:
mov eax,[ebx+108+delta]

0044FF83:
mov [ebx+110+delta],eax

00450129:
mov edx,[ebx+110+delta]

0044F734:
mov eax,[ebx+108+delta]

0044E2A0:
cmp byte ptr [esi+114+delta],0

0044E2AF:
lea edi,[esi+118+delta]

0044E2C2:
mov eax,[esi+110+delta]

0044E2F2:
lea edi,[esi+118+delta]

004757DE:
cmp byte ptr [eax+115+delta],0

004504F1:
cmp byte ptr [eax+114+delta],0

004504FE:
cmp byte ptr [eax+115+delta],0

00450521:
add edi,130+delta

004505A1:
add edi,130+delta

004506A1:
add edi,130+delta

00450B17:
add edi,130+delta

004A1DAD:
lea eax,[edi+118+delta]

004A1E3C:
mov eax,[edi+10C+delta]

0049130E:
mov cl,[ebx+114+delta]

00465F95:
lea ebp,[esi+118+delta]

00465FFF:
add esi,118+delta

0046583C:
lea eax,[ebx+118+delta]

0046584D:
mov al,[ebx+114+delta]

00467758:
lea eax,[esi+118+delta]

004677DC:
mov ebx,[esi+108+delta]

00467804:
mov [esi+108+delta],ebx

004659F9:
mov eax,[edx+10C+delta]

0049B1F3:
lea edi,[esi+118+delta]

0049B21F:
add esi,118+delta

0046A871:
mov al,[ecx+114+delta]

0044EAA4:
lea esi,[ebp+118+delta]

0046776F:
mov eax,[esi+104+delta]

0046B401:
mov al,[ecx+114+delta]

00467419:
add eax,118+delta

004677CA:
cmp [esi+108+delta],eax

0046783B:
inc [esi+108+delta]

004677D2:
mov [esi+108+delta],0

00465D80:
lea ebx,[esi+118+delta]

00465DB8:
mov al,[ebx+114+delta]

00465E05:
add esi,118+delta

0044E059:
add esi,118+delta

00460494:
add edi,118+delta

0046066D:
add edi,118+delta

00467443:
add eax,118+delta

00475658:
add eax,118+delta

00475CF0:
add eax,118+delta

00476926:
add eax,118+delta

00476991:
add eax,118+delta

00478EBF:
add eax,118+delta

0047F92E:
add eax,118+delta

00480266:
add eax,118+delta

00482D6A:
add eax,118+delta

00482E2E:
add eax,118+delta

00483C42:
add eax,118+delta

00483C6F:
add eax,118+delta

004851CF:
add eax,118+delta

00485395:
add eax,118+delta

004856D0:
add eax,118+delta

0049093C:
add edi,118+delta

00490A4D:
add edi,118+delta

00490B5D:
add edi,118+delta

00490D3E:
add edi,118+delta

004912DA:
add edi,118+delta

00491807:
add ebp,118+delta

0049190D:
add esi,118+delta

0049B1BF:
add esi,118+delta

0049B232:
add esi,118+delta

0049BC84:
add ebx,118+delta

0049E589:
add eax,118+delta

004C6B30:
add eax,118+delta

004C6B54:
add eax,118+delta

//00550A13:
//add ecx,118+delta

//00550A43:
//add ecx,118+delta

//005516F3:
//add ecx,118+delta

004BAFE2:
cmp dword ptr [ebp+104+delta],4

004BB1DD:
cmp byte ptr [ebp+114+delta],1

004BB1E6:
cmp dword ptr [ebp+104+delta],4

004BB25B:
mov eax,[ebp+104+delta]

004BB2F0:
cmp [ebp+108+delta],eax

004BB302:
mov esi,[ebp+108+delta]

004BB370:
inc [ebp+108+delta]

004BB2F8:
mov [ebp+108+delta],0

004BB327:
mov [ebp+108+delta],esi

0044FB2D:
mov [ebx+108+delta],eax

00450B09:
mov eax,[edi+148+delta]

00450B11:
mov esi,[edi+130+delta]

0044E379:
lea edi,[ebp+118+delta]

0049BBEF:
lea esi,[ebx+118+delta]

0049124A:
lea ebx,[edi+118+delta]

0044E7C8:
lea ebp,[esi+118+delta]

0044FB61:
cmp byte ptr [ebx+114+delta],1

00450307:
cmp byte ptr [ebx+114+delta],1

004908D4:
lea ebx,[edi+118+delta]

00491767:
lea eax,[ebp+118+delta]

004917A4:
mov al,[edx+114+delta]

00490C8A:
lea ebx,[edi+118+delta]

00490CBF:
mov al,[ebx+114+delta]

004919C1:
mov al,[ebx+114+delta]

00491A12:
lea edi,[ebx+118+delta]

00490905:
mov al,[ebx+114+delta]

004909E5:
lea ebx,[edi+118+delta]

00490A16:
mov al,[ebx+114+delta]

00490AF5:
lea ebx,[edi+118+delta]

00490B26:
mov al,[ebx+114+delta]

//004F22C1:
//cmp dword ptr [ecx+118+delta],0

//004F22D1:
//mov ecx,[ecx+118+delta]

0044F71A:
mov edx,[ebx+110+delta]

0044F725:
mov [ebx+110+delta],edx

0044F792:
mov edx,[ebx+110+delta]

0044F7C2:
mov [ebx+110+delta],eax

0044F969:
mov edx,[ebx+110+delta]

00455C69:
cmp byte ptr [ecx+114+delta],1

0044FEC8:
mov edx,[ebx+110+delta]

0044F76E:
cmp byte ptr [ebx+114+delta],1

0044FF2F:
cmp byte ptr [ebx+114+delta],1

004604B4:
mov dl,[ecx+114+delta]

0047F95F:
cmp byte ptr [edi+114+delta],0

0047F971:
mov ecx,[edi+110+delta]

00475D5C:
mov edx,[edi+110+delta]

0049E4C6:
cmp byte ptr [ebx+114+delta],1

004609E0:
lea ebx,[esi+118+delta]

004734A2:
lea eax,[esi+118+delta]

0044E322:
lea edi,[esi+118+delta]

0044E331:
cmp [esi+114+delta],bl

0044E34A:
mov eax,[esi+110+delta]

0044E551:
lea edi,[esi+118+delta]

0044E567:
cmp eax,[esi+110+delta]

0044E611:
lea edi,[esi+118+delta]

0044E62C:
cmp eax,[esi+110+delta]

0044E645:
mov [esi+110+delta],eax

004600EE:
lea ebp,[esi+118+delta]

00460272:
lea esi,[ebp+118+delta]

0046028E:
mov cl,[ebp+114+delta]

0046083E:
lea ebp,[esi+118+delta]

00460B87:
lea edi,[esi+118+delta]

00491876:
lea ebx,[esi+118+delta]

004918AB:
mov al,[edx+114+delta]

0044F73F:
mov [ebx+108+delta],eax

0044ED43:
cmp byte ptr [ecx+114+delta],0

0044ED4D:
mov esi,[ecx+108+delta]

0044ECD0:
mov [eax+115+delta],cl

0044ECE0:
mov [eax+104+delta],ecx

0044ECE0:
mov [eax+104+delta],ecx

0044FEED:
mov [ebx+108+delta],eax

0044FF53:
mov edx,[ebx+110+delta]

00467869:
mov [esi+108+delta],0
mov ebx,[esi+108+delta]

0046789B:
mov [esi+108+delta],ebx

004678C4:
inc [esi+108+delta]

004BB39F:
mov [ebp+108+delta],0
mov esi,[ebp+108+delta]

004BB3D3:
mov [ebp+108+delta],esi

004BB424:
inc [ebp+108+delta]

004BB397:
cmp [ebp+108+delta],eax

0044FED3:
mov [ebx+110+delta],edx

00467861:
cmp [esi+108+delta],eax

0046068D:
mov dl,[ecx+114+delta]

00465134:
cmp byte ptr [eax+114+delta],0

00480297:
cmp byte ptr [edi+114+delta],0

004802A9:
mov ecx,[edi+110+delta]

004658D8:
mov eax,[ecx+10C+delta]

0046B675:
mov al,[esi+114+delta]

[DISABLE]
/*
00450CBB:
mov [edi+104],eax

00450CC2:
cmp [edi+114],al

0044E170:
mov al,[edi+114]

0044ED70:
cmp byte ptr [eax+114],1

0044E979:
mov al,[esi+114]

0044E170:
mov al,[edi+114]

0044E219:
mov [edi+10C],eax

0044EC06:
mov cl,[ebx+114]

004A1DBE:
mov al,[edi+114]

004A1F15:
mov eax,[edi+10C]

004BA98B:
cmp dword ptr [eax+104],4

0049BC2D:
mov al,[esi+114]

0049127B:
mov al,[ebx+114]

004911AE:
mov cl,[ebx+114]

0044E8C4:
mov al,[edi+114]

0044EC75:
mov byte ptr [esi+114],1

0044ECA8:
cmp eax,[esi+110]

0044ECBF:
mov [esi+110],eax

004758C7:
mov [edx+114],al

004758D6:
mov [ecx+104],edx

004758E6:
mov [eax+115],cl

004758FC:
movzx eax,byte ptr [esi+114]

00475907:
movzx ecx,byte ptr [esi+115]

00475912:
mov edx,[esi+104]

00475927:
mov edx,[esi+110]

004759E4:
cmp byte ptr [eax+114],0

004759F4:
mov [eax+115],cl

00475A0A:
mov al,[esi+115]

00475976:
cmp byte ptr [eax+114],0

00475986:
mov [eax+104],edx

00475D46:
cmp byte ptr [edi+114],0

00475DA2:
mov ecx,[esi+110]

00475A99:
cmp byte ptr [eax+114],0

0044E5CE:
mov [esi+110],eax
mov ecx,[esi+110]

00475A4C:
cmp byte ptr [eax+114],0

0044E6E5:
cmp edi,[esi+110]

0044E708:
mov [esi+110],eax
mov ecx,[esi+110]

00475DF5:
cmp byte ptr [esi+114],0

0044DFD5:
lea eax,[esi+118]

00450719:
add esi,130

0044F4E7:
lea eax,[ebp+118]

0049B131:
lea edi,[esi+118]

0049B15B:
lea ebx,[edi+118]

0049B184:
add esi,118

0044F24C:
lea eax,[ebp+118]

0044DFE7:
lea eax,[esi+130]

0044E967:
lea eax,[esi+118]

004509DE:
add edi,130

0049B1A6:
add esi,118

0044E0E0:
add eax,118

0044E0F0:
add eax,118

0044E11C:
add eax,118

0044E133:
add eax,118

0044E156:
add eax,118

0044EC8D:
lea edi,[esi+118]

00475423:
add eax,118

0044EB85:
lea edi,[ebx+118]

00478862:
add eax,118

0044E4C3:
lea ebx,[edi+118]

0044E669:
lea ebx,[esi+118]

0044E261:
lea edi,[esi+118]

0044EDBE:
lea esi,[ebp+118]

0044EF59:
mov ecx,[ebp+110]

0044EF6B:
mov cl,[ebp+115]

0044EF78:
mov cx,[ebp+104]

0044EF88:
movzx eax,byte ptr [ebp+114]

0044E1CB:
mov [edi+10C],edx

0044F17A:
lea eax,[ebp+118]

0044EA14:
lea edi,[ebx+118]

0044F5F6:
cmp byte ptr [ecx+114],1

0044F641:
lea eax,[ebx+118]

0044F6B3:
cmp edi,[ebx+110]

00450622:
add edi,130

0044FA81:
lea eax,[ebx+118]

0044FB22:
mov eax,[ebx+108]

0044E8B7:
lea ebx,[edi+118]

00450238:
lea eax,[ebx+118]

0044E597:
lea edi,[esi+118]

0047583A:
cmp byte ptr [esi+114],0

0044FDEB:
lea eax,[ebx+118]

0044FE57:
cmp edi,[ebx+110]

0044FEE2:
mov eax,[ebx+108]

0044FF83:
mov [ebx+110],eax

00450129:
mov edx,[ebx+110]

0044F734:
mov eax,[ebx+108]

0044E2A0:
cmp byte ptr [esi+114],0

0044E2AF:
lea edi,[esi+118]

0044E2C2:
mov eax,[esi+110]

0044E2F2:
lea edi,[esi+118]

004757DE:
cmp byte ptr [eax+115],0

004504F1:
cmp byte ptr [eax+114],0

004504FE:
cmp byte ptr [eax+115],0

00450521:
add edi,130

004505A1:
add edi,130

004506A1:
add edi,130

00450B17:
add edi,130

004A1DAD:
lea eax,[edi+118]

004A1E3C:
mov eax,[edi+10C]

0049130E:
mov cl,[ebx+114]

00465F95:
lea ebp,[esi+118]

00465FFF:
add esi,118

0046583C:
lea eax,[ebx+118]

0046584D:
mov al,[ebx+114]

00467758:
lea eax,[esi+118]

004677DC:
mov ebx,[esi+108]

00467804:
mov [esi+108],ebx

004659F9:
mov eax,[edx+10C]

0049B1F3:
lea edi,[esi+118]

0049B21F:
add esi,118

0046A871:
mov al,[ecx+114]

0044EAA4:
lea esi,[ebp+118]

0046776F:
mov eax,[esi+104]

0046B401:
mov al,[ecx+114]

00467419:
add eax,118

004677CA:
cmp [esi+108],eax

0046783B:
inc [esi+108]

004677D2:
mov [esi+108],0

00465D80:
lea ebx,[esi+118]

00465DB8:
mov al,[ebx+114]

00465E05:
add esi,118

0044E059:
add esi,118

00460494:
add edi,118

0046066D:
add edi,118

00467443:
add eax,118

00475658:
add eax,118

00475CF0:
add eax,118

00476926:
add eax,118

00476991:
add eax,118

00478EBF:
add eax,118

0047F92E:
add eax,118

00480266:
add eax,118

00482D6A:
add eax,118

00482E2E:
add eax,118

00483C42:
add eax,118

00483C6F:
add eax,118

004851CF:
add eax,118

00485395:
add eax,118

004856D0:
add eax,118

0049093C:
add edi,118

00490A4D:
add edi,118

00490B5D:
add edi,118

00490D3E:
add edi,118

004912DA:
add edi,118

00491807:
add ebp,118

0049190D:
add esi,118

0049B1BF:
add esi,118

0049B232:
add esi,118

0049BC84:
add ebx,118

0049E589:
add eax,118

004C6B30:
add eax,118

004C6B54:
add eax,118

//00550A13:
//add ecx,118

//00550A43:
//add ecx,118

//005516F3:
//add ecx,118

004BAFE2:
cmp dword ptr [ebp+104],4

004BB1DD:
cmp byte ptr [ebp+114],1

004BB1E6:
cmp dword ptr [ebp+104],4

004BB25B:
mov eax,[ebp+104]

004BB2F0:
cmp [ebp+108],eax

004BB302:
mov esi,[ebp+108]

004BB370:
inc [ebp+108]

004BB2F8:
mov [ebp+108],0

004BB327:
mov [ebp+108],esi

0044FB2D:
mov [ebx+108],eax

00450B09:
mov eax,[edi+148]

00450B11:
mov esi,[edi+130]

0044E379:
lea edi,[ebp+118]

0049BBEF:
lea esi,[ebx+118]

0049124A:
lea ebx,[edi+118]

0044E7C8:
lea ebp,[esi+118]

0044FB61:
cmp byte ptr [ebx+114],1

00450307:
cmp byte ptr [ebx+114],1

004908D4:
lea ebx,[edi+118]

00491767:
lea eax,[ebp+118]

004917A4:
mov al,[edx+114]

00490C8A:
lea ebx,[edi+118]

00490CBF:
mov al,[ebx+114]

004919C1:
mov al,[ebx+114]

00491A12:
lea edi,[ebx+118]

00490905:
mov al,[ebx+114]

004909E5:
lea ebx,[edi+118]

00490A16:
mov al,[ebx+114]

00490AF5:
lea ebx,[edi+118]

00490B26:
mov al,[ebx+114]

//004F22C1:
//cmp dword ptr [ecx+118],0

//004F22D1:
//mov ecx,[ecx+118]

0044F71A:
mov edx,[ebx+110]

0044F725:
mov [ebx+110],edx

0044F792:
mov edx,[ebx+110]

0044F7C2:
mov [ebx+110],eax

0044F969:
mov edx,[ebx+110]

00455C69:
cmp byte ptr [ecx+114],1

0044FEC8:
mov edx,[ebx+110]

0044F76E:
cmp byte ptr [ebx+114],1

0044FF2F:
cmp byte ptr [ebx+114],1

004604B4:
mov dl,[ecx+114]

0047F95F:
cmp byte ptr [edi+114],0

0047F971:
mov ecx,[edi+110]

00475D5C:
mov edx,[edi+110]

0049E4C6:
cmp byte ptr [ebx+114],1

004609E0:
lea ebx,[esi+118]

004734A2:
lea eax,[esi+118]

0044E322:
lea edi,[esi+118]

0044E331:
cmp [esi+114],bl

0044E34A:
mov eax,[esi+110]

0044E551:
lea edi,[esi+118]

0044E567:
cmp eax,[esi+110]

0044E611:
lea edi,[esi+118]

0044E62C:
cmp eax,[esi+110]

0044E645:
mov [esi+110],eax

004600EE:
lea ebp,[esi+118]

00460272:
lea esi,[ebp+118]

0046028E:
mov cl,[ebp+114]

0046083E:
lea ebp,[esi+118]

00460B87:
lea edi,[esi+118]

00491876:
lea ebx,[esi+118]

004918AB:
mov al,[edx+114]

0044F73F:
mov [ebx+108],eax

0044ED43:
cmp byte ptr [ecx+114],0

0044ED4D:
mov esi,[ecx+108]

0044ECD0:
mov [eax+115],cl

0044ECE0:
mov [eax+104],ecx

0044ECE0:
mov [eax+104],ecx

0044FEED:
mov [ebx+108],eax

0044FF53:
mov edx,[ebx+110]

00467869:
mov [esi+108],0
mov ebx,[esi+108]

0046789B:
mov [esi+108],ebx

004678C4:
inc [esi+108]

004BB39F:
mov [ebp+108],0
mov esi,[ebp+108]

004BB3D3:
mov [ebp+108],esi

004BB424:
inc [ebp+108]

004BB397:
cmp [ebp+108],eax

0044FED3:
mov [ebx+110],edx

00467861:
cmp [esi+108],eax

0046068D:
mov dl,[ecx+114]

00465134:
cmp byte ptr [eax+114],0

00480297:
cmp byte ptr [edi+114],0

004802A9:
mov ecx,[edi+110]

004658D8:
mov eax,[ecx+10C]

0046B675:
mov al,[esi+114]
*/
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>140</ID>
          <Description>"Raid kapasitesi"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,512)

label(raid_max_slots)
registersymbol(raid_max_slots)

newmem:

raid_max_slots:
dd #150 // here is the limit max is 150

rc1:
push ecx
mov ecx, dword ptr [raid_max_slots]
cmp dword ptr [eax+10],ecx
pop ecx
jl 0047580D
jmp ret_rc1

rc2:
push eax
mov eax, dword ptr [raid_max_slots]
cmp dword ptr [ebp+10],eax
pop eax
push esi
jmp ret_rc2

rc3:
cmp eax, dword ptr [raid_max_slots]
jl 0044F587
jmp ret_rc3

rc4:
cmp eax, dword ptr [raid_max_slots]
mov [esp+24],eax
jmp ret_rc4

rc5:
cmp eax, dword ptr [raid_max_slots]
jl 0044E563
jmp ret_rc5

rc6:
cmp eax, dword ptr [raid_max_slots]
jl 0044ED58
jmp ret_rc6

rc7:
cmp eax, dword ptr [raid_max_slots]
jl 0044E6F4
jmp ret_rc7

rc8:
cmp esi, dword ptr [raid_max_slots]
jle 004658A4
jmp ret_rc8

rc9:
mov edi, dword ptr [raid_max_slots]
jmp ret_rc9

rc10:
mov edi, dword ptr [raid_max_slots]
jmp ret_rc10

rc11:
cmp ecx, dword ptr [raid_max_slots]
jl 0044ED13
jmp ret_rc11

rc12:
cmp esi, dword ptr [raid_max_slots]
jle 004A1E08
jmp ret_rc12

rc13:
cmp esi, dword ptr [raid_max_slots]
jle 004A1EE1
jmp ret_rc13

rc14:
cmp esi, dword ptr [raid_max_slots]
jle 004659C5
jmp ret_rc14

004757F7:
jmp rc1
nop
ret_rc1:

0044EDB0:
jmp rc2
ret_rc2:

0044F5A6:
jmp rc3
ret_rc3:

0044F128:
jmp rc4
nop
nop
ret_rc4:

0044E570:
jmp rc5
ret_rc5:

0044ED66:
jmp rc6
ret_rc6:

0044E701:
jmp rc7
ret_rc7:

0046589B:
jmp rc8
ret_rc8:

00475B1B:
jmp rc9
ret_rc9:

00475E73:
jmp rc10
ret_rc10:

0044ED22:
jmp rc11
ret_rc11:

004A1DFF:
jmp rc12
ret_rc12:

004A1ED8:
jmp rc13
ret_rc13:

004659BC:
jmp rc14
ret_rc14:

[DISABLE]
/*
004757F7:
cmp dword ptr [eax+10],1E
jl 0047580D

0044EDB0:
cmp dword ptr [ebp+10],1E
push esi

0044F5A6:
cmp eax,1E
jl 0044F587

0044F128:
cmp eax,1E
mov dword ptr [esp+24],eax

0044E570:
cmp eax,1E
jl 0044E563

0044ED66:
cmp eax,1E
jl 0044ED58

0044E701:
cmp eax,1E
jl 0044E6F4

0046589B:
cmp esi,1E
jle 004658A4

00475B1B:
mov edi,1E

00475E73:
mov edi,1E

0044ED22:
cmp ecx,1E
jl 0044ED13

004A1DFF:
cmp esi,1E
jle 004A1E08

004A1ED8:
cmp esi,1E
jle 004A1EE1

004659BC:
cmp esi,1E
jle 004659C5

unregistersymbol(raid_max_slots)
dealloc(newmem)
*/
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>379</ID>
          <Description>"Raid Organizatörleri"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,1024)
define(move_ok,00475D6C)
define(move_fail,00475634)
define(delta,3C0)

newmem:
mov edx, dword ptr [edi+110+delta]
cmp dword ptr [edi+edx*8+18],ebp
je move_ok

push ebp
call func_get_player_slot_in_raid

cdq
mov ecx,#30
div ecx
cmp edx,#29

je is_raid_organizer

jmp move_fail

is_raid_organizer:
sub esp,18

mov dword ptr [esp],eax          // organizer raid
mov dword ptr [esp+4],edx        // organizer slot

mov eax, dword ptr [ebx+2]
cdq
mov ecx,#30
div ecx

mov dword ptr [esp+8],eax        // old raid
mov dword ptr [esp+C],edx        // old slot

mov eax, dword ptr [ebx+6]
cdq
mov ecx,#30
div ecx

mov dword ptr [esp+10],eax        // new raid
mov dword ptr [esp+14],edx        // new slot

// different raid
cmp eax, dword ptr [esp]
jne is_raid_organizer_move_fail

// different raid
mov eax, dword ptr [esp+8]
cmp eax, dword ptr [esp]
jne is_raid_organizer_move_fail

// organizer slot
cmp dword ptr [esp+C],#29
je is_raid_organizer_move_fail

// organizer slot
cmp dword ptr [esp+14],#29
je is_raid_organizer_move_fail

add esp,18
jmp move_ok

is_raid_organizer_move_fail:
add esp,18
jmp move_fail

// push player
func_get_player_slot_in_raid:
push ecx
push ebx
push edi

mov edx, dword ptr [esp+10] // player
mov edi, dword ptr [edx+17F4]
xor eax,eax

func_get_player_slot_in_raid_next:
cmp edx, dword ptr [edi+eax*8+18]
je func_get_player_slot_in_raid_found

inc eax
cmp eax, dword ptr [raid_max_slots]
jb func_get_player_slot_in_raid_next

mov eax,-1
jmp func_get_player_slot_in_raid_exit

func_get_player_slot_in_raid_found:
mov eax, dword ptr [edi+eax*8+14]

func_get_player_slot_in_raid_exit:
pop edi
pop ebx
pop ecx
ret 4

00475D5C:
jmp newmem
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop

[DISABLE]
/*
00475D5C:
mov edx, dword ptr [edi+110]
cmp dword ptr [edi+edx*8+18],ebp
jne 00475634
*/
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>158</ID>
          <Description>"Raidden atmayı engelle (Admin, GM, Restricted Players)"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,1024)

label(raid_kick)
label(ret_raid_kick)
label(raid_kick_adm)
label(raid_kick_gm)
label(raid_kick_adm_notice)
label(raid_kick_gm_notice)

newmem:
raid_kick:
cmp byte ptr [eax+5808],1
je raid_kick_adm
cmp byte ptr [eax+5808],2
je raid_kick_gm

mov ebx, dword ptr [ebp+17F4]
jmp ret_raid_kick

raid_kick_adm:
push ecx
push edx
mov ecx,ebp
mov edx,raid_kick_adm_notice
push 34
push edx
call 004ED0E0
pop edx
pop ecx
jmp 00475417

raid_kick_gm:
push ecx
push edx
mov ecx,ebp
mov edx,raid_kick_gm_notice
push 30
push edx
call 004ED0E0
pop edx
pop ecx
jmp 00475417

raid_kick_adm_notice:
db 0B F9 31
db 'One does not simply kick an admin out of a raid.'
db 00

raid_kick_gm_notice:
db 0B F9 2D
db 'One does not simply kick a GM out of a raid.'
db 00

0047586C:
jmp raid_kick
nop
ret_raid_kick:

[DISABLE]

0047586C:
mov ebx, dword ptr [ebp+17F4]

dealloc(newmem)

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>157</ID>
          <Description>"Manuel Raidlere girmeye izin ver (Admin, GM)"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,128)

label(check_raid_auto_1)
label(ret_check_raid_auto_1)

label(check_raid_auto_2)
label(ret_check_raid_auto_2)

define(delta,3C0)

newmem:
check_raid_auto_1:
mov eax, dword ptr [edi+17F4]
cmp byte ptr [eax+114+delta],0
je 004757E7
cmp byte ptr [ebp+5808],2
jbe 004757F7
jmp ret_check_raid_auto_1

check_raid_auto_2:
cmp byte ptr [ebp+5808],2
jbe 00450507
cmp byte ptr [eax+115+delta],0
je 004504FA
jmp ret_check_raid_auto_2

004757D8:
jmp check_raid_auto_1
nop
ret_check_raid_auto_1:

004504FE:
jmp check_raid_auto_2
nop
nop
nop
nop
ret_check_raid_auto_2:

[DISABLE]
/*
004757D8:
mov eax, dword ptr [edi+17F4]

004504FE:
cmp byte ptr [eax+115],0
je 004504FA

dealloc(newmem)
*/
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>378</ID>
          <Description>"Taraflar Arası Raidlere girmeye izin ver (Admin, GM)"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,128)

newmem:
cmp byte ptr [ebp+5808],2
jbe 004757D8

originalcode:
mov dl, byte ptr [ebp+12D]
jmp returnhere

004757BA:
jmp newmem
nop
returnhere:

[DISABLE]

004757BA:
mov dl, byte ptr [ebp+12D]

dealloc(newmem)
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>377</ID>
          <Description>"Raid Duyuru tag ve isim"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,1024)
label(exit)

define(malloc_size,200)
define(delta,3C0)

// ebx = /raid packet
// ebp = player
newmem:
sub esp,4

// allocate memory
push malloc_size
call msvcrt.malloc
add esp,4

mov dword ptr [esp],eax

push malloc_size
push 0
push eax
call msvcrt.memset
add esp,C

push ebp
call func_get_player_role_in_raid

push eax
call func_get_tag_by_role_in_raid

test eax,eax
je concat_name

mov ecx, dword ptr [esp]

push eax
push ecx
call msvcrt.strcat
add esp,8

concat_name:
lea eax, dword ptr [ebp+184]
mov ecx, dword ptr [esp]

push eax
push ecx
call msvcrt.strcat
add esp,8

mov ecx, dword ptr [esp]

push string_colon
push ecx
call msvcrt.strcat
add esp,8

lea eax, dword ptr [ebx+3]
mov ecx, dword ptr [esp]

push eax
push ecx
call msvcrt.strcat
add esp,8

lea eax, dword ptr [ebx+3]
mov ecx, dword ptr [esp]

push ecx
push eax
call msvcrt.strcpy
add esp,8

lea eax, dword ptr [ebx+3]

push eax
call msvcrt.strlen
add esp,4

mov byte ptr [ebx+2],al

// free memory
mov ecx, dword ptr [esp]
push ecx
call msvcrt.free
add esp,4

exit:
mov al, byte ptr [ebx+2]
add esp,4

originalcode:
mov ecx, dword ptr [ebp+128]
jmp returnhere

// push playerPointer
// call func_get_player_role_in_raid
// eax = 0 =&gt; lead
// eax = 1 =&gt; sub-lead
// eax = 2 =&gt; member
func_get_player_role_in_raid:
push ecx
push edx
push ebx

mov ecx, dword ptr [esp+10] // get player
mov ebx, dword ptr [ecx+17F4] // get raid

xor eax,eax

mov edx, dword ptr [ebx+C] // get leader index
mov edx, dword ptr [ebx+edx*8+18] // get leader pointer

cmp ecx,edx
je func_get_player_role_in_raid_exit

inc eax

mov edx, dword ptr [ebx+110+delta] // get sub-leader index
mov edx, dword ptr [ebx+edx*8+18] // get sub-leader pointer

cmp ecx,edx
je func_get_player_role_in_raid_exit

inc eax

func_get_player_role_in_raid_exit:
pop ebx
pop edx
pop ecx
ret 4

// push roleInRaid
// call func_get_tag_by_role_in_raid
func_get_tag_by_role_in_raid:
push ecx

mov ecx, dword ptr [esp+8]

mov eax,tag_leader

test ecx,ecx
je func_get_tag_by_role_in_raid_exit

mov eax,tag_sub_leader

dec ecx
je func_get_tag_by_role_in_raid_exit

xor eax,eax

func_get_tag_by_role_in_raid_exit:
pop ecx
ret 4

tag_leader:
db '[L]' 0

tag_sub_leader:
db '[S-L]' 0

string_colon:
db ':' 0

0047F995:
jmp newmem
nop
returnhere:

[DISABLE]

0047F995:
mov ecx, dword ptr [ebp+128]

dealloc(newmem)
</AssemblerScript>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>532</ID>
      <Description>"Off"</Description>
      <GroupHeader>1</GroupHeader>
      <Address>0</Address>
      <CheatEntries>
        <CheatEntry>
          <ID>477</ID>
          <Description>"DEX Override (Melee)"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(pop_originalcode)
label(originalcode)
label(success)

define(dex_per_percent,#10)
define(min_accuracy,#20)

// edi = attacker
// esi = target
newmem:
cmp byte ptr [edi+1385],1
je originalcode

push eax
push ecx
push edx
sub esp,10

mov eax, dword ptr [edi+1220]
mov ecx, dword ptr [esi+1220]

cmp eax,ecx
jg success

sub eax,ecx
mov dword ptr [esp],eax
mov dword ptr [esp+4],dex_per_percent
fild dword ptr [esp+4] // dex_per_percent
fild dword ptr [esp] // DEX difference
fabs
fdiv st(0), st(1)
fistp dword ptr [esp]
fistp dword ptr [esp+4]

mov esi,#100
sub esi, dword ptr [esp]

cmp esi,min_accuracy
jge pop_originalcode

mov esi,min_accuracy

pop_originalcode:
add esp,10
pop edx
pop ecx
pop eax

originalcode:
cmp esi,1
jmp returnhere

success:
mov esi,#100
jmp pop_originalcode

00463D4B:
jmp newmem
returnhere:

[DISABLE]

00463D4B:
mov esi,eax
cmp esi,1

dealloc(newmem)
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>478</ID>
          <Description>"DEX Override (Ranged)"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(pop_originalcode)
label(originalcode)
label(success)

define(dex_per_percent,#10)
define(min_accuracy,#20)

// edi = attacker
// esi = target
newmem:
cmp byte ptr [edi+1395],1
je originalcode

push eax
push ecx
push edx
sub esp,10

mov eax, dword ptr [edi+1220]
mov ecx, dword ptr [esi+1220]

cmp eax,ecx
jg success

sub eax,ecx
mov dword ptr [esp],eax
mov dword ptr [esp+4],dex_per_percent
fild dword ptr [esp+4] // dex_per_percent
fild dword ptr [esp] // DEX difference
fabs
fdiv st(0), st(1)
fistp dword ptr [esp]
fistp dword ptr [esp+4]

mov esi,#100
sub esi, dword ptr [esp]

cmp esi,min_accuracy
jge pop_originalcode

mov esi,min_accuracy

pop_originalcode:
add esp,10
pop edx
pop ecx
pop eax

originalcode:
cmp esi,1
jmp returnhere

success:
mov esi,#100
jmp pop_originalcode

00463C9D:
jmp newmem
returnhere:

[DISABLE]

00463C9D:
mov esi,eax
cmp esi,1

dealloc(newmem)
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>17</ID>
          <Description>"Union Summon Raid"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(ItemSummonRaid)
label(checkcountry)
label(failed)
label(exit)

newmem:
call ps_game.exe+4ECF0
//esi=target player,edi=source player
//check map
originalcode:
pushad
movzx eax,word ptr [esi+0x160]
movzx ebx,word ptr [edi+0x160]
cmp eax,(int)45
je checkcountry
cmp ebx,(int)45
je checkcountry

jmp ItemSummonRaid

//checkcountry and check if same map
checkcountry:
cmp eax,ebx        //if they are in the same map which we speicifys
je ItemSummonRaid

movzx eax,byte ptr [esi+0x12d]
movzx ebx,byte ptr [edi+0x12d]
cmp eax,ebx
jne failed

/*
push eax               //party table
push ecx               //leader id
mov eax,[edi+17f4]
mov ecx,[eax+0c]       //leader id
imul ecx,ecx,8
add  ecx,18
mov  ecx,[eax+ecx]   //leader address
cmp edi,ecx          //compare address check is leader
pop ecx
pop eax
je 0049e4ea        //if yes
*/

ItemSummonRaid:

mov eax,dword ptr ds:[edi+0x58FC]
mov ecx,dword ptr ds:[edi+0x5900]
lea eax,dword ptr ds:[eax+eax*2]     // eax=bag,ecx=slot
lea edx,dword ptr ds:[ecx+eax*8]
imul edx,edx,4
mov eax,dword ptr ds:[edi+edx+0x1C0]
mov eax,dword ptr ds:[eax+30]
cmp [eax],(int)100045                 //orginal item id
popad
jne 0049e4ea   //success addr
/*
mov eax,dword ptr ds:[eax+0x30]
cmp byte ptr ds:[eax+0x46],0x1F
*/



exit:
jmp returnhere

failed:
popad
jmp 0049E517



"ps_game.exe"+9E4E1:

jmp newmem

returnhere:

[DISABLE]

//code from here till the end of the code will be used to disable the cheat

dealloc(newmem)

"ps_game.exe"+9E4E1:

call ps_game.exe+4ECF0

//Alt: db E8 0A 08 FB FF
</AssemblerScript>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>0</ID>
      <Description>"Bless system block [DEV]Factory"</Description>
      <ShowAsSigned>0</ShowAsSigned>
      <VariableType>4 Bytes</VariableType>
      <Address>ps_game.exe+CA22E8</Address>
      <CheatEntries>
        <CheatEntry>
          <ID>533</ID>
          <Description>"light bless"</Description>
          <Color>00FF00</Color>
          <VariableType>4 Bytes</VariableType>
          <Address>ps_game.exe+CA2264</Address>
        </CheatEntry>
        <CheatEntry>
          <ID>534</ID>
          <Description>"dark bless"</Description>
          <Color>0000FF</Color>
          <VariableType>4 Bytes</VariableType>
          <Address>ps_game.exe+CA22E8</Address>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
  </CheatEntries>
  <CheatCodes>
    <CodeEntry>
      <Description>Code :lock xadd [ecx],eax</Description>
      <AddressString>kernel32.dll+4BB68</AddressString>
      <Before>
        <Byte>04</Byte>
        <Byte>8B</Byte>
        <Byte>44</Byte>
        <Byte>24</Byte>
        <Byte>08</Byte>
      </Before>
      <Actual>
        <Byte>F0</Byte>
        <Byte>0F</Byte>
        <Byte>C1</Byte>
        <Byte>01</Byte>
      </Actual>
      <After>
        <Byte>C2</Byte>
        <Byte>08</Byte>
        <Byte>00</Byte>
        <Byte>90</Byte>
        <Byte>90</Byte>
      </After>
    </CodeEntry>
    <CodeEntry>
      <Description>Code :lock xadd [ecx],eax</Description>
      <AddressString>kernel32.dll+4BB68</AddressString>
      <Before>
        <Byte>04</Byte>
        <Byte>8B</Byte>
        <Byte>44</Byte>
        <Byte>24</Byte>
        <Byte>08</Byte>
      </Before>
      <Actual>
        <Byte>F0</Byte>
        <Byte>0F</Byte>
        <Byte>C1</Byte>
        <Byte>01</Byte>
      </Actual>
      <After>
        <Byte>C2</Byte>
        <Byte>08</Byte>
        <Byte>00</Byte>
        <Byte>90</Byte>
        <Byte>90</Byte>
      </After>
    </CodeEntry>
  </CheatCodes>
  <UserdefinedSymbols/>
</CheatTable>
