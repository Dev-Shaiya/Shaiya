<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="42">
  <CheatEntries>
    <CheatEntry>
      <ID>0</ID>
      <Description>"Works"</Description>
      <Options moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
      <GroupHeader>1</GroupHeader>
      <CheatEntries>
        <CheatEntry>
          <ID>438</ID>
          <Description>"Features"</Description>
          <Options moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
          <Color>804000</Color>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>205</ID>
              <Description>"Max Level 70"</Description>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]

define(max_level,#80)

004651D9:
cmp ax,max_level

0046507D:
cmp ax,max_level

0046143E:
cmp eax,max_level

00480FC4:
cmp ebx,max_level

0049B5DE:
cmp ebx,max_level

0049B63A:
cmp ebx,max_level

0049B68E:
cmp ebx,max_level

0049B7C2:
cmp ebx,max_level

0049B81E:
cmp ebx,max_level

0049B872:
cmp ebx,max_level

0049BD9E:
cmp ebx,max_level

0049BDCF:
cmp ebx,max_level

0049BE00:
cmp ebx,max_level

0049BEDB:
cmp ebx,max_level

00460C55:
cmp ecx,max_level

00460C85:
cmp ecx,max_level

00460CB5:
cmp ecx,max_level

0046135B:
cmp ecx,max_level

004613AC:
cmp ecx,max_level

004613F9:
cmp ecx,max_level

00464FF5:
cmp ecx,max_level

0046515F:
cmp ecx,max_level

004651EA:
cmp ecx,max_level

0046523F:
cmp ecx,max_level

00467BFC:
cmp ecx,max_level

004612CC:
cmp edx,max_level

004612F7:
cmp edx,max_level

00461322:
cmp edx,max_level

0049241B:
cmp edx,max_level

00547019:
cmp eax,max_level

0049BF34:
cmp ebx,max_level

0049BF81:
cmp ebx,max_level

0049BFD1:
cmp ebx,max_level

0049C013:
cmp ebx,max_level

0049C052:
cmp ebx,max_level

0049C0B4:
cmp ebx,max_level

0049C10D:
cmp ebx,max_level

0049C15A:
cmp ebx,max_level

0049C1AA:
cmp ebx,max_level

0049C1EC:
cmp ebx,max_level

0049C22B:
cmp ebx,max_level

00480E0C:
cmp ecx,max_level

0049243B:
cmp ecx,max_level

0049B4A2:
cmp ecx,max_level

0049B4D3:
cmp ecx,max_level

0049B504:
cmp ecx,max_level

0049BB75:
cmp ecx,max_level

0049BB9C:
cmp ecx,max_level

[DISABLE]

define(max_level,#70)

004651D9:
cmp ax,max_level

0046507D:
cmp ax,max_level

0046143E:
cmp eax,max_level

00480FC4:
cmp ebx,max_level

0049B5DE:
cmp ebx,max_level

0049B63A:
cmp ebx,max_level

0049B68E:
cmp ebx,max_level

0049B7C2:
cmp ebx,max_level

0049B81E:
cmp ebx,max_level

0049B872:
cmp ebx,max_level

0049BD9E:
cmp ebx,max_level

0049BDCF:
cmp ebx,max_level

0049BE00:
cmp ebx,max_level

0049BEDB:
cmp ebx,max_level

00460C55:
cmp ecx,max_level

00460C85:
cmp ecx,max_level

00460CB5:
cmp ecx,max_level

0046135B:
cmp ecx,max_level

004613AC:
cmp ecx,max_level

004613F9:
cmp ecx,max_level

00464FF5:
cmp ecx,max_level

0046515F:
cmp ecx,max_level

004651EA:
cmp ecx,max_level

0046523F:
cmp ecx,max_level

00467BFC:
cmp ecx,max_level

004612CC:
cmp edx,max_level

004612F7:
cmp edx,max_level

00461322:
cmp edx,max_level

0049241B:
cmp edx,max_level

00547019:
cmp eax,max_level

0049BF34:
cmp ebx,max_level

0049BF81:
cmp ebx,max_level

0049BFD1:
cmp ebx,max_level

0049C013:
cmp ebx,max_level

0049C052:
cmp ebx,max_level

0049C0B4:
cmp ebx,max_level

0049C10D:
cmp ebx,max_level

0049C15A:
cmp ebx,max_level

0049C1AA:
cmp ebx,max_level

0049C1EC:
cmp ebx,max_level

0049C22B:
cmp ebx,max_level

00480E0C:
cmp ecx,max_level

0049243B:
cmp ecx,max_level

0049B4A2:
cmp ecx,max_level

0049B4D3:
cmp ecx,max_level

0049B504:
cmp ecx,max_level

0049BB75:
cmp ecx,max_level

0049BB9C:
cmp ecx,max_level
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>47</ID>
              <Description>"Stat Recreation : Reroll"</Description>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript Async="1">[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(max,4)
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)
label(custom)
label(custom2)
label(end)
label(dopa)
label(Oeuf_de_Dragon_Stat4)
label(Oeuf_de_Dragon_Stat3)
label(Oeuf_de_Dragon_Stat2)
label(Oeuf_de_Dragon_Stat1)
label(Oeuf_de_Dragon_Stat)
label(Oeuf_de_Dragon_Mount)
label(Oeuf_de_Dragon_remove)
label(Oeuf_de_Dragon_Base)
label(removal)
label(nothing)

newmem: //this is allocated memory, you have read,write,execute access
mov [start],1
cmp [type],0
JNE custom
cmp [stat],0
JNE custom

originalcode:
lea ebp,[esi+00000084]
mov [start],0
jmp exit

custom:
lea ebp,[esi+00000084]
lea ecx,[ecx+00]
mov edi,[stat]
call 0051BD66
mov edx,[esi+30]
movzx ecx,word ptr [edx+3E]
cdq
mov [max],ecx
inc ecx
idiv ecx
mov bl,dl
call ps_game.exe+11BD66
mov edx,[esi+30]
movzx ecx,word ptr [edx+3E]
inc ecx
cdq
idiv ecx
cmp bl,dl
jb custom2
mov bl,dl

custom2:
cmp dword ptr [esp+2C],00
jne dopa
call ps_game.exe+11BD66
mov edx,[esi+30]
movzx ecx,word ptr [edx+3E]
inc ecx
cdq
idiv ecx
cmp bl,dl
jb dopa
mov bl,dl

dopa:
dec edi
cmp [type],11
JE Oeuf_de_Dragon_Stat4
cmp [type],9
JE Oeuf_de_Dragon_Stat3
cmp [type],8
JE Oeuf_de_Dragon_Stat2
cmp [type],7
JE Oeuf_de_Dragon_Stat1
cmp [type],3
JE Oeuf_de_Dragon_Stat
cmp [type],6
JE Oeuf_de_Dragon_Mount
cmp [type],5
JE Oeuf_de_Dragon_remove
cmp [type],1
JE Oeuf_de_Dragon_Base
cmp [type],(int)10
JE removal
jmp nothing


nothing:
movzx dx,bl
mov [ebp+00+edi*2],dx
jmp end

removal:
xor ecx,ecx
mov [ebp+00+edi*2],00
movzx edx,word ptr [edi*2+00581C74]
mov byte ptr [edx+esi+4C],30
movzx eax,word ptr [edi*2+00581C74]
mov byte ptr [eax+esi+4D],30
mov [start],0
jmp 004D2C7B

Oeuf_de_Dragon_Stat4:
mov bl,70.
movzx dx,bl
mov [ebp+00+edi*2],dx
jmp end

Oeuf_de_Dragon_Stat3:
mov bl,65.
movzx dx,bl
mov [ebp+00+edi*2],dx
jmp end

Oeuf_de_Dragon_Stat2:
mov bl,60.
movzx dx,bl
mov [ebp+00+edi*2],dx
jmp end

Oeuf_de_Dragon_Stat1:
mov bl,55.
movzx dx,bl
mov [ebp+00+edi*2],dx
jmp end

Oeuf_de_Dragon_Stat:
mov bl,50.
movzx dx,bl
mov [ebp+00+edi*2],dx
jmp end

Oeuf_de_Dragon_Base:
mov bl,40.
movzx dx,bl
mov [ebp+00+edi*2],dx
jmp end

Oeuf_de_Dragon_remove:
mov bl,max
movzx dx,bl
mov [ebp+00+edi*2],dx
jmp end

Oeuf_de_Dragon_Mount:
mov bl,30.
movzx dx,bl
mov [ebp+00+edi*2],dx
jmp end

end:
movzx eax,bl
cdq
mov ecx,0000000A
idiv ecx
movzx ecx,word ptr [edi*2+00581C74]
add al,30
mov [ecx+esi+4C],al
movzx eax,word ptr [edi*2+00581C74]
add dl,30
mov [eax+esi+4D],dl
mov [start],0
jmp 004D2C7B





exit:
jmp returnhere

"ps_game.exe"+D2BC7:
jmp newmem
nop
returnhere:


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+D2BC7:
lea ebp,[esi+00000084]
//Alt: db 8D AE 84 00 00 00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>633</ID>
              <Description>"Stat Recreation : Pointers"</Description>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript Async="1">[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
registersymbol(start)
alloc(start,4)
registersymbol(type)
registersymbol(stat)
registersymbol(counter)
registersymbol(maxorange)
registersymbol(itemtype)
registersymbol(statamount)
alloc(statamount,4)
alloc(itemtype,4)
alloc(maxorange,4)
alloc(counter,4)
alloc(type,4)
alloc(stat,4)
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)
label(check)
label(orange)
label(equality)
label(pointers)

newmem: //this is allocated memory, you have read,write,execute access
/*
Rec runes


STR = Defines Rec rune type

1	: Stat rune (random)
2	: Stat rune (max)
3	: Rec doubler
10	: Stat rune (removal)

Dex = Defines Stat

1 : Str
2 : Dex
3 : Rec
4 : Int
5 : Wis
6 : Luc
7 : Hp
8 : Mp
9 : Sp

[pp+800+eax] = oranges 801 = str 802 = dex etc
[edi+820+eax] = orange stats, 821 = how many str you have, 822 = how many dex you got etc
[edi+840] = max orange amount
[edi+845] = rec doubler amount
*/
cmp byte ptr [ecx+70],1
je check_level_Base
cmp byte ptr [ecx+70],6
je check_level_Mount
cmp byte ptr [ecx+70],3
je Oeuf_de_Dragon_Stat4
cmp byte ptr [ecx+70],11
je Oeuf_de_Dragon_Stat3
cmp byte ptr [ecx+70],9
je Oeuf_de_Dragon_Stat2
cmp byte ptr [ecx+70],8
je Oeuf_de_Dragon_Stat1
cmp byte ptr [ecx+70],7
je Oeuf_de_Dragon_Stat

start_reroll:
mov [statamount],0
pushad
movzx eax,byte ptr [ecx+70]
movzx ebx,byte ptr [ecx+72]
mov [type],eax
mov [stat],ebx
popad
cmp [type],0
JE originalcode
cmp [stat],0
JE originalcode
cmp [stat],(int)7
JL pointers
mov esi,[ebp+30]
cmp [esi],(int)120001
JGE pointers
cmp [esi+a0],(int)16
JL ps_game.exe+6D901
cmp [esi+a0],(int)22
JL pointers
cmp [esi+a0],(int)24
JL ps_game.exe+6D901
cmp [esi+a0],(int)25
JE ps_game.exe+6D901
cmp [esi+a0],(int)36
JL pointers
cmp [esi+a0],(int)39
JL ps_game.exe+6D901
cmp [esi+a0],(int)39
JE pointers
cmp [esi+a0],(int)67
JL ps_game.exe+6D901


pointers:
mov [edi+845],0
mov [edi+840],0
mov [counter],0
pushad
mov esi,[ebp+30]
movzx esi, word ptr[esi+3E]
mov [maxorange],esi
mov eax,0
mov esi,[ebp+30]
movzx esi, byte ptr[esi+4a]
mov ebx,0

orange:
cmp eax,9
JGE check
add eax,1
mov [edi+800+eax],0
mov [edi+820+eax],0
cmp byte ptr [ebp+82+eax*2],00
movzx edx,byte ptr [ebp+82+eax*2]
JE orange
mov [edi+800+eax],1
mov [edi+820+eax],edx
add ebx,1
jmp orange


check:
cmp ebx,esi
popad
JG 0046D901
JE equality
jmp originalcode


originalcode:
push eax
mov eax,[stat]
movzx eax,byte ptr[edi+820+eax]
mov [statamount],eax
pop eax
cmp byte ptr [ecx+46],3E
jne ps_game.exe+6D901
cmp [start],0
JNE ps_game.exe+6D901
jmp exit

equality:
pushad
mov esi,[stat]
cmp byte ptr [edi+800+esi],00
popad
JE ps_game.exe+6D901
jmp originalcode

Oeuf_de_Dragon_Stat4:
push ebp
mov ebp,[ebp+30]
cmp byte ptr [ebp+2e],(int)80
pop ebp
je start_reroll
jmp 0046D901

Oeuf_de_Dragon_Stat3:
push ebp
mov ebp,[ebp+30]
cmp byte ptr [ebp+2e],(int)80
pop ebp
je start_reroll
jmp 0046D901

Oeuf_de_Dragon_Stat2:
push ebp
mov ebp,[ebp+30]
cmp byte ptr [ebp+2e],(int)80
pop ebp
je start_reroll
jmp 0046D901

Oeuf_de_Dragon_Stat1:
push ebp
mov ebp,[ebp+30]
cmp byte ptr [ebp+2e],(int)80
pop ebp
je start_reroll
jmp 0046D901

Oeuf_de_Dragon_Stat:
push ebp
mov ebp,[ebp+30]
cmp byte ptr [ebp+2e],(int)80
pop ebp
je start_reroll
jmp 0046D901

check_level_Base:
push ebp
mov ebp,[ebp+30]
cmp byte ptr [ebp+2e],(int)80
pop ebp
je start_reroll
jmp 0046D901

check_level_Mount:
push ebp
mov ebp,[ebp+30]
cmp byte ptr [ebp+2e],(int)1
pop ebp
je start_reroll
jmp 0046D901

exit:
jmp returnhere

"ps_game.exe"+6D6A9:
jmp newmem
nop
nop
nop
nop
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+6D6A9:
cmp byte ptr [ecx+46],3E
jne ps_game.exe+6D901
//Alt: db 80 79 46 3E 0F 85 4E 02 00 00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>473</ID>
              <Description>"Boss Death Notice"</Description>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,1024)

// ebx = mob pointer
// eax = player pointer
newmem:
call func_send_notice

originalcode:
lea ecx, dword ptr [ebx+DD4]
jmp returnhere

func_send_notice:
pushad

mov esi,eax
add esi,184

mov ebx, dword ptr [ebx+D4]
add ebx,2

sub esp,#100

mov edi,esp

push #100
push 0
push edi
call msvcrt.memset
add esp,C

mov word ptr [edi],F90B
mov byte ptr [edi+2],FF

push ebx
push edi
call msvcrt.strcat
add esp,8

push notice_text
push edi
call msvcrt.strcat
add esp,8

push esi
push edi
call msvcrt.strcat
add esp,8

push edi
call msvcrt.strlen
add esp,4

mov byte ptr [edi+2],al

mov esi, dword ptr [00587960]
movzx eax, byte ptr [edi+2]
add eax,3
mov ecx,edi
call 00419120

add esp,#100

func_send_notice_exit:
popad
ret

notice_text:
db ' was just killed by '
db 0

004A2083:
jmp newmem
nop
returnhere:

[DISABLE]

004A2083:
lea ecx, dword ptr [ebx+DD4]

dealloc(newmem)
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>472</ID>
              <Description>"Boss Spawn Notice"</Description>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,1024)

// ebx = mob pointer
newmem:
call func_send_notice

originalcode:
lea edx, dword ptr [edi+98]
jmp returnhere

func_send_notice:
pushad

add ebx,2

sub esp,#100

mov edi,esp

push #100
push 0
push edi
call msvcrt.memset
add esp,C

mov word ptr [edi],F90B
mov byte ptr [edi+2],FF

push ebx
push edi
call msvcrt.strcat
add esp,8

push notice_text
push edi
call msvcrt.strcat
add esp,8

push edi
call msvcrt.strlen
add esp,4

mov byte ptr [edi+2],al

mov esi, dword ptr [00587960]
movzx eax, byte ptr [edi+2]
add eax,3
mov ecx,edi
call 00419120

add esp,#100

func_send_notice_exit:
popad
ret

notice_text:
db ' just spawned!'
db 0

00422F0D:
jmp newmem
nop
returnhere:

[DISABLE]

00422F0D:
lea edx, dword ptr [edi+98]

dealloc(newmem)
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>625</ID>
              <Description>"Map42 Spawn options"</Description>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>// Credits to Eric-Dutra16
[ENABLE]

// Light Auction House Spawn Points

// Light
0056E628:
dd #42 // MapID

dd (float)507.0 // X
dd (float)1.24 // Y
dd (float)298.0 // Z

// Fury
0056E638:
dd #42 // MapID

dd (float)507.0 // X
dd (float)1.24 // Y
dd (float)298.0 // Z

[DISABLE]

0056E628:
dd 0000002A

dd 429D3852
dd 4175C28F
dd 41DF999A

0056E638:
dd 0000002A

dd 41BB1EB8
dd 4175C28F
dd 42D4CCCD
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>626</ID>
              <Description>"Party Self"</Description>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

alloc(newmem1,2048)
label(returnhere1)
label(originalcode1)
label(exit1)
newmem: //this is allocated memory, you have read,write,execute access
//place your code here
cmp [ebp+18],ecx
je 0044F557
originalcode:
cmp dword ptr [ebp+10],07
mov [esp+20],ebx
jl ps_game.exe+4F246

exit:
jmp returnhere

"ps_game.exe"+4F239:
jmp newmem
nop
returnhere:


"ps_game.exe"+754E2:
nop
nop
nop
nop
nop
nop
nop
nop
 newmem1: //this is allocated memory, you have read,write,execute access
//place your code here
mov eax,01
cmp [esi+10],eax
jle 0044EC8C
originalcode1:
xor eax,eax
cmp [esi+10],eax

exit1:
jmp returnhere1

"ps_game.exe"+4EC70:
jmp newmem1
returnhere1:
[DISABLE]
"ps_game.exe"+4F239:
mov [esp+20],ebx
jl ps_game.exe+4F246

"ps_game.exe"+754E2:
cmp ebx,[ebp+000000DC]
je ps_game.exe+75505

"ps_game.exe"+4EC70:
xor eax,eax
cmp [esi+10],eax
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>344</ID>
              <Description>"Remove Deaths"</Description>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
ps_game.exe+67F46:
add byte ptr [esp+0A],00

[DISABLE]

ps_game.exe+67F46:
mov byte ptr [esp+0A],01
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>57</ID>
              <Description>"Enable summon and movement in Map 67 (Dios Room)"</Description>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]

004733E9:
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop

00473567:
nop
nop
nop
nop
nop
nop

[DISABLE]

004733E9:
cmp dword ptr [ecx+78],#67
je 0047468A

00473567:
cmp dword ptr [ecx+78],#67
je 00473557
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>627</ID>
              <Description>"Removal EXP 15 and 30"</Description>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
//place your code here
cmp byte ptr[esi+160], (int)18//MapID
je 00465222
cmp byte ptr[esi+160], (int)30//MapID
je 00465222
cmp byte ptr[esi+160], (int)105//MapID
je 00465222
originalcode:
cmp edi,eax
jae ps_game.exe+651B7
add edi,ebp

exit:
jmp returnhere

"ps_game.exe"+65177:
jmp newmem
nop
returnhere:



[DISABLE]
"ps_game.exe"+65177:
cmp edi,eax
jae ps_game.exe+651B7
add edi,ebp
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>594</ID>
              <Description>"Allow duels vs just in arena"</Description>
              <Color>408000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
//place your code here
mov cl,[ebx+0000012D]
cmp word ptr [ebx+160],(int)40
je 0048BE8C
jmp 0048BFAA

originalcode:


exit:
jmp returnhere

"ps_game.exe"+8BE80:
jmp newmem
nop
returnhere:


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+8BE80:
mov cl,[ebx+0000012D]
//Alt: db 8A 8B 2D 01 00 00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>463</ID>
              <Description>"enable login cross faction (dark)"</Description>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
//place your code here

originalcode:
jmp ps_game.exe+7B6BB

exit:
jmp returnhere

"ps_game.exe"+7B608:
jmp newmem
nop
returnhere:


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+7B608:
je ps_game.exe+7B6BB
//Alt: db 0F 84 AD 00 00 00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>20</ID>
              <Description>"enable world enter cross faction"</Description>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
//place your code here

originalcode:
jmp ps_game.exe+7C180
push edi
lea edx,[ebp+00005834]

exit:
jmp returnhere

"ps_game.exe"+7C134:
jmp newmem
nop
nop
nop
nop
returnhere:


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+7C134:
je ps_game.exe+7C180
push edi
lea edx,[ebp+00005834]
//Alt: db 74 4A 57 8D 95 34 58 00 00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>18</ID>
              <Description>"enable login cross faction (light)"</Description>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
//place your code here

originalcode:
jmp ps_game.exe+7B6BB

exit:
jmp returnhere

"ps_game.exe"+7B54E:
jmp newmem
nop
returnhere:


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+7B54E:
je ps_game.exe+7B6BB
//Alt: db 0F 84 67 01 00 00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>638</ID>
              <Description>"100% HP/MP/SP Resurrection"</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem, 1024)

ps_game.exe+66EFD:
jmp newmem
db 90

newmem:

// sp
mov ecx,[edi+00001238]
add ecx,ecx
mov [edi+00001238],ecx

// mp
mov edx,[edi+0000123C]
add edx,edx
mov [edi+0000123C],edx
push ecx

// hp
mov ecx,[edi+00001234]
add ecx,ecx
mov [edi+00001234],ecx

// return 
jmp ps_game.exe+66F10

[DISABLE]
dealloc(newmem)

ps_game.exe+66EFD:
mov ecx,[edi+00001238]
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>219</ID>
              <Description>"Instant Mount Summon"</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]

00477147:
add esi,#1000

0047714F:
add esi,#1000

[DISABLE]

00477147:
add esi,#3000

0047714F:
add esi,#5000
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>742</ID>
              <Description>"Leader ress in 10sec"</Description>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>{
    Onur Tok
}
[ENABLE]
ps_game.exe+78EA2:
add eax,#10000

[DISABLE]
ps_game.exe+78EA2:
add eax,#30000
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>554</ID>
              <Description>"PvE perma critical"</Description>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>//Bowie 12/2019
[ENABLE]
00459B13: //magic attacks
nop
nop

00459D8D: //range attacks
nop
nop
nop
nop
nop
nop

00459FFF: //melee attacks
nop
nop

[DISABLE]
00459B13:
jnl 00459B6E

00459D8D:
jnl 00459E22

00459FFF:
jnl 0045A05A
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>628</ID>
              <Description>"Cross faction"</Description>
              <Options moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
              <Color>804000</Color>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>454</ID>
                  <Description>"Cross Faction Trade on AH"</Description>
                  <Color>804000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp word ptr [ebx+0x160],#42
je 0047d9bc

originalcode:
cmp cl,[ebx+0000012D]

exit:
jmp returnhere

"ps_game.exe"+7D9B0:
jmp newmem
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+7D9B0:
cmp cl,[ebx+0000012D]
//Alt: db 3A 8B 2D 01 00 00
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>631</ID>
                  <Description>"Cross Faction Whisper all maps"</Description>
                  <Color>804000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
0047f629:
db 90 90 90 90 90 90

0047ff69:
db 90 90 90 90 90 90


[DISABLE]
0047f629:
db 0F 85 DF 00 00 00

0047ff69:
db 0F 85 DF 00 00 00
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>630</ID>
                  <Description>"Cross Faction Inspect on AH"</Description>
                  <Color>804000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp word ptr [eax+0x160],#42
je 00477d4f

originalcode:
cmp cl,[eax+0000012D]

exit:
jmp returnhere

"ps_game.exe"+77D43:
jmp newmem
nop
returnhere:


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+77D43:
cmp cl,[eax+0000012D]
//Alt: db 3A 88 2D 01 00 00
</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>261</ID>
              <Description>"Drop Yourself (without party) - Random Drop fix"</Description>
              <Options moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>125</ID>
                  <Description>"Gold To Inventory"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
alloc(newmem,512)
label(returnhere)

label(solo)
label(solo_bonus)
label(solo_bonus_ok)
label(solo_bonus_wtc)
label(solo_bonus_rpc)

newmem:
mov eax, dword ptr [esp+44] // raid pointer
test eax,eax
je solo
jmp returnhere

solo:
mov edx, dword ptr [esp+40] // player pointer
test edx,edx
je 004BAE0D

cmp dword ptr [edx+594C],2
je solo_bonus_wtc
cmp dword ptr [edx+594C],3
je solo_bonus_rpc

solo_bonus_ok:
mov ecx, dword ptr [esp+18]
call 0046BBA0
jmp 004BAEB8

solo_bonus:
sub esp,4
fild dword ptr [esp+1C]
fld dword ptr [esp]
fmul st(1),st(0)
fstp dword ptr [esp]
fistp dword ptr [esp+1C]
add esp,4
jmp solo_bonus_ok

solo_bonus_wtc:
mov dword ptr [esp-4],(float)1.200 // White Tiger Charm = +20%
jmp solo_bonus

solo_bonus_rpc:
mov dword ptr [esp-4],(float)1.500 // Red Phoenix Charm = +50%
jmp solo_bonus

004BAD4C:
jmp newmem
nop
nop
nop
nop
nop
nop
nop
returnhere:

[DISABLE]
dealloc(newmem)

004BAD4C:
mov eax, dword ptr [esp+44]
test eax,eax
je 004BAE0D
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>127</ID>
                  <Description>"Drop To Inventory"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
alloc(newmem,128)
label(returnhere)
label(solo)

newmem:
test ebp,ebp
je solo
jmp returnhere

solo:
mov ecx, dword ptr [esp+18]
test ecx,ecx
je 004BB438
push ebx
call 0046AE60
jmp 004BB47A

004BB1D5:
jmp newmem
nop
nop
nop
returnhere:

[DISABLE]
dealloc(newmem)

004BB1D5:
test ebp,ebp
je 004BB438
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>226</ID>
                  <Description>"Random Drop"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
alloc(newmem,1024)
label(returnhere)
label(originalcode)
label(exit)

define(stack_alloc,100)

// 4 bytes - global random drop count
// 4 bytes - x10,000 account random drop count
//alloc(player_random_drop_order,40004)
//define(accounts,#10000)

// ebp = raid
newmem:
cmp dword ptr [esp+18],0 // Killer
je originalcode

push ebx
sub esp,stack_alloc

mov esi,esp // store the stack pointer

// clear the memory
push stack_alloc
push 0
push esi
call msvcrt.memset
add esp,C

lea eax, dword ptr [ebp+118]
mov dword ptr [esi+stack_alloc-4],eax
push eax
call dword ptr [005540DC] // ntdll.RtlEnterCriticalSection

mov ecx, dword ptr [esi+stack_alloc+C] // mob
xor ebx,ebx

random_next:
mov edx, dword ptr [ebp+ebx*8+18]

cmp edx, dword ptr [esi+stack_alloc+1C]
je random_ok // skip all further checks for killer

push edx
push ecx
call func_is_player_within_range
test eax,eax
je random_next_check

random_ok:
mov eax, dword ptr [esi+stack_alloc-8]
mov dword ptr [esi+eax*4],edx
inc dword ptr [esi+stack_alloc-8]

random_next_check:
inc ebx
cmp ebx, dword ptr [ebp+10]
jb random_next

call msvcrt.rand
cdq
idiv dword ptr [esi+stack_alloc-8]

mov edx, dword ptr [esi+edx*4]

push ebp
push edx
call func_get_player_index_in_party

mov edx,eax // index of player in party

mov eax, dword ptr [esi+stack_alloc-4]
push eax
call dword ptr [005540D4] // ntdll.RtlLeaveCriticalSection

exit:
add esp,stack_alloc
pop ebx
jmp returnhere

originalcode:
call 0051BD66
cdq
idiv dword ptr [ebp+10]
jmp returnhere

// push player
// push mob
// call func_is_player_within_range
func_is_player_within_range:
push ecx
push edx
push ebx
sub esp,4

xor eax,eax // clearing the return value (false)

mov ecx, dword ptr [esp+14] // mob
mov edx, dword ptr [esp+18] // player

// comparing zone pointers
mov ebx, dword ptr [ecx+8C]
cmp ebx, dword ptr [edx+E0]
jne func_is_player_within_range_exit

 // load mob.X
fld dword ptr [ecx+7C]
// subtract player.X from it
fsub dword ptr [edx+D0]
// get the absolute value
fabs
 // square it
fmul st(0),st(0)
// store result in the stack and pop floating point register
fstp dword ptr [esp]

// load mob.Z
fld dword ptr [ecx+84]
// subtract player.Z from it
fsub dword ptr [edx+D8]
// get the absolute value
fabs
// square it
fmul st(0),st(0)
// add the value previously stored in stack to it
fadd dword ptr [esp]

// square root
fsqrt
// store result in the stack and pop floating point register
fstp dword ptr [esp]

cmp dword ptr [esp],(float)100.000 // max range
ja func_is_player_within_range_exit

inc eax // set return value to true
func_is_player_within_range_exit:
add esp,4
pop ebx
pop edx
pop ecx
ret 8

// push party
// push player
// call func_get_player_index_in_party
func_get_player_index_in_party:
push ecx
push edx
push ebx

mov ecx, dword ptr [esp+10] // player
mov edx, dword ptr [esp+14] // party

mov eax, dword ptr [edx+10] // party member count

func_get_player_index_in_party_next:
dec eax

cmp dword ptr [edx+eax*8+18],ecx
je func_get_player_index_in_party_exit

test eax,eax
jne func_get_player_index_in_party_next

func_get_player_index_in_party_exit:
pop ebx
pop edx
pop ecx
ret 8

//player_random_drop_order:
//dd CCCCCCCC

004BB266:
jmp newmem
nop
nop
nop
nop
returnhere:

[DISABLE]
dealloc(newmem)
//dealloc(player_random_drop_order)

004BB266:
call 0051BD66
cdq
idiv dword ptr [ebp+10]
</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>476</ID>
              <Description>"rune_cutting"</Description>
              <Options moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>637</ID>
                  <Description>"jump_cutting"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//Bowie 06/2020
[ENABLE]
alloc(jump_cutting,32)
label(return)
{stand/sit/jump packet bytes
06 05 01 00 00 00 00 - stand
06 05 01 00 00 00 01 - sit
06 05 01 00 00 00 02 - jump}
jump_cutting:
mov cl,[ebp+02]
cmp cl,02
//stops sending jump packets
je 00479155
//original code
mov [esp+22],edx
jmp return

0047894D:
jmp jump_cutting
nop
nop
return:

[DISABLE]
dealloc(jump_cutting)
0047894D:
mov cl,[ebp+02]
mov [esp+22],edx
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>635</ID>
                  <Description>"bootleggery"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//by Bowie
[ENABLE]
alloc(newmem,32)
label(return)

newmem:
cmp dword ptr [ebp+00001270],02
je 0047468A
//original code
cmp dword ptr [eax+000001A4],00
jmp return

00473ED7:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00473ED7:
cmp dword ptr [eax+000001A4],00
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>115</ID>
                  <Description>"arena recall"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//by Bowie
[ENABLE]
alloc(newmem,32)
label(return)

newmem:
cmp dword ptr [ebp+00001270],02
je 0047468A
//original code
cmp dword ptr [eax+000001A4],00
jmp return

00473FFD:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00473FFD:
cmp dword ptr [eax+000001A4],00
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>636</ID>
                  <Description>"capital recall"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//by Bowie
[ENABLE]
alloc(newmem,32)
label(return)

newmem:
cmp dword ptr [ebp+00001270],02
je 0047468A
//original code
cmp dword ptr [eax+000001A4],00
jmp return

00473DB0:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00473DB0:
cmp dword ptr [eax+000001A4],00
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>474</ID>
                  <Description>"guild house"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//by Bowie
[ENABLE]
alloc(newmem,32)
label(return)

newmem:
cmp dword ptr [ebp+00001270],02
je 004742B6
//original code
cmp dword ptr [eax+000001A4],06
jmp return

00474196:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00474196:
cmp dword ptr [eax+000001A4],06
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>475</ID>
                  <Description>"party summon"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//by [DEV]AkaneTendo
[ENABLE]
alloc(newmem,32)
label(return)

newmem:
cmp dword ptr [ebp+00001270],02
je 0047468A
//original code
cmp dword ptr [ebp+000058B8],00
jmp return

00473400:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00473400:
cmp dword ptr [ebp+000058B8],00
</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>639</ID>
              <Description>"Dex fix "</Description>
              <Options moHideChildren="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>224</ID>
                  <Description>"DEX Override (Melee)"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(pop_originalcode)
label(originalcode)
label(success)

define(dex_per_percent,#12)
define(min_accuracy,#20)

// edi = attacker
// esi = target
newmem:
cmp byte ptr [edi+1385],1
je originalcode

push eax
push ecx
push edx
sub esp,10

mov eax, dword ptr [edi+1220]
mov ecx, dword ptr [esi+1220]

cmp eax,ecx
ja success

sub eax,ecx
mov dword ptr [esp],eax
mov dword ptr [esp+4],dex_per_percent
fild dword ptr [esp+4] // dex_per_percent
fild dword ptr [esp] // DEX difference
fabs
fdiv st(0), st(1)
fistp dword ptr [esp]
fistp dword ptr [esp+4]

mov esi,#100
sub esi, dword ptr [esp]

cmp esi,min_accuracy
jae pop_originalcode

mov esi,min_accuracy

pop_originalcode:
add esp,10
pop edx
pop ecx
pop eax

originalcode:
cmp esi,01
jmp returnhere

success:
mov esi,#100
jmp pop_originalcode

00463D4B:
jmp newmem
returnhere:

[DISABLE]
dealloc(newmem)

00463D4B:
mov esi,eax
cmp esi,01
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>225</ID>
                  <Description>"DEX Override (Ranged)"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(pop_originalcode)
label(originalcode)
label(success)

define(dex_per_percent,#12)
define(min_accuracy,#20)

// edi = attacker
// esi = target
newmem:
cmp byte ptr [edi+1395],1
je originalcode

push eax
push ecx
push edx
sub esp,10

mov eax, dword ptr [edi+1220]
mov ecx, dword ptr [esi+1220]

cmp eax,ecx
ja success

sub eax,ecx
mov dword ptr [esp],eax
mov dword ptr [esp+4],dex_per_percent
fild dword ptr [esp+4] // dex_per_percent
fild dword ptr [esp] // DEX difference
fabs
fdiv st(0), st(1)
fistp dword ptr [esp]
fistp dword ptr [esp+4]

mov esi,#100
sub esi, dword ptr [esp]

cmp esi,min_accuracy
jae pop_originalcode

mov esi,min_accuracy

pop_originalcode:
add esp,10
pop edx
pop ecx
pop eax

originalcode:
cmp esi,01
jmp returnhere

success:
mov esi,#100
jmp pop_originalcode

00463C9D:
jmp newmem
returnhere:

[DISABLE]
dealloc(newmem)

00463C9D:
mov esi,eax
cmp esi,01
</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>741</ID>
          <Description>"Leader ress in 10sec"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{
    Onur Tok
}
[ENABLE]
ps_game.exe+78EA2:
add eax,#2000

[DISABLE]
ps_game.exe+78EA2:
add eax,#30000
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>236</ID>
          <Description>"Guild"</Description>
          <Options moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1" moAllowManualCollapseAndExpand="1"/>
          <Color>000080</Color>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>238</ID>
              <Description>"Creation"</Description>
              <Options moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1" moAllowManualCollapseAndExpand="1"/>
              <Color>000080</Color>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>237</ID>
                  <Description>"Require only 3 people to be in the party"</Description>
                  <Color>000080</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
//place your code here

originalcode:
cmp eax,03

exit:
jmp returnhere

"ps_game.exe"+850A8:
jmp newmem
nop
nop
nop
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+850A8:
cmp eax,07
jg ps_game.exe+8520C
//Alt: db 83 F8 03 0F 8F 5B 01 00 00
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>239</ID>
                  <Description>"Require only 3 people to accept the guild creation request"</Description>
                  <Color>000080</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
//place your code here

originalcode:
cmp dword ptr [esi+24],03
jl ps_game.exe+85456

exit:
jmp returnhere

"ps_game.exe"+8542C:
jmp newmem
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+8542C:
cmp dword ptr [esi+24],07
jl ps_game.exe+85456
//Alt: db 83 7E 24 03 7C 24
</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>173</ID>
              <Description>"Guild Officer Count"</Description>
              <Color>000080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]

0043491B:
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop

[DISABLE]

0043491B:
cmp dword ptr [edi+3C],7
jnl 00434A09
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>183</ID>
              <Description>"Guild Penalty Remove"</Description>
              <Color>000080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]

0048598F:
jmp 004859C8
nop
nop
nop
nop
nop
nop
nop

[DISABLE]

0048598F:
cmp dword ptr [ebp+5580],0
je 004859C8
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>209</ID>
              <Description>"Allow Entering GRB More Than Once"</Description>
              <Color>000080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]

004569CB:
nop
nop
nop
nop
nop
nop

[DISABLE]

004569CB:
mov dword ptr [ebx+5584],eax
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>229</ID>
          <Description>"Admin &amp; GM Restrictions"</Description>
          <Options moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
          <Color>800000</Color>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>241</ID>
              <Description>"Admins see both faction trade chats"</Description>
              <Color>FF0000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
cmp byte ptr [ecx+5808],0B
JL "ps_game.exe"+27944

originalcode:
cmp dl,[ecx+0000012D]

exit:
jmp returnhere

"ps_game.exe"+27938:
jmp newmem
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+27938:
cmp dl,[ecx+0000012D]
//Alt: db 3A 91 2D 01 00 00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>134</ID>
              <Description>"/silence CharName on"</Description>
              <Color>800000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,64)

label(silence_on)
label(ret_silence_on)
label(oc_silence_on)

label(silence_off)
label(ret_silence_off)
label(oc_silence_off)

newmem:

silence_on:
mov byte ptr [esi+16A],2

oc_silence_on:
mov dword ptr [esi+581C],FFFFFFFF
jmp ret_silence_on

silence_off:
mov byte ptr [eax+16A],0

oc_silence_off:
mov dword ptr [eax+581C],edi
jmp ret_silence_off

00483DD6:
jmp silence_on
nop
nop
nop
nop
nop
ret_silence_on:

00483E4D:
jmp silence_off
nop
ret_silence_off:

[DISABLE]
dealloc(newmem)

00483DD6:
mov dword ptr [esi+581C],FFFFFFFF

00483E4D:
mov dword ptr [eax+581C],edi
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>31</ID>
              <Description>"Ability to attack both factions"</Description>
              <Color>800000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(exit)

newmem:
cmp byte ptr [eax+5808],#10
jb 00457E35
cmp dl,[eax+0000012D]

exit:
jmp returnhere

"ps_game.exe"+57E2D:
jmp newmem
nop
returnhere:

[DISABLE]
dealloc(newmem)
"ps_game.exe"+57E2D:
cmp dl,[eax+0000012D]
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>157</ID>
              <Description>"Allow Join Manual Raid (Admin, GM)"</Description>
              <Color>800000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,128)

label(check_raid_auto_1)
label(ret_check_raid_auto_1)

label(check_raid_auto_2)
label(ret_check_raid_auto_2)

define(delta,3C0)

newmem:
check_raid_auto_1:
mov eax, dword ptr [edi+17F4]
cmp byte ptr [eax+114+delta],0
je 004757E7
cmp byte ptr [ebp+5808],2
jbe 004757F7
jmp ret_check_raid_auto_1

check_raid_auto_2:
cmp byte ptr [ebp+5808],2
jbe 00450507
cmp byte ptr [eax+115+delta],0
je 004504FA
jmp ret_check_raid_auto_2

004757D8:
jmp check_raid_auto_1
nop
ret_check_raid_auto_1:

004504FE:
jmp check_raid_auto_2
nop
nop
nop
nop
ret_check_raid_auto_2:

[DISABLE]
/*
004757D8:
mov eax, dword ptr [edi+17F4]

004504FE:
cmp byte ptr [eax+115],0
je 004504FA

dealloc(newmem)
*/
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>378</ID>
              <Description>"Allow Join Both Faction Raid (Admin, GM)"</Description>
              <Color>800000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,128)

newmem:
cmp byte ptr [ebp+5808],2
jbe 004757D8

originalcode:
mov dl, byte ptr [ebp+12D]
jmp returnhere

004757BA:
jmp newmem
nop
returnhere:

[DISABLE]

004757BA:
mov dl, byte ptr [ebp+12D]

dealloc(newmem)
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>307</ID>
          <Description>"Raid"</Description>
          <Options moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1" moAllowManualCollapseAndExpand="1"/>
          <Color>800080</Color>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>139</ID>
              <Description>"Raid Allocation Size"</Description>
              <Color>800080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]

00452253:
push 610

[DISABLE]
/*
00452253:
push 150
*/
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>141</ID>
              <Description>"Raid Memory Clear"</Description>
              <Color>800080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,64)
label(returnhere)
label(next)

define(delta,3C0)

0044E08B:
mov dword ptr [eax+104+delta],ebx
mov dword ptr [eax+108+delta],ebx
mov dword ptr [eax+10C+delta],ebx

0044E0A6:
mov edx,#150

0044E0C1:
mov byte ptr [eax+114+delta],bl
mov byte ptr [eax+115+delta],bl
mov dword ptr [eax+110+delta],1

newmem:
mov edx,510
next:
mov dword ptr [eax+edx],0
add edx,4
cmp edx,610
jb next
jmp returnhere

0044E0D7:
jmp newmem
returnhere:
pop ebx
ret

[DISABLE]
/*
0044E08B:
mov dword ptr [eax+104],ebx
mov dword ptr [eax+108],ebx
mov dword ptr [eax+10C],ebx

0044E0A6:
mov edx,1E

0044E0C1:
mov byte ptr [eax+114],bl
mov byte ptr [eax+115],bl
mov dword ptr [eax+110],1

0044E0D7:
pop ebx
ret
db CC CC CC CC CC

dealloc(newmem)
*/
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>142</ID>
              <Description>"Raid Memory Expansion"</Description>
              <Color>800080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]

define(delta,3C0)

00450CBB:
mov [edi+104+delta],eax

00450CC2:
cmp [edi+114+delta],al

0044E170:
mov al,[edi+114+delta]

0044ED70:
cmp byte ptr [eax+114+delta],1

0044E979:
mov al,[esi+114+delta]

0044E170:
mov al,[edi+114+delta]

0044E219:
mov [edi+10C+delta],eax

0044EC06:
mov cl,[ebx+114+delta]

004A1DBE:
mov al,[edi+114+delta]

004A1F15:
mov eax,[edi+10C+delta]

004BA98B:
cmp dword ptr [eax+104+delta],4

0049BC2D:
mov al,[esi+114+delta]

0049127B:
mov al,[ebx+114+delta]

004911AE:
mov cl,[ebx+114+delta]

0044E8C4:
mov al,[edi+114+delta]

0044EC75:
mov byte ptr [esi+114+delta],1

0044ECA8:
cmp eax,[esi+110+delta]

0044ECBF:
mov [esi+110+delta],eax

004758C7:
mov [edx+114+delta],al

004758D6:
mov [ecx+104+delta],edx

004758E6:
mov [eax+115+delta],cl

004758FC:
movzx eax,byte ptr [esi+114+delta]

00475907:
movzx ecx,byte ptr [esi+115+delta]

00475912:
mov edx,[esi+104+delta]

00475927:
mov edx,[esi+110+delta]

004759E4:
cmp byte ptr [eax+114+delta],0

004759F4:
mov [eax+115+delta],cl

00475A0A:
mov al,[esi+115+delta]

00475976:
cmp byte ptr [eax+114+delta],0

00475986:
mov [eax+104+delta],edx

00475D46:
cmp byte ptr [edi+114+delta],0

00475DA2:
mov ecx,[esi+110+delta]

00475A99:
cmp byte ptr [eax+114+delta],0

0044E5CE:
mov [esi+110+delta],eax
mov ecx,[esi+110+delta]

00475A4C:
cmp byte ptr [eax+114+delta],0

0044E6E5:
cmp edi,[esi+110+delta]

0044E708:
mov [esi+110+delta],eax
mov ecx,[esi+110+delta]

00475DF5:
cmp byte ptr [esi+114+delta],0

0044DFD5:
lea eax,[esi+118+delta]

00450719:
add esi,130+delta

0044F4E7:
lea eax,[ebp+118+delta]

0049B131:
lea edi,[esi+118+delta]

0049B15B:
lea ebx,[edi+118+delta]

0049B184:
add esi,118+delta

0044F24C:
lea eax,[ebp+118+delta]

0044DFE7:
lea eax,[esi+130+delta]

0044E967:
lea eax,[esi+118+delta]

004509DE:
add edi,130+delta

0049B1A6:
add esi,118+delta

0044E0E0:
add eax,118+delta

0044E0F0:
add eax,118+delta

0044E11C:
add eax,118+delta

0044E133:
add eax,118+delta

0044E156:
add eax,118+delta

0044EC8D:
lea edi,[esi+118+delta]

00475423:
add eax,118+delta

0044EB85:
lea edi,[ebx+118+delta]

00478862:
add eax,118+delta

0044E4C3:
lea ebx,[edi+118+delta]

0044E669:
lea ebx,[esi+118+delta]

0044E261:
lea edi,[esi+118+delta]

0044EDBE:
lea esi,[ebp+118+delta]

0044EF59:
mov ecx,[ebp+110+delta]

0044EF6B:
mov cl,[ebp+115+delta]

0044EF78:
mov cx,[ebp+104+delta]

0044EF88:
movzx eax,byte ptr [ebp+114+delta]

0044E1CB:
mov [edi+10C+delta],edx

0044F17A:
lea eax,[ebp+118+delta]

0044EA14:
lea edi,[ebx+118+delta]

0044F5F6:
cmp byte ptr [ecx+114+delta],1

0044F641:
lea eax,[ebx+118+delta]

0044F6B3:
cmp edi,[ebx+110+delta]

00450622:
add edi,130+delta

0044FA81:
lea eax,[ebx+118+delta]

0044FB22:
mov eax,[ebx+108+delta]

0044E8B7:
lea ebx,[edi+118+delta]

00450238:
lea eax,[ebx+118+delta]

0044E597:
lea edi,[esi+118+delta]

0047583A:
cmp byte ptr [esi+114+delta],0

0044FDEB:
lea eax,[ebx+118+delta]

0044FE57:
cmp edi,[ebx+110+delta]

0044FEE2:
mov eax,[ebx+108+delta]

0044FF83:
mov [ebx+110+delta],eax

00450129:
mov edx,[ebx+110+delta]

0044F734:
mov eax,[ebx+108+delta]

0044E2A0:
cmp byte ptr [esi+114+delta],0

0044E2AF:
lea edi,[esi+118+delta]

0044E2C2:
mov eax,[esi+110+delta]

0044E2F2:
lea edi,[esi+118+delta]

004757DE:
cmp byte ptr [eax+115+delta],0

004504F1:
cmp byte ptr [eax+114+delta],0

004504FE:
cmp byte ptr [eax+115+delta],0

00450521:
add edi,130+delta

004505A1:
add edi,130+delta

004506A1:
add edi,130+delta

00450B17:
add edi,130+delta

004A1DAD:
lea eax,[edi+118+delta]

004A1E3C:
mov eax,[edi+10C+delta]

0049130E:
mov cl,[ebx+114+delta]

00465F95:
lea ebp,[esi+118+delta]

00465FFF:
add esi,118+delta

0046583C:
lea eax,[ebx+118+delta]

0046584D:
mov al,[ebx+114+delta]

00467758:
lea eax,[esi+118+delta]

004677DC:
mov ebx,[esi+108+delta]

00467804:
mov [esi+108+delta],ebx

004659F9:
mov eax,[edx+10C+delta]

0049B1F3:
lea edi,[esi+118+delta]

0049B21F:
add esi,118+delta

0046A871:
mov al,[ecx+114+delta]

0044EAA4:
lea esi,[ebp+118+delta]

0046776F:
mov eax,[esi+104+delta]

0046B401:
mov al,[ecx+114+delta]

00467419:
add eax,118+delta

004677CA:
cmp [esi+108+delta],eax

0046783B:
inc [esi+108+delta]

004677D2:
mov [esi+108+delta],0

00465D80:
lea ebx,[esi+118+delta]

00465DB8:
mov al,[ebx+114+delta]

00465E05:
add esi,118+delta

0044E059:
add esi,118+delta

00460494:
add edi,118+delta

0046066D:
add edi,118+delta

00467443:
add eax,118+delta

00475658:
add eax,118+delta

00475CF0:
add eax,118+delta

00476926:
add eax,118+delta

00476991:
add eax,118+delta

00478EBF:
add eax,118+delta

0047F92E:
add eax,118+delta

00480266:
add eax,118+delta

00482D6A:
add eax,118+delta

00482E2E:
add eax,118+delta

00483C42:
add eax,118+delta

00483C6F:
add eax,118+delta

004851CF:
add eax,118+delta

00485395:
add eax,118+delta

004856D0:
add eax,118+delta

0049093C:
add edi,118+delta

00490A4D:
add edi,118+delta

00490B5D:
add edi,118+delta

00490D3E:
add edi,118+delta

004912DA:
add edi,118+delta

00491807:
add ebp,118+delta

0049190D:
add esi,118+delta

0049B1BF:
add esi,118+delta

0049B232:
add esi,118+delta

0049BC84:
add ebx,118+delta

0049E589:
add eax,118+delta

004C6B30:
add eax,118+delta

004C6B54:
add eax,118+delta

00550A13:
add ecx,118+delta

00550A43:
add ecx,118+delta

005516F3:
add ecx,118+delta

004BAFE2:
cmp dword ptr [ebp+104+delta],4

004BB1DD:
cmp byte ptr [ebp+114+delta],1

004BB1E6:
cmp dword ptr [ebp+104+delta],4

004BB25B:
mov eax,[ebp+104+delta]

004BB2F0:
cmp [ebp+108+delta],eax

004BB302:
mov esi,[ebp+108+delta]

004BB370:
inc [ebp+108+delta]

004BB2F8:
mov [ebp+108+delta],0

004BB327:
mov [ebp+108+delta],esi

0044FB2D:
mov [ebx+108+delta],eax

00450B09:
mov eax,[edi+148+delta]

00450B11:
mov esi,[edi+130+delta]

0044E379:
lea edi,[ebp+118+delta]

0049BBEF:
lea esi,[ebx+118+delta]

0049124A:
lea ebx,[edi+118+delta]

0044E7C8:
lea ebp,[esi+118+delta]

0044FB61:
cmp byte ptr [ebx+114+delta],1

00450307:
cmp byte ptr [ebx+114+delta],1

004908D4:
lea ebx,[edi+118+delta]

00491767:
lea eax,[ebp+118+delta]

004917A4:
mov al,[edx+114+delta]

00490C8A:
lea ebx,[edi+118+delta]

00490CBF:
mov al,[ebx+114+delta]

004919C1:
mov al,[ebx+114+delta]

00491A12:
lea edi,[ebx+118+delta]

00490905:
mov al,[ebx+114+delta]

004909E5:
lea ebx,[edi+118+delta]

00490A16:
mov al,[ebx+114+delta]

00490AF5:
lea ebx,[edi+118+delta]

00490B26:
mov al,[ebx+114+delta]

004F22C1:
cmp dword ptr [ecx+118+delta],0

004F22D1:
mov ecx,[ecx+118+delta]

0044F71A:
mov edx,[ebx+110+delta]

0044F725:
mov [ebx+110+delta],edx

0044F792:
mov edx,[ebx+110+delta]

0044F7C2:
mov [ebx+110+delta],eax

0044F969:
mov edx,[ebx+110+delta]

00455C69:
cmp byte ptr [ecx+114+delta],1

0044FEC8:
mov edx,[ebx+110+delta]

0044F76E:
cmp byte ptr [ebx+114+delta],1

0044FF2F:
cmp byte ptr [ebx+114+delta],1

004604B4:
mov dl,[ecx+114+delta]

0047F95F:
cmp byte ptr [edi+114+delta],0

0047F971:
mov ecx,[edi+110+delta]

00475D5C:
mov edx,[edi+110+delta]

0049E4C6:
cmp byte ptr [ebx+114+delta],1

004609E0:
lea ebx,[esi+118+delta]

004734A2:
lea eax,[esi+118+delta]

0044E322:
lea edi,[esi+118+delta]

0044E331:
cmp [esi+114+delta],bl

0044E34A:
mov eax,[esi+110+delta]

0044E551:
lea edi,[esi+118+delta]

0044E567:
cmp eax,[esi+110+delta]

0044E611:
lea edi,[esi+118+delta]

0044E62C:
cmp eax,[esi+110+delta]

0044E645:
mov [esi+110+delta],eax

004600EE:
lea ebp,[esi+118+delta]

00460272:
lea esi,[ebp+118+delta]

0046028E:
mov cl,[ebp+114+delta]

0046083E:
lea ebp,[esi+118+delta]

00460B87:
lea edi,[esi+118+delta]

00491876:
lea ebx,[esi+118+delta]

004918AB:
mov al,[edx+114+delta]

0044F73F:
mov [ebx+108+delta],eax

0044ED43:
cmp byte ptr [ecx+114+delta],0

0044ED4D:
mov esi,[ecx+108+delta]

0044ECD0:
mov [eax+115+delta],cl

0044ECE0:
mov [eax+104+delta],ecx

0044ECE0:
mov [eax+104+delta],ecx

0044FEED:
mov [ebx+108+delta],eax

0044FF53:
mov edx,[ebx+110+delta]

00467869:
mov [esi+108+delta],0
mov ebx,[esi+108+delta]

0046789B:
mov [esi+108+delta],ebx

004678C4:
inc [esi+108+delta]

004BB39F:
mov [ebp+108+delta],0
mov esi,[ebp+108+delta]

004BB3D3:
mov [ebp+108+delta],esi

004BB424:
inc [ebp+108+delta]

004BB397:
cmp [ebp+108+delta],eax

0044FED3:
mov [ebx+110+delta],edx

00467861:
cmp [esi+108+delta],eax

[DISABLE]
/*
00450CBB:
mov [edi+104],eax

00450CC2:
cmp [edi+114],al

0044E170:
mov al,[edi+114]

0044ED70:
cmp byte ptr [eax+114],1

0044E979:
mov al,[esi+114]

0044E170:
mov al,[edi+114]

0044E219:
mov [edi+10C],eax

0044EC06:
mov cl,[ebx+114]

004A1DBE:
mov al,[edi+114]

004A1F15:
mov eax,[edi+10C]

004BA98B:
cmp dword ptr [eax+104],4

0049BC2D:
mov al,[esi+114]

0049127B:
mov al,[ebx+114]

004911AE:
mov cl,[ebx+114]

0044E8C4:
mov al,[edi+114]

0044EC75:
mov byte ptr [esi+114],1

0044ECA8:
cmp eax,[esi+110]

0044ECBF:
mov [esi+110],eax

004758C7:
mov [edx+114],al

004758D6:
mov [ecx+104],edx

004758E6:
mov [eax+115],cl

004758FC:
movzx eax,byte ptr [esi+114]

00475907:
movzx ecx,byte ptr [esi+115]

00475912:
mov edx,[esi+104]

00475927:
mov edx,[esi+110]

004759E4:
cmp byte ptr [eax+114],0

004759F4:
mov [eax+115],cl

00475A0A:
mov al,[esi+115]

00475976:
cmp byte ptr [eax+114],0

00475986:
mov [eax+104],edx

00475D46:
cmp byte ptr [edi+114],0

00475DA2:
mov ecx,[esi+110]

00475A99:
cmp byte ptr [eax+114],0

0044E5CE:
mov [esi+110],eax
mov ecx,[esi+110]

00475A4C:
cmp byte ptr [eax+114],0

0044E6E5:
cmp edi,[esi+110]

0044E708:
mov [esi+110],eax
mov ecx,[esi+110]

00475DF5:
cmp byte ptr [esi+114],0

0044DFD5:
lea eax,[esi+118]

00450719:
add esi,130

0044F4E7:
lea eax,[ebp+118]

0049B131:
lea edi,[esi+118]

0049B15B:
lea ebx,[edi+118]

0049B184:
add esi,118

0044F24C:
lea eax,[ebp+118]

0044DFE7:
lea eax,[esi+130]

0044E967:
lea eax,[esi+118]

004509DE:
add edi,130

0049B1A6:
add esi,118

0044E0E0:
add eax,118

0044E0F0:
add eax,118

0044E11C:
add eax,118

0044E133:
add eax,118

0044E156:
add eax,118

0044EC8D:
lea edi,[esi+118]

00475423:
add eax,118

0044EB85:
lea edi,[ebx+118]

00478862:
add eax,118

0044E4C3:
lea ebx,[edi+118]

0044E669:
lea ebx,[esi+118]

0044E261:
lea edi,[esi+118]

0044EDBE:
lea esi,[ebp+118]

0044EF59:
mov ecx,[ebp+110]

0044EF6B:
mov cl,[ebp+115]

0044EF78:
mov cx,[ebp+104]

0044EF88:
movzx eax,byte ptr [ebp+114]

0044E1CB:
mov [edi+10C],edx

0044F17A:
lea eax,[ebp+118]

0044EA14:
lea edi,[ebx+118]

0044F5F6:
cmp byte ptr [ecx+114],1

0044F641:
lea eax,[ebx+118]

0044F6B3:
cmp edi,[ebx+110]

00450622:
add edi,130

0044FA81:
lea eax,[ebx+118]

0044FB22:
mov eax,[ebx+108]

0044E8B7:
lea ebx,[edi+118]

00450238:
lea eax,[ebx+118]

0044E597:
lea edi,[esi+118]

0047583A:
cmp byte ptr [esi+114],0

0044FDEB:
lea eax,[ebx+118]

0044FE57:
cmp edi,[ebx+110]

0044FEE2:
mov eax,[ebx+108]

0044FF83:
mov [ebx+110],eax

00450129:
mov edx,[ebx+110]

0044F734:
mov eax,[ebx+108]

0044E2A0:
cmp byte ptr [esi+114],0

0044E2AF:
lea edi,[esi+118]

0044E2C2:
mov eax,[esi+110]

0044E2F2:
lea edi,[esi+118]

004757DE:
cmp byte ptr [eax+115],0

004504F1:
cmp byte ptr [eax+114],0

004504FE:
cmp byte ptr [eax+115],0

00450521:
add edi,130

004505A1:
add edi,130

004506A1:
add edi,130

00450B17:
add edi,130

004A1DAD:
lea eax,[edi+118]

004A1E3C:
mov eax,[edi+10C]

0049130E:
mov cl,[ebx+114]

00465F95:
lea ebp,[esi+118]

00465FFF:
add esi,118

0046583C:
lea eax,[ebx+118]

0046584D:
mov al,[ebx+114]

00467758:
lea eax,[esi+118]

004677DC:
mov ebx,[esi+108]

00467804:
mov [esi+108],ebx

004659F9:
mov eax,[edx+10C]

0049B1F3:
lea edi,[esi+118]

0049B21F:
add esi,118

0046A871:
mov al,[ecx+114]

0044EAA4:
lea esi,[ebp+118]

0046776F:
mov eax,[esi+104]

0046B401:
mov al,[ecx+114]

00467419:
add eax,118

004677CA:
cmp [esi+108],eax

0046783B:
inc [esi+108]

004677D2:
mov [esi+108],0

00465D80:
lea ebx,[esi+118]

00465DB8:
mov al,[ebx+114]

00465E05:
add esi,118

0044E059:
add esi,118

00460494:
add edi,118

0046066D:
add edi,118

00467443:
add eax,118

00475658:
add eax,118

00475CF0:
add eax,118

00476926:
add eax,118

00476991:
add eax,118

00478EBF:
add eax,118

0047F92E:
add eax,118

00480266:
add eax,118

00482D6A:
add eax,118

00482E2E:
add eax,118

00483C42:
add eax,118

00483C6F:
add eax,118

004851CF:
add eax,118

00485395:
add eax,118

004856D0:
add eax,118

0049093C:
add edi,118

00490A4D:
add edi,118

00490B5D:
add edi,118

00490D3E:
add edi,118

004912DA:
add edi,118

00491807:
add ebp,118

0049190D:
add esi,118

0049B1BF:
add esi,118

0049B232:
add esi,118

0049BC84:
add ebx,118

0049E589:
add eax,118

004C6B30:
add eax,118

004C6B54:
add eax,118

00550A13:
add ecx,118

00550A43:
add ecx,118

005516F3:
add ecx,118

004BAFE2:
cmp dword ptr [ebp+104],4

004BB1DD:
cmp byte ptr [ebp+114],1

004BB1E6:
cmp dword ptr [ebp+104],4

004BB25B:
mov eax,[ebp+104]

004BB2F0:
cmp [ebp+108],eax

004BB302:
mov esi,[ebp+108]

004BB370:
inc [ebp+108]

004BB2F8:
mov [ebp+108],0

004BB327:
mov [ebp+108],esi

0044FB2D:
mov [ebx+108],eax

00450B09:
mov eax,[edi+148]

00450B11:
mov esi,[edi+130]

0044E379:
lea edi,[ebp+118]

0049BBEF:
lea esi,[ebx+118]

0049124A:
lea ebx,[edi+118]

0044E7C8:
lea ebp,[esi+118]

0044FB61:
cmp byte ptr [ebx+114],1

00450307:
cmp byte ptr [ebx+114],1

004908D4:
lea ebx,[edi+118]

00491767:
lea eax,[ebp+118]

004917A4:
mov al,[edx+114]

00490C8A:
lea ebx,[edi+118]

00490CBF:
mov al,[ebx+114]

004919C1:
mov al,[ebx+114]

00491A12:
lea edi,[ebx+118]

00490905:
mov al,[ebx+114]

004909E5:
lea ebx,[edi+118]

00490A16:
mov al,[ebx+114]

00490AF5:
lea ebx,[edi+118]

00490B26:
mov al,[ebx+114]

004F22C1:
cmp dword ptr [ecx+118],0

004F22D1:
mov ecx,[ecx+118]

0044F71A:
mov edx,[ebx+110]

0044F725:
mov [ebx+110],edx

0044F792:
mov edx,[ebx+110]

0044F7C2:
mov [ebx+110],eax

0044F969:
mov edx,[ebx+110]

00455C69:
cmp byte ptr [ecx+114],1

0044FEC8:
mov edx,[ebx+110]

0044F76E:
cmp byte ptr [ebx+114],1

0044FF2F:
cmp byte ptr [ebx+114],1

004604B4:
mov dl,[ecx+114]

0047F95F:
cmp byte ptr [edi+114],0

0047F971:
mov ecx,[edi+110]

00475D5C:
mov edx,[edi+110]

0049E4C6:
cmp byte ptr [ebx+114],1

004609E0:
lea ebx,[esi+118]

004734A2:
lea eax,[esi+118]

0044E322:
lea edi,[esi+118]

0044E331:
cmp [esi+114],bl

0044E34A:
mov eax,[esi+110]

0044E551:
lea edi,[esi+118]

0044E567:
cmp eax,[esi+110]

0044E611:
lea edi,[esi+118]

0044E62C:
cmp eax,[esi+110]

0044E645:
mov [esi+110],eax

004600EE:
lea ebp,[esi+118]

00460272:
lea esi,[ebp+118]

0046028E:
mov cl,[ebp+114]

0046083E:
lea ebp,[esi+118]

00460B87:
lea edi,[esi+118]

00491876:
lea ebx,[esi+118]

004918AB:
mov al,[edx+114]

0044F73F:
mov [ebx+108],eax

0044ED43:
cmp byte ptr [ecx+114],0

0044ED4D:
mov esi,[ecx+108]

0044ECD0:
mov [eax+115],cl

0044ECE0:
mov [eax+104],ecx

0044ECE0:
mov [eax+104],ecx

0044FEED:
mov [ebx+108],eax

0044FF53:
mov edx,[ebx+110]

00467869:
mov [esi+108],0
mov ebx,[esi+108]

0046789B:
mov [esi+108],ebx

004678C4:
inc [esi+108]

004BB39F:
mov [ebp+108],0
mov esi,[ebp+108]

004BB3D3:
mov [ebp+108],esi

004BB424:
inc [ebp+108]

004BB397:
cmp [ebp+108],eax

0044FED3:
mov [ebx+110],edx

00467861:
cmp [esi+108],eax
*/
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>140</ID>
              <Description>"Raid Capacity"</Description>
              <Color>800080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,512)

label(raid_max_slots)
registersymbol(raid_max_slots)

newmem:

raid_max_slots:
dd #150

rc1:
push ecx
mov ecx, dword ptr [raid_max_slots]
cmp dword ptr [eax+10],ecx
pop ecx
jl 0047580D
jmp ret_rc1

rc2:
push eax
mov eax, dword ptr [raid_max_slots]
cmp dword ptr [ebp+10],eax
pop eax
push esi
jmp ret_rc2

rc3:
cmp eax, dword ptr [raid_max_slots]
jl 0044F587
jmp ret_rc3

rc4:
cmp eax, dword ptr [raid_max_slots]
mov [esp+24],eax
jmp ret_rc4

rc5:
cmp eax, dword ptr [raid_max_slots]
jl 0044E563
jmp ret_rc5

rc6:
cmp eax, dword ptr [raid_max_slots]
jl 0044ED58
jmp ret_rc6

rc7:
cmp eax, dword ptr [raid_max_slots]
jl 0044E6F4
jmp ret_rc7

rc8:
cmp esi, dword ptr [raid_max_slots]
jle 004658A4
jmp ret_rc8

rc9:
mov edi, dword ptr [raid_max_slots]
jmp ret_rc9

rc10:
mov edx, dword ptr [raid_max_slots]
jmp ret_rc10

rc11:
mov edi, dword ptr [raid_max_slots]
jmp ret_rc11

rc12:
mov edx, dword ptr [raid_max_slots]
jmp ret_rc12

rc13:
mov edx, dword ptr [raid_max_slots]
jmp ret_rc13

rc14:
cmp ecx, dword ptr [raid_max_slots]
jl 0044ED13
jmp ret_rc14

004757F7:
jmp rc1
nop
ret_rc1:

0044EDB0:
jmp rc2
ret_rc2:

0044F5A6:
jmp rc3
ret_rc3:

0044F128:
jmp rc4
nop
nop
ret_rc4:

0044E570:
jmp rc5
ret_rc5:

0044ED66:
jmp rc6
ret_rc6:

0044E701:
jmp rc7
ret_rc7:

0046589B:
jmp rc8
ret_rc8:

00475B1B:
jmp rc9
ret_rc9:

0045001B:
jmp rc10
ret_rc10:

00475E73:
jmp rc11
ret_rc11:

0044F85B:
jmp rc12
ret_rc12:

0044FC04:
jmp rc13
ret_rc13:

0044ED22:
jmp rc14
ret_rc14:

[DISABLE]
/*
004757F7:
cmp dword ptr [eax+10],1E
jl 0047580D

0044EDB0:
cmp dword ptr [ebp+10],1E
push esi

0044F5A6:
cmp eax,1E
jl 0044F587

0044F128:
cmp eax,1E
mov dword ptr [esp+24],eax

0044E570:
cmp eax,1E
jl 0044E563

0044ED66:
cmp eax,1E
jl 0044ED58

0044E701:
cmp eax,1E
jl 0044E6F4

0046589B:
cmp esi,1E
jle 004658A4

00475B1B:
mov edi,1E

0045001B:
mov edx,1E

00475E73:
mov edi,1E

0044F85B:
mov edx,1E

0044FC04:
mov edx,1E

0044ED22:
cmp ecx,1E
jl 0044ED13

unregistersymbol(raid_max_slots)
dealloc(newmem)
*/
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>379</ID>
              <Description>"Raid Organizers"</Description>
              <Color>800080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,1024)
define(move_ok,00475D6C)
define(move_fail,00475634)
define(delta,3C0)

newmem:
mov edx, dword ptr [edi+110+delta]
cmp dword ptr [edi+edx*8+18],ebp
je move_ok

push ebp
call func_get_player_slot_in_raid

cdq
mov ecx,#30
div ecx
cmp edx,#29

je is_raid_organizer

jmp move_fail

is_raid_organizer:
sub esp,18

mov dword ptr [esp],eax          // organizer raid
mov dword ptr [esp+4],edx        // organizer slot

mov eax, dword ptr [ebx+2]
cdq
mov ecx,#30
div ecx

mov dword ptr [esp+8],eax        // old raid
mov dword ptr [esp+C],edx        // old slot

mov eax, dword ptr [ebx+6]
cdq
mov ecx,#30
div ecx

mov dword ptr [esp+10],eax        // new raid
mov dword ptr [esp+14],edx        // new slot

// different raid
cmp eax, dword ptr [esp]
jne is_raid_organizer_move_fail

// different raid
mov eax, dword ptr [esp+8]
cmp eax, dword ptr [esp]
jne is_raid_organizer_move_fail

// organizer slot
cmp dword ptr [esp+C],#29
je is_raid_organizer_move_fail

// organizer slot
cmp dword ptr [esp+14],#29
je is_raid_organizer_move_fail

add esp,18
jmp move_ok

is_raid_organizer_move_fail:
add esp,18
jmp move_fail

// push player
func_get_player_slot_in_raid:
push ecx
push ebx
push edi

mov edx, dword ptr [esp+10] // player
mov edi, dword ptr [edx+17F4]
xor eax,eax

func_get_player_slot_in_raid_next:
cmp edx, dword ptr [edi+eax*8+18]
je func_get_player_slot_in_raid_found

inc eax
cmp eax, dword ptr [raid_max_slots]
jb func_get_player_slot_in_raid_next

mov eax,-1
jmp func_get_player_slot_in_raid_exit

func_get_player_slot_in_raid_found:
mov eax, dword ptr [edi+eax*8+14]

func_get_player_slot_in_raid_exit:
pop edi
pop ebx
pop ecx
ret 4

00475D5C:
jmp newmem
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop

[DISABLE]
/*
00475D5C:
mov edx, dword ptr [edi+110]
cmp dword ptr [edi+edx*8+18],ebp
jne 00475634
*/
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>380</ID>
              <Description>"Allow Raid Notice (Admin, GM)"</Description>
              <Color>800080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,1024)
define(raid_notice_ok,0047F97D)
define(raid_notice_fail,0047F922)
define(delta,3C0)

newmem:
mov ecx, dword ptr [edi+110+delta]
cmp dword ptr [edi+ecx*8+18],ebp
je raid_notice_ok

cmp byte ptr [ebp+5808],2
jbe raid_notice_ok

jmp raid_notice_fail

0047F971:
jmp newmem
nop
nop
nop
nop
nop
nop
nop

[DISABLE]
/*
0047F971:
mov ecx, dword ptr [edi+110]
cmp dword ptr [edi+ecx*8+18],ebp
jne 0047F922
*/
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>158</ID>
              <Description>"Raid Kick Restrictions (Admin, GM, Restricted Players)"</Description>
              <Color>800080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,1024)

label(raid_kick)
label(ret_raid_kick)
label(raid_kick_adm)
label(raid_kick_gm)
label(raid_kick_adm_notice)
label(raid_kick_gm_notice)

newmem:
raid_kick:
cmp byte ptr [eax+5808],1
je raid_kick_adm
cmp byte ptr [eax+5808],2
je raid_kick_gm

mov ebx, dword ptr [ebp+17F4]
jmp ret_raid_kick

raid_kick_adm:
push ecx
push edx
mov ecx,ebp
mov edx,raid_kick_adm_notice
push 34
push edx
call 004ED0E0
pop edx
pop ecx
jmp 00475417

raid_kick_gm:
push ecx
push edx
mov ecx,ebp
mov edx,raid_kick_gm_notice
push 30
push edx
call 004ED0E0
pop edx
pop ecx
jmp 00475417

raid_kick_adm_notice:
db 0B F9 31
db 'One does not simply kick an admin out of a raid.'
db 00

raid_kick_gm_notice:
db 0B F9 2D
db 'One does not simply kick a GM out of a raid.'
db 00

0047586C:
jmp raid_kick
nop
ret_raid_kick:

[DISABLE]

0047586C:
mov ebx, dword ptr [ebp+17F4]

dealloc(newmem)

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>377</ID>
              <Description>"Raid Notice Tag And Name"</Description>
              <Color>800080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,1024)
label(exit)

define(malloc_size,200)
define(delta,3C0)

// ebx = /raid packet
// ebp = player
newmem:
sub esp,4

// allocate memory
push malloc_size
call msvcrt.malloc
add esp,4

mov dword ptr [esp],eax

push malloc_size
push 0
push eax
call msvcrt.memset
add esp,C

push ebp
call func_get_player_role_in_raid

push eax
call func_get_tag_by_role_in_raid

test eax,eax
je concat_name

mov ecx, dword ptr [esp]

push eax
push ecx
call msvcrt.strcat
add esp,8

concat_name:
lea eax, dword ptr [ebp+184]
mov ecx, dword ptr [esp]

push eax
push ecx
call msvcrt.strcat
add esp,8

mov ecx, dword ptr [esp]

push string_colon
push ecx
call msvcrt.strcat
add esp,8

lea eax, dword ptr [ebx+3]
mov ecx, dword ptr [esp]

push eax
push ecx
call msvcrt.strcat
add esp,8

lea eax, dword ptr [ebx+3]
mov ecx, dword ptr [esp]

push ecx
push eax
call msvcrt.strcpy
add esp,8

lea eax, dword ptr [ebx+3]

push eax
call msvcrt.strlen
add esp,4

mov byte ptr [ebx+2],al

// free memory
mov ecx, dword ptr [esp]
push ecx
call msvcrt.free
add esp,4

exit:
mov al, byte ptr [ebx+2]
add esp,4

originalcode:
mov ecx, dword ptr [ebp+128]
jmp returnhere

// push playerPointer
// call func_get_player_role_in_raid
// eax = 0 =&gt; lead
// eax = 1 =&gt; sub-lead
// eax = 2 =&gt; member
func_get_player_role_in_raid:
push ecx
push edx
push ebx

mov ecx, dword ptr [esp+10] // get player
mov ebx, dword ptr [ecx+17F4] // get raid

xor eax,eax

mov edx, dword ptr [ebx+C] // get leader index
mov edx, dword ptr [ebx+edx*8+18] // get leader pointer

cmp ecx,edx
je func_get_player_role_in_raid_exit

inc eax

mov edx, dword ptr [ebx+110+delta] // get sub-leader index
mov edx, dword ptr [ebx+edx*8+18] // get sub-leader pointer

cmp ecx,edx
je func_get_player_role_in_raid_exit

inc eax

func_get_player_role_in_raid_exit:
pop ebx
pop edx
pop ecx
ret 4

// push roleInRaid
// call func_get_tag_by_role_in_raid
func_get_tag_by_role_in_raid:
push ecx

mov ecx, dword ptr [esp+8]

mov eax,tag_leader

test ecx,ecx
je func_get_tag_by_role_in_raid_exit

mov eax,tag_sub_leader

dec ecx
je func_get_tag_by_role_in_raid_exit

xor eax,eax

func_get_tag_by_role_in_raid_exit:
pop ecx
ret 4

tag_leader:
db '[L]' 0

tag_sub_leader:
db '[S-L]' 0

string_colon:
db ':' 0

0047F995:
jmp newmem
nop
returnhere:

[DISABLE]

0047F995:
mov ecx, dword ptr [ebp+128]

dealloc(newmem)
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>260</ID>
              <Description>"Shared PvP Kills"</Description>
              <Color>800080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)
label(M1)
label(M2)
label(M3)
label(M4)
label(M5)
label(M6)
label(M7)
label(M8)
label(M9)

newmem:
pushad
mov edi,esi
mov edx,[esi+000000E0]
xor ecx,ecx
mov cl,[esi+0000012D]
cmp ecx,01
je setzero
mov ecx,01
jmp gocall
setzero:
mov ecx,00
gocall:
push ecx
push edx
call ShareKill
popad
originalcode:

exit:
jmp 00465ACF

ShareKill:
sub esp,10 { 16 }
push ebx
push ebp
mov ebp,[esp+1C]
push esi
call dword ptr [ps_game.exe+1540D0] { -&gt;kernel32.GetTickCount }
lea esi,[ebp+0000018C]
mov ebx,eax
push esi
add ebx,000003E8 { 1000 }
mov [esp+1C],esi
call dword ptr [ps_game.exe+1540DC] { -&gt;ntdll.RtlEnterCriticalSection }
mov ecx,[ebp+00000184]
mov eax,[ecx+04]
mov [ebp+00000188],eax
cmp eax,ecx
je M1
test eax,eax
je M1
M8:
mov eax,[eax+08]
test eax,eax
je M2
lea esi,[eax-000000D0]
jmp M3
M2:
xor esi,esi
M3:
// cmp byte ptr [esi+00005808],0A { if ( *(_BYTE *)(v8 + 22376) &gt; 0xAu )}
//ja M4
//mov eax,[ebp+00000188] {  v6 = (CObjectLink *)CZone-&gt;m_listUser.cursor-&gt;next;}
//mov eax,[eax+04]
//jmp M6

M4:
cmp edi,esi
jne M5
mov ecx,[ebp+00000188]
mov eax,[ecx+04]
jmp M6
M5:
mov dl,[esp+24]
cmp [esi+0000012D],dl { if ( *(_BYTE *)(v8 + 301) == byCountry )}
jne M9
// NEW CODE HERE //
fld dword ptr [edi+000000D0]
push ecx
fsub dword ptr [esi+000000D0]
fstp dword ptr [esp+14]
fld dword ptr [edi+000000D8]
fsub dword ptr [esi+000000D8]
fstp dword ptr [esp+24]
fld dword ptr [esp+24]
fld dword ptr [esp+14]
fmul st(0),st(0)
fld st(1)
fmulp st(2),st(0)
faddp
fstp dword ptr [esp+24]
fld dword ptr [esp+24]
fstp dword ptr [esp]
call ps_game.exe+1B8A0
fcomp dword ptr [RangeFloat] { [300.00] }
add esp,04 { 00000004 }
fnstsw ax
sahf
//test ah,41 { 65 }
jae M9 { if ( v11 &gt; 10.0 )}
//Need check party
cmp [esi+000017F4],00
je M9
mov ecx,esi
push edi
call ps_game.exe+67CE0
//               //
M9:
mov edx,[ebp+00000188]
mov eax,[edx+04]
M6:
cmp eax,[ebp+00000184] { while ( v6 != CZone-&gt;m_listUser.head &amp;&amp; v6 );}
mov [ebp+00000188],eax
je M7
test eax,eax
jne M8
M7:
mov esi,[esp+18] { v4 = &amp;this-&gt;m_listUser.m_csList.m_cs;}
M1:
push esi
call dword ptr [ps_game.exe+1540D4] { -&gt;ntdll.RtlLeaveCriticalSection }
pop esi
pop ebp
pop ebx
add esp,10 { 16 }
ret 0008 { 00000008 }

RangeFloat:
dd 42C80000

"ps_game.exe"+65AAD:
jmp newmem
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+65AAD:
call ps_game.exe+67EE0
//Alt: db E8 2E 24 00 00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>634</ID>
              <Description>"Leader Summon Raid"</Description>
              <Color>800080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(ItemSummonRaid)
label(checkcountry)
label(failed)
label(exit)
label(checkleader)
newmem:
call ps_game.exe+4ECF0
//esi=target player,edi=source player
//check map
originalcode:
pushad
movzx eax,word ptr [esi+0x160]
movzx ebx,word ptr [edi+0x160]
cmp eax,(int)45
je checkcountry
cmp ebx,(int)45
je checkcountry

jmp ItemSummonRaid

//checkcountry and check if same map
checkcountry:
cmp eax,ebx        //if they are in the same map which we speicifys
je ItemSummonRaid

movzx eax,byte ptr [esi+0x12d]
movzx ebx,byte ptr [edi+0x12d]
cmp eax,ebx
jne failed

/*
push eax               //party table
push ecx               //leader id
mov eax,[edi+17f4]
mov ecx,[eax+0c]       //leader id
imul ecx,ecx,8
add  ecx,18
mov  ecx,[eax+ecx]   //leader address
cmp edi,ecx          //compare address check is leader
pop ecx
pop eax
je 0049e4ea        //if yes
*/

ItemSummonRaid:

mov eax,dword ptr ds:[edi+0x58FC]
mov ecx,dword ptr ds:[edi+0x5900]
lea eax,dword ptr ds:[eax+eax*2]     // eax=bag,ecx=slot
lea edx,dword ptr ds:[ecx+eax*8]
imul edx,edx,4
mov eax,dword ptr ds:[edi+edx+0x1C0]
mov eax,dword ptr ds:[eax+30]
cmp [eax],(int)100045                 //orginal item id
popad
jne checkleader   //success addr
/*
mov eax,dword ptr ds:[eax+0x30]
cmp byte ptr ds:[eax+0x46],0x1F
*/



exit:
jmp returnhere

checkleader:
push eax               //party table
push ecx               //leader id
mov eax,[edi+17f4]
mov ecx,[eax+0c]       //leader id
imul ecx,ecx,8
add  ecx,18
mov  ecx,[eax+ecx]   //leader address
cmp edi,ecx          //compare address check is leader
pop ecx
pop eax
je 0049e4ea        //if yes
jmp 0049E517

failed:
popad
jmp 0049E517



"ps_game.exe"+9E4E1:

jmp newmem

returnhere:

[DISABLE]

//code from here till the end of the code will be used to disable the cheat

dealloc(newmem)

"ps_game.exe"+9E4E1:

call ps_game.exe+4ECF0

//Alt: db E8 0A 08 FB FF
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>381</ID>
          <Description>"Costume &amp; Weap Skins"</Description>
          <Options moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
          <Color>03447E</Color>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>382</ID>
              <Description>"Slots"</Description>
              <Options moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
              <Color>03447E</Color>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>1</ID>
                  <Description>"Extra Inventory Slots (Costume, Weapon Skin)"</Description>
                  <Color>03447E</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
alloc(newmem,256)

newmem:

slot14:
cmp byte ptr [esi+24],#91
je 0046846B
jmp fail

slot15:
cmp byte ptr [esi+24],#92
je 0046846B
jmp fail

jumps:
dd 004683C2
dd 004683D3
dd 004683E4
dd 004683F1

dd 004683FE
dd 00468395
dd 0046840B
dd 0046842D

dd 0046843A
dd 00468447
dd 00468447
dd 00468454

dd 00468454
dd 00468461
dd slot14 // 14
dd slot15 // 15

dd fail
dd fail
dd fail
dd 004684C6

fail:
xor al,al
pop esi
ret

0046838E:
jmp dword ptr [eax*4+jumps]

00468387:
db #15

0046862D:
db #16

00468955:
db #16

004685E6:
cmp ebx,0D
jnl 00468610

004685FD:
cmp eax,0D
jnl 0046861E

[DISABLE]

0046838E:
jmp dword ptr [eax*4+0046853C]

00468387:
db 0D

0046862D:
db 0E

00468955:
db 0E

004685E6:
cmp ebx,0D
jnl 00468610

004685FD:
cmp eax,0D
jnl 0046861E

dealloc(newmem)
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>2</ID>
                  <Description>"Item Equip (Costume, Weapon Skin)"</Description>
                  <Color>03447E</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
alloc(newmem,256)

newmem:

item_equip:
mov dword ptr [esi+ebx*4+1C0],ecx

cmp ebx,#14
je costume

cmp ebx,#15
je wep_skin

jmp ret_item_equip

costume:
push eax

push 0
mov ecx,esi
call 00492C00

push 1
mov ecx,esi
call 00492C00

push 2
mov ecx,esi
call 00492C00

push 3
mov ecx,esi
call 00492C00

push 4
mov ecx,esi
call 00492C00

pop eax
jmp ret_item_equip

wep_skin:
push eax

push 5
mov ecx,esi
call 00492C00

push 6
mov ecx,esi
call 00492C00

pop eax
jmp ret_item_equip

004689B5:
jmp item_equip
nop
nop
ret_item_equip:

[DISABLE]

004689B5:
mov dword ptr [esi+ebx*4+1C0],ecx

dealloc(newmem)
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>3</ID>
                  <Description>"Item Remove (Costume, Weapon Skin)"</Description>
                  <Color>03447E</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
alloc(newmem,256)

newmem:

item_remove:
mov dword ptr [esi+ebx*4+1C0],edi

cmp ebx,#14
je costume

cmp ebx,#15
je wep_skin

jmp ret_item_remove

costume:
push eax
push edx

push 0
mov ecx,esi
call 00492C00

push 1
mov ecx,esi
call 00492C00

push 2
mov ecx,esi
call 00492C00

push 3
mov ecx,esi
call 00492C00

push 4
mov ecx,esi
call 00492C00

pop edx
pop eax
jmp ret_item_remove

wep_skin:
push eax
push edx

push 5
mov ecx,esi
call 00492C00

push 6
mov ecx,esi
call 00492C00

pop edx
pop eax
jmp ret_item_remove

004686D0:
jmp item_remove
nop
nop
ret_item_remove:

[DISABLE]

004686D0:
mov dword ptr [esi+ebx*4+1C0],edi

dealloc(newmem)
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>8</ID>
                  <Description>"Item Swap (Costume, Weapon Skin)"</Description>
                  <Color>03447E</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
alloc(newmem,256)

newmem:

item_swap:
mov dword ptr [esi+ebx*4+1C0],edx

cmp ebx,#14
je costume

cmp ebx,#15
je wep_skin

jmp ret_item_swap

costume:
push eax

push 0
mov ecx,esi
call 00492C00

push 1
mov ecx,esi
call 00492C00

push 2
mov ecx,esi
call 00492C00

push 3
mov ecx,esi
call 00492C00

push 4
mov ecx,esi
call 00492C00

pop eax
jmp ret_item_swap

wep_skin:
push eax

push 5
mov ecx,esi
call 00492C00

push 6
mov ecx,esi
call 00492C00

pop eax
jmp ret_item_swap

00468AE3:
jmp item_swap
nop
nop
ret_item_swap:

[DISABLE]

00468AE3:
mov dword ptr [esi+ebx*4+1C0],edx

dealloc(newmem)
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>25</ID>
                  <Description>"Display Equip Item (Costume, Weapon Skin)"</Description>
                  <Color>03447E</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
alloc(newmem,1024)

newmem:
packet_0303:
cmp dword ptr [ebx+1C0+4*E],0 // E = 14 = costume slot
jne costume_item
costume_after:

cmp dword ptr [ebx+1C0+4*F],0 // F = 15 = weapon skin slot
jne wep_skin_item
wep_skin_after:

oc_packet_0303:
mov eax, dword ptr [ebx+1DC]
jmp ret_packet_0303

costume_item:
mov eax, dword ptr [ebx+1C0+4*E] // E = 14 = costume slot
mov cl,#72

mov byte ptr [esp+49],cl
inc cl
mov byte ptr [esp+4C],cl
inc cl
mov byte ptr [esp+4F],cl
add cl,2
mov byte ptr [esp+52],cl
inc cl
mov byte ptr [esp+55],cl

mov cl, byte ptr [eax+41]

mov byte ptr [esp+4A],cl
mov byte ptr [esp+4D],cl
mov byte ptr [esp+50],cl
mov byte ptr [esp+53],cl
mov byte ptr [esp+56],cl

mov byte ptr [esp+4B],0
mov byte ptr [esp+4E],0
mov byte ptr [esp+51],0
mov byte ptr [esp+54],0
mov byte ptr [esp+57],0

jmp costume_after


wep_skin_item:
mov eax, dword ptr [ebx+1C0+4*F] // F = 15 = weapon skin slot
movzx eax, byte ptr [eax+41]

mov ecx, dword ptr [ebx+1C0+4*5]
test ecx,ecx
je shield_item
movzx ecx, byte ptr [ecx+40]
cmp ecx,#15
ja shield_item
lea ecx, dword ptr [wep_skin_item_type_table+ecx*2]
call func_get_original_country_from_family_and_add_to_ecx
movzx ecx, byte ptr [ecx]
mov byte ptr [esp+58],cl
mov byte ptr [esp+59],al

shield_item:
mov ecx, dword ptr [ebx+1C0+4*6]
test ecx,ecx
je wep_skin_after
movzx ecx, byte ptr [ecx+40]
cmp ecx,#19
je shield_item_type_ok
cmp ecx,#34
je shield_item_type_ok
jmp wep_skin_after

shield_item_type_ok:
lea ecx, dword ptr [wep_skin_item_type_table+ecx*2]
call func_get_original_country_from_family_and_add_to_ecx
movzx ecx, byte ptr [ecx]
mov byte ptr [esp+58],cl
mov byte ptr [esp+59],al

jmp wep_skin_after

func_get_original_country_from_family_and_add_to_ecx:
push eax

movzx eax, byte ptr [ebx+12E]

cmp ecx,3
ja func_get_country_from_family_and_add_to_ecx_exit

movzx eax, byte ptr [family_to_original_country_table+eax]
add cl,al

func_get_country_from_family_and_add_to_ecx_exit:
pop eax
ret

family_to_original_country_table:
db 0 // 0 - Human
db 0 // 1 - Elf
db 1 // 2 - Vail
db 1 // 3 - Deatheater

wep_skin_item_type_table:
db 00 00
db #45 #45 // 1
db #46 #46 // 2
db #45 #45 // 3
db #46 #46 // 4
db #49 #49 // 5
db #51 #51 // 6
db #53 #53 // 7
db #55 #55 // 8
db #57 #57 // 9
db #58 #58 // 10
db #59 #59 // 11
db #60 #60 // 12
db #62 #62 // 13
db #64 #64 // 14
db #65 #65 // 15

db #16 #16 // 16
db #17 #17 // 17
db #18 #18 // 18

db #69 #69 // 19

db #20 #20 // 20
db #21 #21 // 21
db #22 #22 // 22
db #23 #23 // 23
db #24 #24 // 24
db #25 #25 // 25
db #26 #26 // 26
db #27 #27 // 27
db #28 #28 // 28
db #29 #29 // 29
db #30 #30 // 30
db #31 #31 // 31
db #32 #32 // 32
db #33 #33 // 33

db #69 #69 // 34

db #35 #35 // 35
db #36 #36 // 36

00426C34:
jmp packet_0303
nop
ret_packet_0303:

[DISABLE]

00426C34:
mov eax, dword ptr [ebx+1DC]

dealloc(newmem)
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26</ID>
                  <Description>"Display Equip Items (Costume, Weapon Skin)"</Description>
                  <Color>03447E</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
alloc(newmem,512)

newmem:

packet_0705:
cmp ebx,4
jle costume
cmp ebx,6
jle wep_skin

oc_packet_0705:
cmp dword ptr [ecx+ebx*4+1C0],0
je 00492CBE
jmp ret_packet_0705

costume:
mov eax, dword ptr [ecx+1C0+4*E] // E = 14 = costume slot
test eax,eax
jne costume_item

jmp oc_packet_0705

costume_item:
movzx eax, byte ptr [eax+41]
mov byte ptr [esp+14],al
movzx eax, byte ptr [costume_item_slot_type_table+ebx]
mov byte ptr [esp+13],al
jmp 00492CC8

wep_skin:
mov eax, dword ptr [ecx+1C0+4*0F] // 0F = 15 = weapon skin slot
test eax,eax
jne wep_skin_item

jmp oc_packet_0705

wep_skin_item:
lea eax, dword ptr [ebx*4]
add eax,ecx
add eax,1C0
cmp dword ptr [eax],0
je oc_packet_0705
mov esi, dword ptr [eax]
movzx eax, byte ptr [esi+40]
cmp eax,#15 // allowed weapon types on player: 1 to 15
jbe wep_skin_item_type_found
cmp eax,#19 // allowed shield type
je wep_skin_item_type_found
cmp eax,#34 // allowed shield type
je wep_skin_item_type_found

jmp oc_packet_0705

wep_skin_item_type_found:
lea eax, dword ptr [wep_skin_item_type_table+eax*2]
call func_get_original_country_from_family_and_add_to_eax
movzx eax, byte ptr [eax]
mov byte ptr [esp+13],al
mov eax, dword ptr [ecx+1C0+4*0F]
movzx eax, byte ptr [eax+41]
mov byte ptr [esp+14],al

lea eax, dword ptr [esi+4C]
jmp 00492C53

func_get_original_country_from_family_and_add_to_eax:
push ecx

movzx ecx, byte ptr [ecx+12E]

cmp ecx,3
ja func_get_country_from_family_and_add_to_eax_exit

movzx ecx, byte ptr [family_to_original_country_table+ecx]
add al,cl

func_get_country_from_family_and_add_to_eax_exit:
pop ecx
ret

family_to_original_country_table:
db 0 // 0 - Human
db 0 // 1 - Elf
db 1 // 2 - Vail
db 1 // 3 - Deatheater

costume_item_slot_type_table:
db #72
db #73
db #74
db #76
db #77

wep_skin_item_type_table:
db 00 00
db #45 #45 // 1
db #46 #46 // 2
db #45 #45 // 3
db #46 #46 // 4
db #49 #49 // 5
db #51 #51 // 6
db #53 #53 // 7
db #55 #55 // 8
db #57 #57 // 9
db #58 #58 // 10
db #59 #59 // 11
db #60 #60 // 12
db #62 #62 // 13
db #64 #64 // 14
db #65 #65 // 15

db #16 #16 // 16
db #17 #17 // 17
db #18 #18 // 18

db #69 #69 // 19

db #20 #20 // 20
db #21 #21 // 21
db #22 #22 // 22
db #23 #23 // 23
db #24 #24 // 24
db #25 #25 // 25
db #26 #26 // 26
db #27 #27 // 27
db #28 #28 // 28
db #29 #29 // 29
db #30 #30 // 30
db #31 #31 // 31
db #32 #32 // 32
db #33 #33 // 33

db #84 #84 // 34

db #35 #35 // 35
db #36 #36 // 36

00492C19:
nop
nop
nop
nop
nop
nop
nop
nop

00492C35:
jmp packet_0705
nop
ret_packet_0705:

[DISABLE]

00492C19:
cmp dword ptr [ecx+ebx*4+1C0],0

00492C35:
je 00492CBE

dealloc(newmem)
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>306</ID>
                  <Description>"Skip grow check on item equip"</Description>
                  <Color>03447E</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{
Author: Cups, 7th March 2018

Skips the check for a character's game mode, when equipping an item.
}
[ENABLE]

// Jump to the check for "special", and ignore the game mode checks
ps_game.exe+684E3:
jmp ps_game.exe+68515
db 90 90 90 90 90

[DISABLE]

// Original game mode check begins here
ps_game.exe+684E3:
movzx ecx,byte ptr [edi+0000012F]
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>257</ID>
                  <Description>"Remove cap on link chance"</Description>
                  <Color>03447E</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
ps_game.exe+6E733:
cmp esi,#100
jle 0046E73D
mov esi,#100

[DISABLE]

ps_game.exe+6E733:
cmp esi,#50
jle 0046E73D
mov esi,#50
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>363</ID>
                  <Description>"Prevent Cape Enchant"</Description>
                  <Color>03447E</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]

0046C9F8:
je 0046CAB7

[DISABLE]

0046C9F8:
je 0046CAB2
</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>436</ID>
              <Description>"Buff-Costumes"</Description>
              <Options moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
              <Color>03447E</Color>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>6</ID>
                  <Description>"Look"</Description>
                  <Color>03447E</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)
label(costume)
label(costumeweap)
label(nothing)
label(weap)
label(t45)
label(t46)
label(t49)
label(t51)
label(t53)
label(t55)
label(t57)
label(t58)
label(t59)
label(t60)
label(t62)
label(t64)
label(t65)

newmem: //this is allocated memory, you have read,write,execute access
cmp word ptr [ebx+164],0
jne originalcode
cmp word ptr [ebx+166],0
jne weap
jmp nothing

costume:

mov dl,byte ptr[ebx+164]
//add dl,(int)99

//mov dl,[esi+41]
lea eax,[esi+4C]
cmp byte ptr [ebx+12d],0
jne dark
add [edi-01],(int)50
jmp exit
dark:
add [edi-01],(int)35
jmp exit

costumeweap:

mov dl,byte ptr[ebx+166]

//mov dl,[esi+41]
lea eax,[esi+4C]
cmp byte ptr [edi-01],(int)1
je t45
cmp byte ptr [edi-01],(int)3
je t45
cmp byte ptr [edi-01],(int)2
je t46
cmp byte ptr [edi-01],(int)4
je t46
cmp byte ptr [edi-01],(int)5
je t49
cmp byte ptr [edi-01],(int)6
je t51
cmp byte ptr [edi-01],(int)7
je t53
cmp byte ptr [edi-01],(int)8
je t55
cmp byte ptr [edi-01],(int)9
je t57
cmp byte ptr [edi-01],(int)10
je t58
cmp byte ptr [edi-01],(int)11
je t59
cmp byte ptr [edi-01],(int)12
je t60
cmp byte ptr [edi-01],(int)13
je t62
cmp byte ptr [edi-01],(int)14
je t64
cmp byte ptr [edi-01],(int)15
je t65
jmp exit

t45:
mov [edi-01],(int)45
jmp exit
t46:
mov [edi-01],(int)46
jmp exit
t49:
mov [edi-01],(int)49
jmp exit
t51:
mov [edi-01],(int)51
jmp exit
t53:
mov [edi-01],(int)53
jmp exit
t55:
mov [edi-01],(int)55
jmp exit
t57:
mov [edi-01],(int)57
jmp exit
t58:
mov [edi-01],(int)58
jmp exit
t59:
mov [edi-01],(int)59
jmp exit
t60:
mov [edi-01],(int)60
jmp exit
t62:
mov [edi-01],(int)62
jmp exit
t64:
mov [edi-01],(int)64
jmp exit
t65:
mov [edi-01],(int)65
jmp exit


nothing:
mov dl,[esi+41]
lea eax,[esi+4C]
jmp exit

originalcode:
cmp [ebx+0*4+1c0],esi
je costume
cmp [ebx+1*4+1c0],esi
je costume
cmp [ebx+2*4+1c0],esi
je costume
cmp [ebx+3*4+1c0],esi
je costume
cmp [ebx+4*4+1c0],esi
je costume
cmp [ebx+f*4+1c0],0
jne weap
jmp nothing

weap:
cmp [ebx+5*4+1c0],esi
je costumeweap
jmp nothing




exit:
jmp returnhere

"ps_game.exe"+26BD1:
jmp newmem
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+26BD1:
mov dl,[esi+41]
lea eax,[esi+4C]
//Alt: db 8A 56 41 8D 46 4C
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>10</ID>
                  <Description>"Costume"</Description>
                  <Color>03447E</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)
label(dark)
label(costumeweap)
label(t45)
label(t46)
label(t49)
label(t51)
label(t53)
label(t55)
label(t57)
label(t58)
label(t59)
label(t60)
label(t62)
label(t64)
label(t65)


newmem: //this is allocated memory, you have read,write,execute access
cmp ebx,5
je costumeweap
cmp ebx,4
jg originalcode
cmp word ptr [ecx+164],0
je originalcode
cmp word ptr [ecx+164],FF
ja originalcode
//costume typeid change
mov dl,byte ptr[ecx+164]
//add dl,(int)99
////
//mov dl,[esi+41]
lea eax,[esi+4C]

cmp byte ptr [ecx+12d],0
jne dark
add [esp+13],(int)50
jmp exit
dark:
add [esp+13],(int)35
jmp exit

costumeweap:
cmp word ptr [ecx+166],0
je originalcode
cmp word ptr [ecx+166],ff
ja originalcode

mov dl,byte ptr[ecx+166]

//mov dl,[esi+41]
lea eax,[esi+4C]
cmp byte ptr [esp+13],(int)1
je t45
cmp byte ptr [esp+13],(int)3
je t45
cmp byte ptr [esp+13],(int)2
je t46
cmp byte ptr [esp+13],(int)4
je t46
cmp byte ptr [esp+13],(int)5
je t49
cmp byte ptr [esp+13],(int)6
je t51
cmp byte ptr [esp+13],(int)7
je t53
cmp byte ptr [esp+13],(int)8
je t55
cmp byte ptr [esp+13],(int)9
je t57
cmp byte ptr [esp+13],(int)10
je t58
cmp byte ptr [esp+13],(int)11
je t59
cmp byte ptr [esp+13],(int)12
je t60
cmp byte ptr [esp+13],(int)13
je t62
cmp byte ptr [esp+13],(int)14
je t64
cmp byte ptr [esp+13],(int)15
je t65
jmp exit

t45:
mov [esp+13],(int)45
jmp exit
t46:
mov [esp+13],(int)46
jmp exit
t49:
mov [esp+13],(int)49
jmp exit
t51:
mov [esp+13],(int)51
jmp exit
t53:
mov [esp+13],(int)53
jmp exit
t55:
mov [esp+13],(int)55
jmp exit
t57:
mov [esp+13],(int)57
jmp exit
t58:
mov [esp+13],(int)58
jmp exit
t59:
mov [esp+13],(int)59
jmp exit
t60:
mov [esp+13],(int)60
jmp exit
t62:
mov [esp+13],(int)62
jmp exit
t64:
mov [esp+13],(int)64
jmp exit
t65:
mov [esp+13],(int)65
jmp exit

originalcode:
mov dl,[esi+41]
lea eax,[esi+4C]
jmp exit


exit:
jmp returnhere

"ps_game.exe"+92C49:
jmp newmem
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+92C49:
mov dl,[esi+41]
lea eax,[esi+4C]
//Alt: db 8A 56 41 8D 46 4C
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>9</ID>
                  <Description>"Prevent multicostume"</Description>
                  <Color>03447E</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)
label(costumeweap)

newmem: //this is allocated memory, you have read,write,execute access
cmp [esi+84],(int)5000
jl originalcode
cmp [esi+84],(int)5500
jg costumeweap
cmp word ptr [ebp+164],0
je originalcode
jmp 00473142

costumeweap:
cmp [esi+84],(int)6500
jg originalcode
cmp word ptr [ebp+166],0
je originalcode
jmp 00473142

originalcode:
cmp byte ptr [esi+44],00
je ps_game.exe+73142

exit:
jmp returnhere

"ps_game.exe"+72F89:
jmp newmem
nop
nop
nop
nop
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+72F89:
cmp byte ptr [esi+44],00
je ps_game.exe+73142
//Alt: db 80 7E 44 00 0F 84 AF 01 00 00
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>437</ID>
                  <Description>"Costume pop"</Description>
                  <Color>03447E</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
costume:
		cmp dword ptr [ebx+84],(int)5001
		jl originalcode
		cmp dword ptr [ebx+84],(int)5255
		jg weaponcheck
		push eax
		mov eax, [ebx+84]
		sub eax, (int)5000
		mov [edi+164], eax
		pop eax
		//UPDATE DB
		//pushad
		//movzx  ecx, word ptr[edi+128]  // char id
		//push ecx
		//mov ecx, [edi+9d0]
		//push ecx
		//call dwUpdateCostume
		//add esp, 8
		//popad
		//
		pushad
		pushfd
		mov esi, edi
		mov edx, 0
		push edx
		mov ecx, esi
		mov ebx, 0
		mov eax, 0
		mov ebp, dword ptr[esi+1c0]
		call 00492C00
		popfd
		popad
		pushad
		pushfd
		mov esi, edi
		mov edx, 1
		push edx
		mov ecx, esi
		mov ebx, 1
		mov eax, 0
		mov ebp, dword ptr[esi+4+1c0]
		call 00492C00
		popfd
		popad
		pushad
		pushfd
		mov esi, edi
		mov edx, 2
		push edx
		mov ecx, esi
		mov ebx, 2
		mov eax, 0
		mov ebp, dword ptr[esi+8+1c0]
		call 00492C00
		popfd
		popad
		pushad
		pushfd
		mov esi, edi
		mov edx, 3
		push edx
		mov ecx, esi
		mov ebx, 3
		mov eax, 0
		mov ebp, dword ptr[esi+3*4+1c0]
		call 00492C00
		popfd
		popad
		pushad
		pushfd
		mov esi, edi
		mov edx, 4
		push edx
		mov ecx, esi
		mov ebx, 4
		mov eax, 0
		mov ebp, dword ptr[esi+4*4+1c0]
		call 00492C00
		popfd
		popad
		jmp originalcode

	weaponcheck:
		cmp dword ptr [ebx+84], (int)6255
			jg originalcode
			cmp dword ptr [ebx+84], (int)6001
			jl originalcode
			push eax
			mov eax, [ebx+84]
			sub eax, (int)6000
			mov [edi+166], eax
			pop eax

			//pushad
			//movzx  ecx, word ptr[edi+128]  // char id
			//push ecx
			//movzx ecx, word ptr [edi+166]
			//push ecx
			//call dwUpdateWeapCostume
			//add esp, 8
			//popad

			pushad
			pushfd
			mov esi, edi
			mov edx, 5
			push edx
			mov ecx, esi
			mov ebx, 5
			mov eax, 0
			mov ebp, dword ptr[esi+5*4+1c0]
			call 00492C00
			popfd
			popad

originalcode:
mov edx,[esp+00000B5C]

exit:
jmp returnhere

"ps_game.exe"+730AF:
jmp newmem
nop
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+730AF:
mov edx,[esp+00000B5C]
//Alt: db E9 FC 29 2E 6F
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>7</ID>
                  <Description>"Costume Relog"</Description>
                  <Color>03447E</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
pushad
			pushfd
			//mov esi, edi
			mov edx, 0
			push edx
			mov ecx, esi
			mov ebx, 0
			mov eax, 0
			mov ebp, dword ptr[esi+1c0]
			call 0492C00
			popfd
			popad
			pushad
			pushfd
			//mov esi, edi
			mov edx, 1
			push edx
			mov ecx, esi
			mov ebx, 1
			mov eax, 0
			mov ebp, dword ptr[esi+4+1c0]
			call 0492C00
			popfd
			popad
			pushad
			pushfd
			//mov esi, edi
			mov edx, 2
			push edx
			mov ecx, esi
			mov ebx, 2
			mov eax, 0
			mov ebp, dword ptr[esi+8+1c0]
			call 0492C00
			popfd
			popad
			pushad
			pushfd
			//mov esi, edi
			mov edx, 3
			push edx
			mov ecx, esi
			mov ebx, 3
			mov eax, 0
			mov ebp, dword ptr[esi+3*4+1c0]
			call 0492C00
			popfd
			popad
			pushad
			pushfd
			//mov esi, edi
			mov edx, 4
			push edx
			mov ecx, esi
			mov ebx, 4
			mov eax, 0
			mov ebp, dword ptr[esi+4*4+1c0]
			call 0492C00
			popfd
			popad
			pushad
			pushfd
			//mov esi, edi
			mov edx, 5
			push edx
			mov ecx, esi
			mov ebx, 5
			mov eax, 0
			mov ebp, dword ptr[esi+5*4+1c0]
			call 0492C00
			popfd
			popad


originalcode:
fld dword ptr [esi+000000D0]
jmp 455EC7

exit:
jmp returnhere

"ps_game.exe"+55EC1:
jmp newmem
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+55EC1:
fld dword ptr [esi+000000D0]
//Alt: db D9 86 D0 00 00 00
</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>641</ID>
      <Description>"FFA"</Description>
      <VariableType>4 Bytes</VariableType>
      <Address>FFA</Address>
      <CheatEntries>
        <CheatEntry>
          <ID>321</ID>
          <Description>"RVR"</Description>
          <Options moRecursiveSetValue="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>322</ID>
              <Description>"All red"</Description>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr [ebp+160],(int)86 //MapID
jne originalcode2
push eax
mov ecx, [ebx+000017F4]
cmp ecx, 0
je code
mov eax, [ebp+000017F4]
cmp eax, 0
je code
cmp eax, ecx
jne code
movzx ecx, byte ptr [ebp+0000012D] //kogo gryzit
jmp originalcode
code:
movzx ecx, byte ptr [ebx+0000012D] //kogo gryzit
movzx eax, byte ptr [ebp+0000012D] //komy otpravit
cmp eax, ecx
jne originalcode
cmp eax, 1
jne ex
mov cl, 0
jmp originalcode
ex:
mov cl, 1
originalcode:
pop eax
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]

exit:
jmp returnhere
originalcode2:
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
jmp exit

"ps_game.exe"+26B17:
jmp newmem
nop
nop
nop
nop
nop
nop
returnhere:

 
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+26B17:
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>12</ID>
              <Description>"party kick"</Description>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
add dword ptr [ebx+10],-01
push edi
mov edi,[esp+18]
cmp byte ptr [edi+160],(int)86 //MapID
jne originalcode2
pop edi

mov eax,0
zanovo:
pushad
push eax
sub esp,128
mov ecx,[esp+128+20+18]
mov ebx,[eax*8+esi+18]
cmp ecx,ebx
je sameCharacter
push ecx
mov ecx,[ebx+000000DC]
mov eax,00000303 { 771 }
mov [esp+34],ax
mov [esp+36],ecx
movzx eax,byte ptr [ebx+0000144C]
movzx ecx,byte ptr [ebx+0000012D]
sete dl
mov [esp+3A],dl
movzx edx,byte ptr [ebx+0000012E]
mov [esp+3B],al
movzx eax,byte ptr [ebx+00000131]
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
mov [esp+3D],dl
movzx edx,byte ptr [ebx+00000133]
mov [esp+3E],al
movzx eax,byte ptr [ebx+00000134]
mov [esp+3F],cl
movzx ecx,byte ptr [ebx+00000135]
push ebx
mov [esp+44],dl
mov [esp+45],al
mov [esp+46],cl
call ps_game.exe+9B120
movzx edx,byte ptr [ebx+0000012F]
mov ecx,[ebx+00000184]
mov [esp+43],al
mov eax,[ebx+00000148]
mov [esp+45],eax
mov eax,[ebx+0000018C]
mov [esp+44],dl
mov edx,[ebx+00000188]
mov [esp+69],eax
movzx eax,byte ptr [ebx+00000198]
mov [esp+61],ecx
mov ecx,[ebx+00000190]
mov [esp+65],edx
mov edx,[ebx+00000194]
mov [esp+75],al
mov [esp+6D],ecx
mov [esp+71],edx
mov byte ptr [esp+75],00 { 0 }
lea edi,[esp+4A]
lea ebp,[ebx+000001C0]
mov [esp+14],00000008 { 8 }
label5:
cmp dword ptr [ebp+00],00 { 0 }
je label1
mov esi,[ebp+00]
mov cl,[esi+40]
mov [edi-01],cl
mov dl,[esi+41]
lea eax,[esi+4C]
mov [edi],dl
lea edx,[eax+01]
lea esp,[esp+00]
label2:
mov cl,[eax]
inc eax
test cl,cl
jne label2
sub eax,edx
cmp eax,14 { 20 }
jne label3
mov al,[esi+5E]
cmp al,30 { 48 }
jl label3
cmp al,39 { 57 }
jg label3
mov cl,[esi+5F]
cmp cl,30 { 48 }
jl label3
cmp cl,39 { 57 }
jg label3
sub al,30 { 48 }
mov dl,0A { 10 }
imul dl
add al,cl
sub al,30 { 48 }
mov [edi+01],al
jmp label4
label3:
xor al,al
mov [edi+01],al
jmp label4
label1:
mov byte ptr [edi-01],00 { 0 }
mov byte ptr [edi],00 { 0 }
mov byte ptr [edi+01],00 { 0 }
label4:
add ebp,04 { 4 }
add edi,03 { 3 }
sub dword ptr [esp+14],01 { 1 }
jne label5
mov eax,[ebx+000001DC]
jmp label6
mov ecx,[eax+46]
mov [esp+76],ecx
mov dx,[eax+4A]
lea eax,[esp+7C]
push eax
mov [esp+7E],dx
call ps_game.exe+84F50
lea eax,[esp+7C]
lea edx,[eax+01]
nop
label7:
mov cl,[eax]
inc eax
test cl,cl
jne label7
sub eax,edx
add eax,49 { 73 }
lea ecx,[esp+38]
jmp label10
label6:
lea edx,[esp+76]
push edx
call ps_game.exe+84F50
lea eax,[esp+76]
lea edx,[eax+01]
label9:
mov cl,[eax]
inc eax
test cl,cl
jne label9
//mov edi,0
//mov esi,ebx
lea ebx,[ebx+18]
label10:
pop ecx
mov eax,50
push eax
lea eax,[esp+34]
push eax
movzx eax, byte ptr [ecx+0000012D]
cmp al,1
je odina
mov al,1
jmp asda
odina:
mov al,0
asda:
mov [esp+40],al
call ps_game.exe+ED0E0 //send
sameCharacter:
add esp,128
pop eax
popad
inc eax
cmp eax,[ebx+10]
jl zanovo

pushad
sub esp,128
mov ebx,[esp+128+20+14]
mov ecx,[ebx+000000DC]
mov eax,00000303 { 771 }
mov [esp+34],ax
mov [esp+36],ecx
movzx eax,byte ptr [ebx+0000144C]
movzx ecx,byte ptr [ebx+0000012D]
sete dl
mov [esp+3A],dl
movzx edx,byte ptr [ebx+0000012E]
mov [esp+3B],al
movzx eax,byte ptr [ebx+00000131]
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
mov [esp+3D],dl
movzx edx,byte ptr [ebx+00000133]
mov [esp+3E],al
movzx eax,byte ptr [ebx+00000134]
mov [esp+3F],cl
movzx ecx,byte ptr [ebx+00000135]
push ebx
mov [esp+44],dl
mov [esp+45],al
mov [esp+46],cl
call ps_game.exe+9B120
movzx edx,byte ptr [ebx+0000012F]
mov ecx,[ebx+00000184]
mov [esp+43],al
mov eax,[ebx+00000148]
mov [esp+45],eax
mov eax,[ebx+0000018C]
mov [esp+44],dl
mov edx,[ebx+00000188]
mov [esp+69],eax
movzx eax,byte ptr [ebx+00000198]
mov [esp+61],ecx
mov ecx,[ebx+00000190]
mov [esp+65],edx
mov edx,[ebx+00000194]
mov [esp+75],al
mov [esp+6D],ecx
mov [esp+71],edx
mov byte ptr [esp+75],00 { 0 }
lea edi,[esp+4A]
lea ebp,[ebx+000001C0]
mov [esp+14],00000008 { 8 }
labell5:
cmp dword ptr [ebp+00],00 { 0 }
je labell1
mov esi,[ebp+00]
mov cl,[esi+40]
mov [edi-01],cl
mov dl,[esi+41]
lea eax,[esi+4C]
mov [edi],dl
lea edx,[eax+01]
lea esp,[esp+00]
labell2:
mov cl,[eax]
inc eax
test cl,cl
jne labell2
sub eax,edx
cmp eax,14 { 20 }
jne labell3
mov al,[esi+5E]
cmp al,30 { 48 }
jl labell3
cmp al,39 { 57 }
jg labell3
mov cl,[esi+5F]
cmp cl,30 { 48 }
jl labell3
cmp cl,39 { 57 }
jg labell3
sub al,30 { 48 }
mov dl,0A { 10 }
imul dl
add al,cl
sub al,30 { 48 }
mov [edi+01],al
jmp labell4
labell3:
xor al,al
mov [edi+01],al
jmp labell4
labell1:
mov byte ptr [edi-01],00 { 0 }
mov byte ptr [edi],00 { 0 }
mov byte ptr [edi+01],00 { 0 }
labell4:
add ebp,04 { 4 }
add edi,03 { 3 }
sub dword ptr [esp+14],01 { 1 }
jne labell5
mov eax,[ebx+000001DC]
jmp labell6
mov ecx,[eax+46]
mov [esp+76],ecx
mov dx,[eax+4A]
lea eax,[esp+7C]
push eax
mov [esp+7E],dx
call ps_game.exe+84F50
lea eax,[esp+7C]
lea edx,[eax+01]
nop
labell7:
mov cl,[eax]
inc eax
test cl,cl
jne labell7
sub eax,edx
add eax,49 { 73 }
lea ecx,[esp+38]
jmp labell10
labell6:
lea edx,[esp+76]
push edx
call ps_game.exe+84F50
lea eax,[esp+76]
lea edx,[eax+01]
labell9:
mov cl,[eax]
inc eax
test cl,cl
jne labell9
mov edx,ebx
mov edi,0
mov ebx,[esp+120]
mov esi,ebx
lea ebx,[ebx+18]
labell10:
mov ecx,[ebx]
cmp ecx,edx
je labell11
test ecx,ecx
je labell11
sub eax,edx
mov eax,50
push eax
lea eax,[esp+38]
push eax
movzx eax, byte ptr [ecx+0000012D]
cmp al,1
je odinaa
mov al,1
jmp asdaa
odinaa:
mov al,0
asdaa:
mov [esp+3C+8],al
call ps_game.exe+ED0E0 //send
labell11:
add edi,01 { 1 }
add ebx,08 { 8 }
cmp edi,[esi+10]
jl labell10
originalcode:
add esp,00000128 { 296 }
popad
mov eax,[ebx+10]

exit:
jmp returnhere

originalcode2:
pop edi
mov eax,[ebx+10]
jmp exit

"ps_game.exe"+502DE:
jmp newmem
nop
nop
returnhere:

 
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+502DE:
add dword ptr [ebx+10],-01
mov eax,[ebx+10]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>323</ID>
              <Description>"party leave"</Description>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
add dword ptr [ebx+10],-01
push edi
mov edi,[esp+28]
cmp byte ptr [edi+160],(int)86 //MapID
jne originalcode2
pop edi
mov eax,0
zanovo:
pushad
push eax
sub esp,128
mov ecx,[esp+128+20+28]
mov ebx,[eax*8+esi+18]
cmp ecx,ebx
je sameCharacter
push ecx
mov ecx,[ebx+000000DC]
mov eax,00000303 { 771 }
mov [esp+34],ax
mov [esp+36],ecx
movzx eax,byte ptr [ebx+0000144C]
movzx ecx,byte ptr [ebx+0000012D]
sete dl
mov [esp+3A],dl
movzx edx,byte ptr [ebx+0000012E]
mov [esp+3B],al
movzx eax,byte ptr [ebx+00000131]
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
mov [esp+3D],dl
movzx edx,byte ptr [ebx+00000133]
mov [esp+3E],al
movzx eax,byte ptr [ebx+00000134]
mov [esp+3F],cl
movzx ecx,byte ptr [ebx+00000135]
push ebx
mov [esp+44],dl
mov [esp+45],al
mov [esp+46],cl
call ps_game.exe+9B120
movzx edx,byte ptr [ebx+0000012F]
mov ecx,[ebx+00000184]
mov [esp+43],al
mov eax,[ebx+00000148]
mov [esp+45],eax
mov eax,[ebx+0000018C]
mov [esp+44],dl
mov edx,[ebx+00000188]
mov [esp+69],eax
movzx eax,byte ptr [ebx+00000198]
mov [esp+61],ecx
mov ecx,[ebx+00000190]
mov [esp+65],edx
mov edx,[ebx+00000194]
mov [esp+75],al
mov [esp+6D],ecx
mov [esp+71],edx
mov byte ptr [esp+75],00 { 0 }
lea edi,[esp+4A]
lea ebp,[ebx+000001C0]
mov [esp+14],00000008 { 8 }
label5:
cmp dword ptr [ebp+00],00 { 0 }
je label1
mov esi,[ebp+00]
mov cl,[esi+40]
mov [edi-01],cl
mov dl,[esi+41]
lea eax,[esi+4C]
mov [edi],dl
lea edx,[eax+01]
lea esp,[esp+00]
label2:
mov cl,[eax]
inc eax
test cl,cl
jne label2
sub eax,edx
cmp eax,14 { 20 }
jne label3
mov al,[esi+5E]
cmp al,30 { 48 }
jl label3
cmp al,39 { 57 }
jg label3
mov cl,[esi+5F]
cmp cl,30 { 48 }
jl label3
cmp cl,39 { 57 }
jg label3
sub al,30 { 48 }
mov dl,0A { 10 }
imul dl
add al,cl
sub al,30 { 48 }
mov [edi+01],al
jmp label4
label3:
xor al,al
mov [edi+01],al
jmp label4
label1:
mov byte ptr [edi-01],00 { 0 }
mov byte ptr [edi],00 { 0 }
mov byte ptr [edi+01],00 { 0 }
label4:
add ebp,04 { 4 }
add edi,03 { 3 }
sub dword ptr [esp+14],01 { 1 }
jne label5
mov eax,[ebx+000001DC]
jmp label6
mov ecx,[eax+46]
mov [esp+76],ecx
mov dx,[eax+4A]
lea eax,[esp+7C]
push eax
mov [esp+7E],dx
call ps_game.exe+84F50
lea eax,[esp+7C]
lea edx,[eax+01]
nop
label7:
mov cl,[eax]
inc eax
test cl,cl
jne label7
sub eax,edx
add eax,49 { 73 }
lea ecx,[esp+38]
mov ebx,[ebx+17F4]
lea ebx,[ebx+18]
jmp label10
label6:
lea edx,[esp+76]
push edx
call ps_game.exe+84F50
lea eax,[esp+76]
lea edx,[eax+01]
label9:
mov cl,[eax]
inc eax
test cl,cl
jne label9
//mov edi,0
//mov esi,ebx
lea ebx,[ebx+18]
label10:
pop ecx
mov eax,50
push eax
lea eax,[esp+34]
push eax
movzx eax, byte ptr [ecx+0000012D]
cmp al,1
je odina
mov al,1
jmp asda
odina:
mov al,0
asda:
mov [esp+40],al
call ps_game.exe+ED0E0 //send
sameCharacter:
add esp,128
pop eax
popad
inc eax
cmp eax,[ebx+10]
jl zanovo

pushad
sub esp,128
mov ebx,[esp+128+20+24]
mov ecx,[ebx+000000DC]
mov eax,00000303 { 771 }
mov [esp+34],ax
mov [esp+36],ecx
movzx eax,byte ptr [ebx+0000144C]
movzx ecx,byte ptr [ebx+0000012D]
sete dl
mov [esp+3A],dl
movzx edx,byte ptr [ebx+0000012E]
mov [esp+3B],al
movzx eax,byte ptr [ebx+00000131]
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
mov [esp+3D],dl
movzx edx,byte ptr [ebx+00000133]
mov [esp+3E],al
movzx eax,byte ptr [ebx+00000134]
mov [esp+3F],cl
movzx ecx,byte ptr [ebx+00000135]
push ebx
mov [esp+44],dl
mov [esp+45],al
mov [esp+46],cl
call ps_game.exe+9B120
movzx edx,byte ptr [ebx+0000012F]
mov ecx,[ebx+00000184]
mov [esp+43],al
mov eax,[ebx+00000148]
mov [esp+45],eax
mov eax,[ebx+0000018C]
mov [esp+44],dl
mov edx,[ebx+00000188]
mov [esp+69],eax
movzx eax,byte ptr [ebx+00000198]
mov [esp+61],ecx
mov ecx,[ebx+00000190]
mov [esp+65],edx
mov edx,[ebx+00000194]
mov [esp+75],al
mov [esp+6D],ecx
mov [esp+71],edx
mov byte ptr [esp+75],00 { 0 }
lea edi,[esp+4A]
lea ebp,[ebx+000001C0]
mov [esp+14],00000008 { 8 }
labell5:
cmp dword ptr [ebp+00],00 { 0 }
je labell1
mov esi,[ebp+00]
mov cl,[esi+40]
mov [edi-01],cl
mov dl,[esi+41]
lea eax,[esi+4C]
mov [edi],dl
lea edx,[eax+01]
lea esp,[esp+00]
labell2:
mov cl,[eax]
inc eax
test cl,cl
jne labell2
sub eax,edx
cmp eax,14 { 20 }
jne labell3
mov al,[esi+5E]
cmp al,30 { 48 }
jl labell3
cmp al,39 { 57 }
jg labell3
mov cl,[esi+5F]
cmp cl,30 { 48 }
jl labell3
cmp cl,39 { 57 }
jg labell3
sub al,30 { 48 }
mov dl,0A { 10 }
imul dl
add al,cl
sub al,30 { 48 }
mov [edi+01],al
jmp labell4
labell3:
xor al,al
mov [edi+01],al
jmp labell4
labell1:
mov byte ptr [edi-01],00 { 0 }
mov byte ptr [edi],00 { 0 }
mov byte ptr [edi+01],00 { 0 }
labell4:
add ebp,04 { 4 }
add edi,03 { 3 }
sub dword ptr [esp+14],01 { 1 }
jne labell5
mov eax,[ebx+000001DC]
jmp labell6
mov ecx,[eax+46]
mov [esp+76],ecx
mov dx,[eax+4A]
lea eax,[esp+7C]
push eax
mov [esp+7E],dx
call ps_game.exe+84F50
lea eax,[esp+7C]
lea edx,[eax+01]
nop
labell7:
mov cl,[eax]
inc eax
test cl,cl
jne labell7
sub eax,edx
add eax,49 { 73 }
lea ecx,[esp+38]
mov ebx,[ebx+17F4]
lea ebx,[ebx+18]
jmp labell10
labell6:
lea edx,[esp+76]
push edx
call ps_game.exe+84F50
lea eax,[esp+76]
lea edx,[eax+01]
labell9:
mov cl,[eax]
inc eax
test cl,cl
jne labell9
mov edx,ebx
mov edi,0
mov ebx,[esp+120]
mov esi,ebx
lea ebx,[ebx+18]
labell10:
mov ecx,[ebx]
cmp ecx,edx
je labell11
test ecx,ecx
je labell11
sub eax,edx
mov eax,50
push eax
lea eax,[esp+38]
push eax
movzx eax, byte ptr [ecx+0000012D]
cmp al,1
je odinaa
mov al,1
jmp asdaa
odinaa:
mov al,0
asdaa:
mov [esp+3C+8],al
call ps_game.exe+ED0E0 //send
labell11:
add edi,01 { 1 }
add ebx,08 { 8 }
cmp edi,[esi+10]
jl labell10
originalcode:
add esp,00000128 { 296 }
popad
mov eax,[ebx+10]

exit:
jmp returnhere

originalcode2:
pop edi
mov eax,[ebx+10]
jmp exit

"ps_game.exe"+4FB33:
jmp newmem
nop
nop
returnhere:

 
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+4FB33:
add dword ptr [ebx+10],-01
mov eax,[ebx+10]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>324</ID>
              <Description>"party enter"</Description>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
inc [ebp+10]
cmp byte ptr[ebx+160],(int)86//MapID
jne originalcode2
cmp [ebp+10],1
je originalcode2
mov eax,0

zanovo:
push eax
pushad
mov ebx,[eax*8+ebp+18]
mov ecx,[ebx+000000DC]
mov eax,00000303 { 771 }
mov [esp+34],ax
mov [esp+36],ecx
movzx eax,byte ptr [ebx+0000144C]
movzx ecx,byte ptr [ebx+0000012D]
sete dl
mov [esp+3A],dl
movzx edx,byte ptr [ebx+0000012E]
mov [esp+3B],al
movzx eax,byte ptr [ebx+00000131]
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
mov [esp+3D],dl
movzx edx,byte ptr [ebx+00000133]
mov [esp+3E],al
movzx eax,byte ptr [ebx+00000134]
mov [esp+3F],cl
movzx ecx,byte ptr [ebx+00000135]
push ebx
mov [esp+44],dl
mov [esp+45],al
mov [esp+46],cl
call ps_game.exe+9B120
movzx edx,byte ptr [ebx+0000012F]
mov ecx,[ebx+00000184]
mov [esp+43],al
mov eax,[ebx+00000148]
mov [esp+45],eax
mov eax,[ebx+0000018C]
mov [esp+44],dl
mov edx,[ebx+00000188]
mov [esp+69],eax
movzx eax,byte ptr [ebx+00000198]
mov [esp+61],ecx
mov ecx,[ebx+00000190]
mov [esp+65],edx
mov edx,[ebx+00000194]
mov [esp+75],al
mov [esp+6D],ecx
mov [esp+71],edx
mov byte ptr [esp+75],00 { 0 }
lea edi,[esp+4A]
lea ebp,[ebx+000001C0]
mov [esp+14],00000008 { 8 }
label5:
cmp dword ptr [ebp+00],00 { 0 }
je label1
mov esi,[ebp+00]
mov cl,[esi+40]
mov [edi-01],cl
mov dl,[esi+41]
lea eax,[esi+4C]
mov [edi],dl
lea edx,[eax+01]
lea esp,[esp+00]
label2:
mov cl,[eax]
inc eax
test cl,cl
jne label2
sub eax,edx
cmp eax,14 { 20 }
jne label3
mov al,[esi+5E]
cmp al,30 { 48 }
jl label3
cmp al,39 { 57 }
jg label3
mov cl,[esi+5F]
cmp cl,30 { 48 }
jl label3
cmp cl,39 { 57 }
jg label3
sub al,30 { 48 }
mov dl,0A { 10 }
imul dl
add al,cl
sub al,30 { 48 }
mov [edi+01],al
jmp label4
label3:
xor al,al
mov [edi+01],al
jmp label4
label1:
mov byte ptr [edi-01],00 { 0 }
mov byte ptr [edi],00 { 0 }
mov byte ptr [edi+01],00 { 0 }
label4:
add ebp,04 { 4 }
add edi,03 { 3 }
sub dword ptr [esp+14],01 { 1 }
jne label5
mov eax,[ebx+000001DC]
jmp label6
mov ecx,[eax+46]
mov [esp+76],ecx
mov dx,[eax+4A]
lea eax,[esp+7C]
push eax
mov [esp+7E],dx
call ps_game.exe+84F50
lea eax,[esp+7C]
lea edx,[eax+01]
nop
label7:
mov cl,[eax]
inc eax
test cl,cl
jne label7
sub eax,edx
add eax,49 { 73 }
lea ecx,[esp+38]
mov ebx,[ebx+17F4]
lea ebx,[ebx+18]
jmp label10
label6:
lea edx,[esp+76]
push edx
call ps_game.exe+84F50
lea eax,[esp+76]
lea edx,[eax+01]
label9:
mov cl,[eax]
inc eax
test cl,cl
jne label9
mov edi,0
mov ebx,[ebx+000017F4]
mov esi,ebx
lea ebx,[ebx+18]
label10:
mov ecx,[ebx]
test ecx,ecx
je label11
sub eax,edx
mov eax,50
push eax
lea eax,[esp+38]
push eax
movzx eax, byte ptr [ecx+0000012D]
mov [esp+3C+8],al
call ps_game.exe+ED0E0 //send
label11:
add edi,01 { 1 }
add ebx,08 { 8 }
cmp edi,[esi+10]
jl label10
popad
pop eax
inc eax
cmp eax,[ebp+10]
jl zanovo
originalcode:
mov edi,ebp

exit:
jmp returnhere

originalcode2:
mov edi,ebp
jmp exit

"ps_game.exe"+4F4D6:
jmp newmem
returnhere:



[DISABLE]
dealloc(newmem)
"ps_game.exe"+4F4D6:
inc [ebp+10]
mov edi,ebp
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>640</ID>
              <Description>"raid kick"</Description>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
add dword ptr [ebx+10],-01
push edi
mov edi,[esp+1C]
cmp byte ptr [edi+160],(int)86 //MapID
jne originalcode2
pop edi
mov eax,0
zanovo:
pushad
push eax
sub esp,128
mov ecx,[esp+128+20+1c]
mov ebx,[eax*8+esi+18]
cmp ecx,ebx
je sameCharacter
push ecx
mov ecx,[ebx+000000DC]
mov eax,00000303 { 771 }
mov [esp+34],ax
mov [esp+36],ecx
movzx eax,byte ptr [ebx+0000144C]
movzx ecx,byte ptr [ebx+0000012D]
sete dl
mov [esp+3A],dl
movzx edx,byte ptr [ebx+0000012E]
mov [esp+3B],al
movzx eax,byte ptr [ebx+00000131]
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
mov [esp+3D],dl
movzx edx,byte ptr [ebx+00000133]
mov [esp+3E],al
movzx eax,byte ptr [ebx+00000134]
mov [esp+3F],cl
movzx ecx,byte ptr [ebx+00000135]
push ebx
mov [esp+44],dl
mov [esp+45],al
mov [esp+46],cl
call ps_game.exe+9B120
movzx edx,byte ptr [ebx+0000012F]
mov ecx,[ebx+00000184]
mov [esp+43],al
mov eax,[ebx+00000148]
mov [esp+45],eax
mov eax,[ebx+0000018C]
mov [esp+44],dl
mov edx,[ebx+00000188]
mov [esp+69],eax
movzx eax,byte ptr [ebx+00000198]
mov [esp+61],ecx
mov ecx,[ebx+00000190]
mov [esp+65],edx
mov edx,[ebx+00000194]
mov [esp+75],al
mov [esp+6D],ecx
mov [esp+71],edx
mov byte ptr [esp+75],00 { 0 }
lea edi,[esp+4A]
lea ebp,[ebx+000001C0]
mov [esp+14],00000008 { 8 }
label5:
cmp dword ptr [ebp+00],00 { 0 }
je label1
mov esi,[ebp+00]
mov cl,[esi+40]
mov [edi-01],cl
mov dl,[esi+41]
lea eax,[esi+4C]
mov [edi],dl
lea edx,[eax+01]
lea esp,[esp+00]
label2:
mov cl,[eax]
inc eax
test cl,cl
jne label2
sub eax,edx
cmp eax,14 { 20 }
jne label3
mov al,[esi+5E]
cmp al,30 { 48 }
jl label3
cmp al,39 { 57 }
jg label3
mov cl,[esi+5F]
cmp cl,30 { 48 }
jl label3
cmp cl,39 { 57 }
jg label3
sub al,30 { 48 }
mov dl,0A { 10 }
imul dl
add al,cl
sub al,30 { 48 }
mov [edi+01],al
jmp label4
label3:
xor al,al
mov [edi+01],al
jmp label4
label1:
mov byte ptr [edi-01],00 { 0 }
mov byte ptr [edi],00 { 0 }
mov byte ptr [edi+01],00 { 0 }
label4:
add ebp,04 { 4 }
add edi,03 { 3 }
sub dword ptr [esp+14],01 { 1 }
jne label5
mov eax,[ebx+000001DC]
jmp label6
mov ecx,[eax+46]
mov [esp+76],ecx
mov dx,[eax+4A]
lea eax,[esp+7C]
push eax
mov [esp+7E],dx
call ps_game.exe+84F50
lea eax,[esp+7C]
lea edx,[eax+01]
nop
label7:
mov cl,[eax]
inc eax
test cl,cl
jne label7
sub eax,edx
add eax,49 { 73 }
lea ecx,[esp+38]
jmp label10
label6:
lea edx,[esp+76]
push edx
call ps_game.exe+84F50
lea eax,[esp+76]
lea edx,[eax+01]
label9:
mov cl,[eax]
inc eax
test cl,cl
jne label9
//mov edi,0
//mov esi,ebx
lea ebx,[ebx+18]
label10:
pop ecx
mov eax,50
push eax
lea eax,[esp+34]
push eax
movzx eax, byte ptr [ecx+0000012D]
cmp al,1
je odina
mov al,1
jmp asda
odina:
mov al,0
asda:
mov [esp+40],al
call ps_game.exe+ED0E0 //send
sameCharacter:
add esp,128
pop eax
popad
inc eax
cmp eax,[ebx+10]
jl zanovo

pushad
sub esp,128
mov ebx,[esp+128+20+18]
mov ecx,[ebx+000000DC]
mov eax,00000303 { 771 }
mov [esp+34],ax
mov [esp+36],ecx
movzx eax,byte ptr [ebx+0000144C]
movzx ecx,byte ptr [ebx+0000012D]
sete dl
mov [esp+3A],dl
movzx edx,byte ptr [ebx+0000012E]
mov [esp+3B],al
movzx eax,byte ptr [ebx+00000131]
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
mov [esp+3D],dl
movzx edx,byte ptr [ebx+00000133]
mov [esp+3E],al
movzx eax,byte ptr [ebx+00000134]
mov [esp+3F],cl
movzx ecx,byte ptr [ebx+00000135]
push ebx
mov [esp+44],dl
mov [esp+45],al
mov [esp+46],cl
call ps_game.exe+9B120
movzx edx,byte ptr [ebx+0000012F]
mov ecx,[ebx+00000184]
mov [esp+43],al
mov eax,[ebx+00000148]
mov [esp+45],eax
mov eax,[ebx+0000018C]
mov [esp+44],dl
mov edx,[ebx+00000188]
mov [esp+69],eax
movzx eax,byte ptr [ebx+00000198]
mov [esp+61],ecx
mov ecx,[ebx+00000190]
mov [esp+65],edx
mov edx,[ebx+00000194]
mov [esp+75],al
mov [esp+6D],ecx
mov [esp+71],edx
mov byte ptr [esp+75],00 { 0 }
lea edi,[esp+4A]
lea ebp,[ebx+000001C0]
mov [esp+14],00000008 { 8 }
labell5:
cmp dword ptr [ebp+00],00 { 0 }
je labell1
mov esi,[ebp+00]
mov cl,[esi+40]
mov [edi-01],cl
mov dl,[esi+41]
lea eax,[esi+4C]
mov [edi],dl
lea edx,[eax+01]
lea esp,[esp+00]
labell2:
mov cl,[eax]
inc eax
test cl,cl
jne labell2
sub eax,edx
cmp eax,14 { 20 }
jne labell3
mov al,[esi+5E]
cmp al,30 { 48 }
jl labell3
cmp al,39 { 57 }
jg labell3
mov cl,[esi+5F]
cmp cl,30 { 48 }
jl labell3
cmp cl,39 { 57 }
jg labell3
sub al,30 { 48 }
mov dl,0A { 10 }
imul dl
add al,cl
sub al,30 { 48 }
mov [edi+01],al
jmp labell4
labell3:
xor al,al
mov [edi+01],al
jmp labell4
labell1:
mov byte ptr [edi-01],00 { 0 }
mov byte ptr [edi],00 { 0 }
mov byte ptr [edi+01],00 { 0 }
labell4:
add ebp,04 { 4 }
add edi,03 { 3 }
sub dword ptr [esp+14],01 { 1 }
jne labell5
mov eax,[ebx+000001DC]
jmp labell6
mov ecx,[eax+46]
mov [esp+76],ecx
mov dx,[eax+4A]
lea eax,[esp+7C]
push eax
mov [esp+7E],dx
call ps_game.exe+84F50
lea eax,[esp+7C]
lea edx,[eax+01]
nop
labell7:
mov cl,[eax]
inc eax
test cl,cl
jne labell7
sub eax,edx
add eax,49 { 73 }
lea ecx,[esp+38]
jmp labell10
labell6:
lea edx,[esp+76]
push edx
call ps_game.exe+84F50
lea eax,[esp+76]
lea edx,[eax+01]
labell9:
mov cl,[eax]
inc eax
test cl,cl
jne labell9
mov edx,ebx
mov edi,0
mov ebx,[esp+0000012C]
mov esi,ebx
lea ebx,[ebx+18]
labell10:
mov ecx,[ebx]
cmp ecx,edx
je labell11
test ecx,ecx
je labell11
sub eax,edx
mov eax,50
push eax
lea eax,[esp+38]
push eax
movzx eax, byte ptr [ecx+0000012D]
cmp al,1
je odinaa
mov al,1
jmp asdaa
odinaa:
mov al,0
asdaa:
mov [esp+3C+8],al
call ps_game.exe+ED0E0 //send
labell11:
add edi,01 { 1 }
add ebx,08 { 8 }
cmp edi,[esi+10]
jl labell10
originalcode:
add esp,00000128 { 296 }
popad
mov ecx,[ebx+10]

exit:
jmp returnhere

originalcode2:
pop edi
mov ecx,[ebx+10]
jmp exit

"ps_game.exe"+4FEF3:
jmp newmem
nop
nop
returnhere:


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+4FEF3:
add dword ptr [ebx+10],-01
mov ecx,[ebx+10]
//Alt: db 83 43 10 FF 8B 4B 10
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>15</ID>
              <Description>"raid leave"</Description>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
add dword ptr [ebx+10],-01
push edi
mov edi,[esp+1C]
cmp byte ptr [edi+160],(int)86 //MapID
jne originalcode2
pop edi
mov eax,0
zanovo:
pushad
push eax
sub esp,128
mov ecx,[esp+128+20+1c]
mov ebx,[eax*8+esi+18]
cmp ecx,ebx
je sameCharacter
push ecx
mov ecx,[ebx+000000DC]
mov eax,00000303 { 771 }
mov [esp+34],ax
mov [esp+36],ecx
movzx eax,byte ptr [ebx+0000144C]
movzx ecx,byte ptr [ebx+0000012D]
sete dl
mov [esp+3A],dl
movzx edx,byte ptr [ebx+0000012E]
mov [esp+3B],al
movzx eax,byte ptr [ebx+00000131]
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
mov [esp+3D],dl
movzx edx,byte ptr [ebx+00000133]
mov [esp+3E],al
movzx eax,byte ptr [ebx+00000134]
mov [esp+3F],cl
movzx ecx,byte ptr [ebx+00000135]
push ebx
mov [esp+44],dl
mov [esp+45],al
mov [esp+46],cl
call ps_game.exe+9B120
movzx edx,byte ptr [ebx+0000012F]
mov ecx,[ebx+00000184]
mov [esp+43],al
mov eax,[ebx+00000148]
mov [esp+45],eax
mov eax,[ebx+0000018C]
mov [esp+44],dl
mov edx,[ebx+00000188]
mov [esp+69],eax
movzx eax,byte ptr [ebx+00000198]
mov [esp+61],ecx
mov ecx,[ebx+00000190]
mov [esp+65],edx
mov edx,[ebx+00000194]
mov [esp+75],al
mov [esp+6D],ecx
mov [esp+71],edx
mov byte ptr [esp+75],00 { 0 }
lea edi,[esp+4A]
lea ebp,[ebx+000001C0]
mov [esp+14],00000008 { 8 }
label5:
cmp dword ptr [ebp+00],00 { 0 }
je label1
mov esi,[ebp+00]
mov cl,[esi+40]
mov [edi-01],cl
mov dl,[esi+41]
lea eax,[esi+4C]
mov [edi],dl
lea edx,[eax+01]
lea esp,[esp+00]
label2:
mov cl,[eax]
inc eax
test cl,cl
jne label2
sub eax,edx
cmp eax,14 { 20 }
jne label3
mov al,[esi+5E]
cmp al,30 { 48 }
jl label3
cmp al,39 { 57 }
jg label3
mov cl,[esi+5F]
cmp cl,30 { 48 }
jl label3
cmp cl,39 { 57 }
jg label3
sub al,30 { 48 }
mov dl,0A { 10 }
imul dl
add al,cl
sub al,30 { 48 }
mov [edi+01],al
jmp label4
label3:
xor al,al
mov [edi+01],al
jmp label4
label1:
mov byte ptr [edi-01],00 { 0 }
mov byte ptr [edi],00 { 0 }
mov byte ptr [edi+01],00 { 0 }
label4:
add ebp,04 { 4 }
add edi,03 { 3 }
sub dword ptr [esp+14],01 { 1 }
jne label5
mov eax,[ebx+000001DC]
jmp label6
mov ecx,[eax+46]
mov [esp+76],ecx
mov dx,[eax+4A]
lea eax,[esp+7C]
push eax
mov [esp+7E],dx
call ps_game.exe+84F50
lea eax,[esp+7C]
lea edx,[eax+01]
nop
label7:
mov cl,[eax]
inc eax
test cl,cl
jne label7
sub eax,edx
add eax,49 { 73 }
lea ecx,[esp+38]
jmp label10
label6:
lea edx,[esp+76]
push edx
call ps_game.exe+84F50
lea eax,[esp+76]
lea edx,[eax+01]
label9:
mov cl,[eax]
inc eax
test cl,cl
jne label9
//mov edi,0
//mov esi,ebx
lea ebx,[ebx+18]
label10:
pop ecx
mov eax,50
push eax
lea eax,[esp+34]
push eax
movzx eax, byte ptr [ecx+0000012D]
cmp al,1
je odina
mov al,1
jmp asda
odina:
mov al,0
asda:
mov [esp+40],al
call ps_game.exe+ED0E0 //send
sameCharacter:
add esp,128
pop eax
popad
inc eax
cmp eax,[ebx+10]
jl zanovo

pushad
sub esp,128
mov ebx,[esp+128+20+18]
mov ecx,[ebx+000000DC]
mov eax,00000303 { 771 }
mov [esp+34],ax
mov [esp+36],ecx
movzx eax,byte ptr [ebx+0000144C]
movzx ecx,byte ptr [ebx+0000012D]
sete dl
mov [esp+3A],dl
movzx edx,byte ptr [ebx+0000012E]
mov [esp+3B],al
movzx eax,byte ptr [ebx+00000131]
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
mov [esp+3D],dl
movzx edx,byte ptr [ebx+00000133]
mov [esp+3E],al
movzx eax,byte ptr [ebx+00000134]
mov [esp+3F],cl
movzx ecx,byte ptr [ebx+00000135]
push ebx
mov [esp+44],dl
mov [esp+45],al
mov [esp+46],cl
call ps_game.exe+9B120
movzx edx,byte ptr [ebx+0000012F]
mov ecx,[ebx+00000184]
mov [esp+43],al
mov eax,[ebx+00000148]
mov [esp+45],eax
mov eax,[ebx+0000018C]
mov [esp+44],dl
mov edx,[ebx+00000188]
mov [esp+69],eax
movzx eax,byte ptr [ebx+00000198]
mov [esp+61],ecx
mov ecx,[ebx+00000190]
mov [esp+65],edx
mov edx,[ebx+00000194]
mov [esp+75],al
mov [esp+6D],ecx
mov [esp+71],edx
mov byte ptr [esp+75],00 { 0 }
lea edi,[esp+4A]
lea ebp,[ebx+000001C0]
mov [esp+14],00000008 { 8 }
labell5:
cmp dword ptr [ebp+00],00 { 0 }
je labell1
mov esi,[ebp+00]
mov cl,[esi+40]
mov [edi-01],cl
mov dl,[esi+41]
lea eax,[esi+4C]
mov [edi],dl
lea edx,[eax+01]
lea esp,[esp+00]
labell2:
mov cl,[eax]
inc eax
test cl,cl
jne labell2
sub eax,edx
cmp eax,14 { 20 }
jne labell3
mov al,[esi+5E]
cmp al,30 { 48 }
jl labell3
cmp al,39 { 57 }
jg labell3
mov cl,[esi+5F]
cmp cl,30 { 48 }
jl labell3
cmp cl,39 { 57 }
jg labell3
sub al,30 { 48 }
mov dl,0A { 10 }
imul dl
add al,cl
sub al,30 { 48 }
mov [edi+01],al
jmp labell4
labell3:
xor al,al
mov [edi+01],al
jmp labell4
labell1:
mov byte ptr [edi-01],00 { 0 }
mov byte ptr [edi],00 { 0 }
mov byte ptr [edi+01],00 { 0 }
labell4:
add ebp,04 { 4 }
add edi,03 { 3 }
sub dword ptr [esp+14],01 { 1 }
jne labell5
mov eax,[ebx+000001DC]
jmp labell6
mov ecx,[eax+46]
mov [esp+76],ecx
mov dx,[eax+4A]
lea eax,[esp+7C]
push eax
mov [esp+7E],dx
call ps_game.exe+84F50
lea eax,[esp+7C]
lea edx,[eax+01]
nop
labell7:
mov cl,[eax]
inc eax
test cl,cl
jne labell7
sub eax,edx
add eax,49 { 73 }
lea ecx,[esp+38]
jmp labell10
labell6:
lea edx,[esp+76]
push edx
call ps_game.exe+84F50
lea eax,[esp+76]
lea edx,[eax+01]
labell9:
mov cl,[eax]
inc eax
test cl,cl
jne labell9
mov edx,ebx
mov edi,0
mov ebx,[esp+120]
mov esi,ebx
lea ebx,[ebx+18]
labell10:
mov ecx,[ebx]
cmp ecx,edx
je labell11
test ecx,ecx
je labell11
sub eax,edx
mov eax,50
push eax
lea eax,[esp+38]
push eax
movzx eax, byte ptr [ecx+0000012D]
cmp al,1
je odinaa
mov al,1
jmp asdaa
odinaa:
mov al,0
asdaa:
mov [esp+3C+8],al
call ps_game.exe+ED0E0 //send
labell11:
add edi,01 { 1 }
add ebx,08 { 8 }
cmp edi,[esi+10]
jl labell10
originalcode:
add esp,00000128 { 296 }
popad
mov ecx,[ebx+10]

exit:
jmp returnhere

originalcode2:
pop edi
mov ecx,[ebx+10]
jmp exit

"ps_game.exe"+4F745:
jmp newmem
nop
nop
returnhere:


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+4F745:
add dword ptr [ebx+10],-01
mov ecx,[ebx+10]
//Alt: db 83 43 10 FF 8B 4B 10
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>16</ID>
              <Description>"raid enter"</Description>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
inc [ebp+10]
cmp byte ptr[ebx+160],(int)86//MapID
jne originalcode2
cmp [ebp+10],1
je originalcode2
mov eax,0

zanovo:
push eax
pushad
mov ebx,[eax*8+ebp+18]
mov ecx,[ebx+000000DC]
mov eax,00000303 { 771 }
mov [esp+34],ax
mov [esp+36],ecx
movzx eax,byte ptr [ebx+0000144C]
movzx ecx,byte ptr [ebx+0000012D]
sete dl
mov [esp+3A],dl
movzx edx,byte ptr [ebx+0000012E]
mov [esp+3B],al
movzx eax,byte ptr [ebx+00000131]
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
mov [esp+3D],dl
movzx edx,byte ptr [ebx+00000133]
mov [esp+3E],al
movzx eax,byte ptr [ebx+00000134]
mov [esp+3F],cl
movzx ecx,byte ptr [ebx+00000135]
push ebx
mov [esp+44],dl
mov [esp+45],al
mov [esp+46],cl
call ps_game.exe+9B120
movzx edx,byte ptr [ebx+0000012F]
mov ecx,[ebx+00000184]
mov [esp+43],al
mov eax,[ebx+00000148]
mov [esp+45],eax
mov eax,[ebx+0000018C]
mov [esp+44],dl
mov edx,[ebx+00000188]
mov [esp+69],eax
movzx eax,byte ptr [ebx+00000198]
mov [esp+61],ecx
mov ecx,[ebx+00000190]
mov [esp+65],edx
mov edx,[ebx+00000194]
mov [esp+75],al
mov [esp+6D],ecx
mov [esp+71],edx
mov byte ptr [esp+75],00 { 0 }
lea edi,[esp+4A]
lea ebp,[ebx+000001C0]
mov [esp+14],00000008 { 8 }
label5:
cmp dword ptr [ebp+00],00 { 0 }
je label1
mov esi,[ebp+00]
mov cl,[esi+40]
mov [edi-01],cl
mov dl,[esi+41]
lea eax,[esi+4C]
mov [edi],dl
lea edx,[eax+01]
lea esp,[esp+00]
label2:
mov cl,[eax]
inc eax
test cl,cl
jne label2
sub eax,edx
cmp eax,14 { 20 }
jne label3
mov al,[esi+5E]
cmp al,30 { 48 }
jl label3
cmp al,39 { 57 }
jg label3
mov cl,[esi+5F]
cmp cl,30 { 48 }
jl label3
cmp cl,39 { 57 }
jg label3
sub al,30 { 48 }
mov dl,0A { 10 }
imul dl
add al,cl
sub al,30 { 48 }
mov [edi+01],al
jmp label4
label3:
xor al,al
mov [edi+01],al
jmp label4
label1:
mov byte ptr [edi-01],00 { 0 }
mov byte ptr [edi],00 { 0 }
mov byte ptr [edi+01],00 { 0 }
label4:
add ebp,04 { 4 }
add edi,03 { 3 }
sub dword ptr [esp+14],01 { 1 }
jne label5
mov eax,[ebx+000001DC]
jmp label6
mov ecx,[eax+46]
mov [esp+76],ecx
mov dx,[eax+4A]
lea eax,[esp+7C]
push eax
mov [esp+7E],dx
call ps_game.exe+84F50
lea eax,[esp+7C]
lea edx,[eax+01]
nop
label7:
mov cl,[eax]
inc eax
test cl,cl
jne label7
sub eax,edx
add eax,49 { 73 }
lea ecx,[esp+38]
jmp label10
label6:
lea edx,[esp+76]
push edx
call ps_game.exe+84F50
lea eax,[esp+76]
lea edx,[eax+01]
label9:
mov cl,[eax]
inc eax
test cl,cl
jne label9
mov edi,0
mov ebx,[ebx+000017F4]
mov esi,ebx
lea ebx,[ebx+18]
label10:
mov ecx,[ebx]
test ecx,ecx
je label11
sub eax,edx
mov eax,50
push eax
lea eax,[esp+38]
push eax
movzx eax, byte ptr [ecx+0000012D]
mov [esp+3C+8],al
call ps_game.exe+ED0E0 //send
label11:
add edi,01 { 1 }
add ebx,08 { 8 }
cmp edi,[esi+10]
jl label10
popad
pop eax
inc eax
cmp eax,[ebp+10]
jl zanovo
originalcode:
mov edi,ebp

exit:
jmp returnhere

originalcode2:
mov edi,ebp
jmp exit

"ps_game.exe"+4F169:
jmp newmem
returnhere:


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+4F169:
inc [ebp+10]
mov edi,ebp
//Alt: db FF 45 10 8B FD
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>325</ID>
              <Description>"FFA party (/party in raid leader)"</Description>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr [ebp+160],(int)86 //MapID
jne originalcode
jmp 00475F09
originalcode:
mov al,[ebx+0000012D]

exit:
jmp returnhere

"ps_game.exe"+75EEC:
jmp newmem
nop
returnhere:

 
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+75EEC:
mov al,[ebx+0000012D]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>326</ID>
              <Description>"FFA party (/party)"</Description>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr [ebp+160],(int)86//MapID
jne originalcode
jmp 00475514
originalcode:
mov cl,[edi+0000012D]

exit:
jmp returnhere

"ps_game.exe"+754F7:
jmp newmem
nop
returnhere:

 
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+754F7:
mov cl,[edi+0000012D]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>327</ID>
              <Description>"FFA party (/join)"</Description>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr [ebp+160],(int)86 //MapID
jne originalcode
cmp byte ptr [edi+160],(int)86 //MapID
je 004757D8
originalcode:
mov dl,[ebp+0000012D]

exit:
jmp returnhere

"ps_game.exe"+757BA:
jmp newmem
nop
returnhere:

 
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+757BA:
mov dl,[ebp+0000012D]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>328</ID>
              <Description>"FFA party (search)"</Description>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr [eax+160],(int)86 //MapID
jne originalcode
jmp 00484C77
originalcode:
mov cl,[eax+0000012D]

exit:
jmp returnhere

"ps_game.exe"+84C69:
jmp newmem
nop
returnhere:

 
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+84C69:
mov cl,[eax+0000012D]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>329</ID>
              <Description>"FFA attack"</Description>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr [eax+160],(int)86 //MapID
je mycode
jmp originalcode
mycode:
push eax
push ebx
mov ebx,[edx+000017F4]
cmp ebx,00
je NotInParty
mov eax,[eax+000017F4]
cmp eax,00
je NotInParty
cmp eax,ebx
jne NotInParty
pop ebx
pop eax
jmp 00457E39 //can not be attacked
NotInParty:
pop ebx
pop eax
jmp 00457E35 //can be attacked
originalcode:
mov dl,[edx+0000012D]

exit:
jmp returnhere

"ps_game.exe"+57E27:
jmp newmem
nop
returnhere:

 
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+57E27:
mov dl,[edx+0000012D]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>11</ID>
              <Description>"FFA Items"</Description>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr [ebp+160],(int)86 //MapID
je mycode
jmp originalcode
mycode:
push eax
push ebx
mov eax,[eax+000017F4]
cmp eax,00
je NotInParty
mov ebx,[ebp+000017F4]
cmp ebx,00
je NotInParty
cmp eax,ebx
jne NotInParty
pop ebx
pop eax
jmp 00473A87
NotInParty:
pop ebx
pop eax
jmp 0047468A
originalcode:
mov dl,[ebp+0000012D]

exit:
jmp returnhere

"ps_game.exe"+73A75:
jmp newmem
nop
returnhere:

 
 
[DISABLE]
"ps_game.exe"+73A75:
mov dl,[ebp+0000012D]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>330</ID>
              <Description>"FFA Skills"</Description>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr[esi+160],(int)86//MapID
je mycode
jmp originalcode
mycode:
push eax
push ebx
mov eax,[esi+000017F4]
cmp eax,00
je NotInParty
mov ebx,[edx+000017F4]
cmp ebx,00
je NotInParty
cmp eax,ebx
jne NotInParty
pop ebx
pop eax
jmp 00457F41 //SameParty
NotInParty:
pop ebx
pop eax
jmp 00457F01
originalcode:
mov al,[esi+0000012D]

exit:
jmp returnhere

"ps_game.exe"+57F33:
jmp newmem
nop
returnhere:

 
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+57F33:
mov al,[esi+0000012D]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>331</ID>
              <Description>"Leave from party if TP to map or from map"</Description>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr[esi+160],(int)86//mapid
je leaveFromParty
cmp ax,(int)0//mapid
je leaveFromParty
jmp originalcode
leaveFromParty:
cmp [esi+000017F4],00
je originalcode
pushad
mov ecx,[esi+000017F4]
mov eax,esi
call ps_game.exe+4F5F0
popad
originalcode:
mov [esi+00000160],ax

exit:
jmp returnhere

"ps_game.exe"+148E0:
jmp newmem
nop
nop
returnhere:

 
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+148E0:
mov [esi+00000160],ax
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols/>
</CheatTable>
