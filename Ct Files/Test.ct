<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="34">
  <Forms>
    <UDF1 Class="TCEForm" Encoding="Ascii85">D]H=@2nldAU:MM2b.}cxWeIh0Gi32eO*FuxWMuP5%{mcIVgA6t9Fkwa6vP@ynNpI$=7,z9n3I!V=oyOr.Fg)[TFlAim^X9E:#-P1m%[;6SXz:FoLQC1$=lw3P=DLS#_Ac)!zDjCJ2/l;m6L%100</UDF1>
    <UDF1_1 Class="TCEForm" Encoding="Ascii85">D]H=@2nldAU:MM2b.}cxWeIh0Gi32eO*FuxWMuP5%{mcIVgA6t9Fkwa6vP@ynNpI$=7,z9n3I!V=oyOr.Fg)[TFlAim^X9E:#-P1m%[;6SXz:FoLQC1$=lw3P=DLS#_Ac)!zDjCJ2/l;m6L%100</UDF1_1>
    <UDF1_2 Class="TCEForm" Encoding="Ascii85">D]H=@2nldAU:MM2b.}cxWeIh0Gi32eO*FuxWMuP5%{mcIVgA6t9Fkwa6vP@ynNpI$=7,z9n3I!V=oyOr.Fg)[TFlAim^X9E:#-P1m%[;6SXz:FoLQC1$=lw3P=DLS#_Ac)!zDjCJ2/l;m6L%100</UDF1_2>
  </Forms>
  <CheatEntries>
    <CheatEntry>
      <ID>0</ID>
      <Description>"Works"</Description>
      <Options moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
      <LastState Value="" RealAddress="00000000"/>
      <GroupHeader>1</GroupHeader>
      <CheatEntries>
        <CheatEntry>
          <ID>438</ID>
          <Description>"Features"</Description>
          <Options moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <Color>804000</Color>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>205</ID>
              <Description>"Max Level 70"</Description>
              <LastState/>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]

define(max_level,#70)

004651D9:
cmp ax,max_level

0046507D:
cmp ax,max_level

0046143E:
cmp eax,max_level

00480FC4:
cmp ebx,max_level

0049B5DE:
cmp ebx,max_level

0049B63A:
cmp ebx,max_level

0049B68E:
cmp ebx,max_level

0049B7C2:
cmp ebx,max_level

0049B81E:
cmp ebx,max_level

0049B872:
cmp ebx,max_level

0049BD9E:
cmp ebx,max_level

0049BDCF:
cmp ebx,max_level

0049BE00:
cmp ebx,max_level

0049BEDB:
cmp ebx,max_level

00460C55:
cmp ecx,max_level

00460C85:
cmp ecx,max_level

00460CB5:
cmp ecx,max_level

0046135B:
cmp ecx,max_level

004613AC:
cmp ecx,max_level

004613F9:
cmp ecx,max_level

00464FF5:
cmp ecx,max_level

0046515F:
cmp ecx,max_level

004651EA:
cmp ecx,max_level

0046523F:
cmp ecx,max_level

00467BFC:
cmp ecx,max_level

004612CC:
cmp edx,max_level

004612F7:
cmp edx,max_level

00461322:
cmp edx,max_level

0049241B:
cmp edx,max_level

00547019:
cmp eax,max_level

0049BF34:
cmp ebx,max_level

0049BF81:
cmp ebx,max_level

0049BFD1:
cmp ebx,max_level

0049C013:
cmp ebx,max_level

0049C052:
cmp ebx,max_level

0049C0B4:
cmp ebx,max_level

0049C10D:
cmp ebx,max_level

0049C15A:
cmp ebx,max_level

0049C1AA:
cmp ebx,max_level

0049C1EC:
cmp ebx,max_level

0049C22B:
cmp ebx,max_level

00480E0C:
cmp ecx,max_level

0049243B:
cmp ecx,max_level

0049B4A2:
cmp ecx,max_level

0049B4D3:
cmp ecx,max_level

0049B504:
cmp ecx,max_level

0049BB75:
cmp ecx,max_level

0049BB9C:
cmp ecx,max_level

[DISABLE]

define(max_level,#70)

004651D9:
cmp ax,max_level

0046507D:
cmp ax,max_level

0046143E:
cmp eax,max_level

00480FC4:
cmp ebx,max_level

0049B5DE:
cmp ebx,max_level

0049B63A:
cmp ebx,max_level

0049B68E:
cmp ebx,max_level

0049B7C2:
cmp ebx,max_level

0049B81E:
cmp ebx,max_level

0049B872:
cmp ebx,max_level

0049BD9E:
cmp ebx,max_level

0049BDCF:
cmp ebx,max_level

0049BE00:
cmp ebx,max_level

0049BEDB:
cmp ebx,max_level

00460C55:
cmp ecx,max_level

00460C85:
cmp ecx,max_level

00460CB5:
cmp ecx,max_level

0046135B:
cmp ecx,max_level

004613AC:
cmp ecx,max_level

004613F9:
cmp ecx,max_level

00464FF5:
cmp ecx,max_level

0046515F:
cmp ecx,max_level

004651EA:
cmp ecx,max_level

0046523F:
cmp ecx,max_level

00467BFC:
cmp ecx,max_level

004612CC:
cmp edx,max_level

004612F7:
cmp edx,max_level

00461322:
cmp edx,max_level

0049241B:
cmp edx,max_level

00547019:
cmp eax,max_level

0049BF34:
cmp ebx,max_level

0049BF81:
cmp ebx,max_level

0049BFD1:
cmp ebx,max_level

0049C013:
cmp ebx,max_level

0049C052:
cmp ebx,max_level

0049C0B4:
cmp ebx,max_level

0049C10D:
cmp ebx,max_level

0049C15A:
cmp ebx,max_level

0049C1AA:
cmp ebx,max_level

0049C1EC:
cmp ebx,max_level

0049C22B:
cmp ebx,max_level

00480E0C:
cmp ecx,max_level

0049243B:
cmp ecx,max_level

0049B4A2:
cmp ecx,max_level

0049B4D3:
cmp ecx,max_level

0049B504:
cmp ecx,max_level

0049BB75:
cmp ecx,max_level

0049BB9C:
cmp ecx,max_level
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>47</ID>
              <Description>"Stat Recreation : Reroll"</Description>
              <LastState/>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript Async="1">[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(max,4)
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)
label(custom)
label(custom2)
label(end)
label(dopa)
label(Oeuf_de_Dragon_Stat4)
label(Oeuf_de_Dragon_Stat3)
label(Oeuf_de_Dragon_Stat2)
label(Oeuf_de_Dragon_Stat1)
label(Oeuf_de_Dragon_Stat)
label(Oeuf_de_Dragon_Mount)
label(Oeuf_de_Dragon_remove)
label(Oeuf_de_Dragon_Base)
label(removal)
label(nothing)

newmem: //this is allocated memory, you have read,write,execute access
mov [start],1
cmp [type],0
JNE custom
cmp [stat],0
JNE custom

originalcode:
lea ebp,[esi+00000084]
mov [start],0
jmp exit

custom:
lea ebp,[esi+00000084]
lea ecx,[ecx+00]
mov edi,[stat]
call 0051BD66
mov edx,[esi+30]
movzx ecx,word ptr [edx+3E]
cdq
mov [max],ecx
inc ecx
idiv ecx
mov bl,dl
call ps_game.exe+11BD66
mov edx,[esi+30]
movzx ecx,word ptr [edx+3E]
inc ecx
cdq
idiv ecx
cmp bl,dl
jb custom2
mov bl,dl

custom2:
cmp dword ptr [esp+2C],00
jne dopa
call ps_game.exe+11BD66
mov edx,[esi+30]
movzx ecx,word ptr [edx+3E]
inc ecx
cdq
idiv ecx
cmp bl,dl
jb dopa
mov bl,dl

dopa:
dec edi
cmp [type],11
JE Oeuf_de_Dragon_Stat4
cmp [type],9
JE Oeuf_de_Dragon_Stat3
cmp [type],8
JE Oeuf_de_Dragon_Stat2
cmp [type],7
JE Oeuf_de_Dragon_Stat1
cmp [type],3
JE Oeuf_de_Dragon_Stat
cmp [type],6
JE Oeuf_de_Dragon_Mount
cmp [type],5
JE Oeuf_de_Dragon_remove
cmp [type],1
JE Oeuf_de_Dragon_Base
cmp [type],(int)10
JE removal
jmp nothing


nothing:
movzx dx,bl
mov [ebp+00+edi*2],dx
jmp end

removal:
xor ecx,ecx
mov [ebp+00+edi*2],00
movzx edx,word ptr [edi*2+00581C74]
mov byte ptr [edx+esi+4C],30
movzx eax,word ptr [edi*2+00581C74]
mov byte ptr [eax+esi+4D],30
mov [start],0
jmp 004D2C7B

Oeuf_de_Dragon_Stat4:
mov bl,70.
movzx dx,bl
mov [ebp+00+edi*2],dx
jmp end

Oeuf_de_Dragon_Stat3:
mov bl,65.
movzx dx,bl
mov [ebp+00+edi*2],dx
jmp end

Oeuf_de_Dragon_Stat2:
mov bl,60.
movzx dx,bl
mov [ebp+00+edi*2],dx
jmp end

Oeuf_de_Dragon_Stat1:
mov bl,55.
movzx dx,bl
mov [ebp+00+edi*2],dx
jmp end

Oeuf_de_Dragon_Stat:
mov bl,50.
movzx dx,bl
mov [ebp+00+edi*2],dx
jmp end

Oeuf_de_Dragon_Base:
mov bl,40.
movzx dx,bl
mov [ebp+00+edi*2],dx
jmp end

Oeuf_de_Dragon_remove:
mov bl,max
movzx dx,bl
mov [ebp+00+edi*2],dx
jmp end

Oeuf_de_Dragon_Mount:
mov bl,30.
movzx dx,bl
mov [ebp+00+edi*2],dx
jmp end

end:
movzx eax,bl
cdq
mov ecx,0000000A
idiv ecx
movzx ecx,word ptr [edi*2+00581C74]
add al,30
mov [ecx+esi+4C],al
movzx eax,word ptr [edi*2+00581C74]
add dl,30
mov [eax+esi+4D],dl
mov [start],0
jmp 004D2C7B





exit:
jmp returnhere

"ps_game.exe"+D2BC7:
jmp newmem
nop
returnhere:


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+D2BC7:
lea ebp,[esi+00000084]
//Alt: db 8D AE 84 00 00 00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>633</ID>
              <Description>"Stat Recreation : Pointers"</Description>
              <LastState/>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript Async="1">[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
registersymbol(start)
alloc(start,4)
registersymbol(type)
registersymbol(stat)
registersymbol(counter)
registersymbol(maxorange)
registersymbol(itemtype)
registersymbol(statamount)
alloc(statamount,4)
alloc(itemtype,4)
alloc(maxorange,4)
alloc(counter,4)
alloc(type,4)
alloc(stat,4)
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)
label(check)
label(orange)
label(equality)
label(pointers)

newmem: //this is allocated memory, you have read,write,execute access
/*
Rec runes


STR = Defines Rec rune type

1	: Stat rune (random)
2	: Stat rune (max)
3	: Rec doubler
10	: Stat rune (removal)

Dex = Defines Stat

1 : Str
2 : Dex
3 : Rec
4 : Int
5 : Wis
6 : Luc
7 : Hp
8 : Mp
9 : Sp

[pp+800+eax] = oranges 801 = str 802 = dex etc
[edi+820+eax] = orange stats, 821 = how many str you have, 822 = how many dex you got etc
[edi+840] = max orange amount
[edi+845] = rec doubler amount
*/
cmp byte ptr [ecx+70],1
je check_level_Base
cmp byte ptr [ecx+70],6
je check_level_Mount
cmp byte ptr [ecx+70],3
je Oeuf_de_Dragon_Stat4
cmp byte ptr [ecx+70],11
je Oeuf_de_Dragon_Stat3
cmp byte ptr [ecx+70],9
je Oeuf_de_Dragon_Stat2
cmp byte ptr [ecx+70],8
je Oeuf_de_Dragon_Stat1
cmp byte ptr [ecx+70],7
je Oeuf_de_Dragon_Stat

start_reroll:
mov [statamount],0
pushad
movzx eax,byte ptr [ecx+70]
movzx ebx,byte ptr [ecx+72]
mov [type],eax
mov [stat],ebx
popad
cmp [type],0
JE originalcode
cmp [stat],0
JE originalcode
cmp [stat],(int)7
JL pointers
mov esi,[ebp+30]
cmp [esi],(int)120001
JGE pointers
cmp [esi+a0],(int)16
JL ps_game.exe+6D901
cmp [esi+a0],(int)22
JL pointers
cmp [esi+a0],(int)24
JL ps_game.exe+6D901
cmp [esi+a0],(int)25
JE ps_game.exe+6D901
cmp [esi+a0],(int)36
JL pointers
cmp [esi+a0],(int)39
JL ps_game.exe+6D901
cmp [esi+a0],(int)39
JE pointers
cmp [esi+a0],(int)67
JL ps_game.exe+6D901


pointers:
mov [edi+845],0
mov [edi+840],0
mov [counter],0
pushad
mov esi,[ebp+30]
movzx esi, word ptr[esi+3E]
mov [maxorange],esi
mov eax,0
mov esi,[ebp+30]
movzx esi, byte ptr[esi+4a]
mov ebx,0

orange:
cmp eax,9
JGE check
add eax,1
mov [edi+800+eax],0
mov [edi+820+eax],0
cmp byte ptr [ebp+82+eax*2],00
movzx edx,byte ptr [ebp+82+eax*2]
JE orange
mov [edi+800+eax],1
mov [edi+820+eax],edx
add ebx,1
jmp orange


check:
cmp ebx,esi
popad
JG 0046D901
JE equality
jmp originalcode


originalcode:
push eax
mov eax,[stat]
movzx eax,byte ptr[edi+820+eax]
mov [statamount],eax
pop eax
cmp byte ptr [ecx+46],3E
jne ps_game.exe+6D901
cmp [start],0
JNE ps_game.exe+6D901
jmp exit

equality:
pushad
mov esi,[stat]
cmp byte ptr [edi+800+esi],00
popad
JE ps_game.exe+6D901
jmp originalcode

Oeuf_de_Dragon_Stat4:
push ebp
mov ebp,[ebp+30]
cmp byte ptr [ebp+2e],(int)80
pop ebp
je start_reroll
jmp 0046D901

Oeuf_de_Dragon_Stat3:
push ebp
mov ebp,[ebp+30]
cmp byte ptr [ebp+2e],(int)80
pop ebp
je start_reroll
jmp 0046D901

Oeuf_de_Dragon_Stat2:
push ebp
mov ebp,[ebp+30]
cmp byte ptr [ebp+2e],(int)80
pop ebp
je start_reroll
jmp 0046D901

Oeuf_de_Dragon_Stat1:
push ebp
mov ebp,[ebp+30]
cmp byte ptr [ebp+2e],(int)80
pop ebp
je start_reroll
jmp 0046D901

Oeuf_de_Dragon_Stat:
push ebp
mov ebp,[ebp+30]
cmp byte ptr [ebp+2e],(int)80
pop ebp
je start_reroll
jmp 0046D901

check_level_Base:
push ebp
mov ebp,[ebp+30]
cmp byte ptr [ebp+2e],(int)80
pop ebp
je start_reroll
jmp 0046D901

check_level_Mount:
push ebp
mov ebp,[ebp+30]
cmp byte ptr [ebp+2e],(int)1
pop ebp
je start_reroll
jmp 0046D901

exit:
jmp returnhere

"ps_game.exe"+6D6A9:
jmp newmem
nop
nop
nop
nop
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+6D6A9:
cmp byte ptr [ecx+46],3E
jne ps_game.exe+6D901
//Alt: db 80 79 46 3E 0F 85 4E 02 00 00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>473</ID>
              <Description>"Boss Death Notice"</Description>
              <LastState/>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,1024)

// ebx = mob pointer
// eax = player pointer
newmem:
call func_send_notice

originalcode:
lea ecx, dword ptr [ebx+DD4]
jmp returnhere

func_send_notice:
pushad

mov esi,eax
add esi,184

mov ebx, dword ptr [ebx+D4]
add ebx,2

sub esp,#100

mov edi,esp

push #100
push 0
push edi
call msvcrt.memset
add esp,C

mov word ptr [edi],F90B
mov byte ptr [edi+2],FF

push ebx
push edi
call msvcrt.strcat
add esp,8

push notice_text
push edi
call msvcrt.strcat
add esp,8

push esi
push edi
call msvcrt.strcat
add esp,8

push edi
call msvcrt.strlen
add esp,4

mov byte ptr [edi+2],al

mov esi, dword ptr [00587960]
movzx eax, byte ptr [edi+2]
add eax,3
mov ecx,edi
call 00419120

add esp,#100

func_send_notice_exit:
popad
ret

notice_text:
db ' was just killed by '
db 0

004A2083:
jmp newmem
nop
returnhere:

[DISABLE]

004A2083:
lea ecx, dword ptr [ebx+DD4]

dealloc(newmem)
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>472</ID>
              <Description>"Boss Spawn Notice"</Description>
              <LastState/>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,1024)

// ebx = mob pointer
newmem:
call func_send_notice

originalcode:
lea edx, dword ptr [edi+98]
jmp returnhere

func_send_notice:
pushad

add ebx,2

sub esp,#100

mov edi,esp

push #100
push 0
push edi
call msvcrt.memset
add esp,C

mov word ptr [edi],F90B
mov byte ptr [edi+2],FF

push ebx
push edi
call msvcrt.strcat
add esp,8

push notice_text
push edi
call msvcrt.strcat
add esp,8

push edi
call msvcrt.strlen
add esp,4

mov byte ptr [edi+2],al

mov esi, dword ptr [00587960]
movzx eax, byte ptr [edi+2]
add eax,3
mov ecx,edi
call 00419120

add esp,#100

func_send_notice_exit:
popad
ret

notice_text:
db ' just spawned!'
db 0

00422F0D:
jmp newmem
nop
returnhere:

[DISABLE]

00422F0D:
lea edx, dword ptr [edi+98]

dealloc(newmem)
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>625</ID>
              <Description>"Bootlogery rune location"</Description>
              <LastState/>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]

// Light Auction House Spawn Points

// Light
0056E628:
dd #42 // MapID

dd (float)507.0 // X
dd (float)1.24 // Y
dd (float)298.0 // Z

// Fury
0056E638:
dd #42 // MapID

dd (float)507.0 // X
dd (float)1.24 // Y
dd (float)298.0 // Z

[DISABLE]

0056E628:
dd 0000002A

dd 429D3852
dd 4175C28F
dd 41DF999A

0056E638:
dd 0000002A

dd 41BB1EB8
dd 4175C28F
dd 42D4CCCD
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>344</ID>
              <Description>"Remove Deaths"</Description>
              <LastState/>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
ps_game.exe+67F46:
add byte ptr [esp+0A],00

[DISABLE]

ps_game.exe+67F46:
mov byte ptr [esp+0A],01
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>57</ID>
              <Description>"Enable summon and movement in Map 67 (Dios Room)"</Description>
              <LastState/>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]

004733E9:
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop

00473567:
nop
nop
nop
nop
nop
nop

[DISABLE]

004733E9:
cmp dword ptr [ecx+78],#67
je 0047468A

00473567:
cmp dword ptr [ecx+78],#67
je 00473557
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>627</ID>
              <Description>"Removal EXP 15 and 30"</Description>
              <LastState/>
              <Color>804000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
//place your code here
cmp byte ptr[esi+160], (int)18//MapID
je 00465222
cmp byte ptr[esi+160], (int)30//MapID
je 00465222
cmp byte ptr[esi+160], (int)105//MapID
je 00465222
originalcode:
cmp edi,eax
jae ps_game.exe+651B7
add edi,ebp

exit:
jmp returnhere

"ps_game.exe"+65177:
jmp newmem
nop
returnhere:



[DISABLE]
"ps_game.exe"+65177:
cmp edi,eax
jae ps_game.exe+651B7
add edi,ebp
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>594</ID>
              <Description>"Allow duels vs just in arena"</Description>
              <LastState/>
              <Color>408000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
//place your code here
mov cl,[ebx+0000012D]
cmp word ptr [ebx+160],(int)40
je 0048BE8C
jmp 0048BFAA

originalcode:


exit:
jmp returnhere

"ps_game.exe"+8BE80:
jmp newmem
nop
returnhere:


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+8BE80:
mov cl,[ebx+0000012D]
//Alt: db 8A 8B 2D 01 00 00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>628</ID>
              <Description>"Cross faction"</Description>
              <Options moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
              <LastState Value="" RealAddress="00000000"/>
              <Color>804000</Color>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>454</ID>
                  <Description>"Cross Faction Trade on AH"</Description>
                  <LastState/>
                  <Color>804000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp word ptr [ebx+0x160],#42
je 0047d9bc

originalcode:
cmp cl,[ebx+0000012D]

exit:
jmp returnhere

"ps_game.exe"+7D9B0:
jmp newmem
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+7D9B0:
cmp cl,[ebx+0000012D]
//Alt: db 3A 8B 2D 01 00 00
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>631</ID>
                  <Description>"Cross Faction Whisper all maps"</Description>
                  <LastState/>
                  <Color>804000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
0047f629:
db 90 90 90 90 90 90

0047ff69:
db 90 90 90 90 90 90


[DISABLE]
0047f629:
db 0F 85 DF 00 00 00

0047ff69:
db 0F 85 DF 00 00 00
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>630</ID>
                  <Description>"Cross Faction Inspect on AH"</Description>
                  <LastState/>
                  <Color>804000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp word ptr [eax+0x160],#42
je 00477d4f

originalcode:
cmp cl,[eax+0000012D]

exit:
jmp returnhere

"ps_game.exe"+77D43:
jmp newmem
nop
returnhere:


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+77D43:
cmp cl,[eax+0000012D]
//Alt: db 3A 88 2D 01 00 00
</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>261</ID>
              <Description>"Drop Yourself (without party) - Random Drop fix"</Description>
              <Options moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
              <LastState Value="" RealAddress="00000000"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>125</ID>
                  <Description>"Gold To Inventory"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
alloc(newmem,512)
label(returnhere)

label(solo)
label(solo_bonus)
label(solo_bonus_ok)
label(solo_bonus_wtc)
label(solo_bonus_rpc)

newmem:
mov eax, dword ptr [esp+44] // raid pointer
test eax,eax
je solo
jmp returnhere

solo:
mov edx, dword ptr [esp+40] // player pointer
test edx,edx
je 004BAE0D

cmp dword ptr [edx+594C],2
je solo_bonus_wtc
cmp dword ptr [edx+594C],3
je solo_bonus_rpc

solo_bonus_ok:
mov ecx, dword ptr [esp+18]
call 0046BBA0
jmp 004BAEB8

solo_bonus:
sub esp,4
fild dword ptr [esp+1C]
fld dword ptr [esp]
fmul st(1),st(0)
fstp dword ptr [esp]
fistp dword ptr [esp+1C]
add esp,4
jmp solo_bonus_ok

solo_bonus_wtc:
mov dword ptr [esp-4],(float)1.200 // White Tiger Charm = +20%
jmp solo_bonus

solo_bonus_rpc:
mov dword ptr [esp-4],(float)1.500 // Red Phoenix Charm = +50%
jmp solo_bonus

004BAD4C:
jmp newmem
nop
nop
nop
nop
nop
nop
nop
returnhere:

[DISABLE]
dealloc(newmem)

004BAD4C:
mov eax, dword ptr [esp+44]
test eax,eax
je 004BAE0D
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>127</ID>
                  <Description>"Drop To Inventory"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
alloc(newmem,128)
label(returnhere)
label(solo)

newmem:
test ebp,ebp
je solo
jmp returnhere

solo:
mov ecx, dword ptr [esp+18]
test ecx,ecx
je 004BB438
push ebx
call 0046AE60
jmp 004BB47A

004BB1D5:
jmp newmem
nop
nop
nop
returnhere:

[DISABLE]
dealloc(newmem)

004BB1D5:
test ebp,ebp
je 004BB438
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>226</ID>
                  <Description>"Random Drop"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
alloc(newmem,1024)
label(returnhere)
label(originalcode)
label(exit)

define(stack_alloc,100)

// 4 bytes - global random drop count
// 4 bytes - x10,000 account random drop count
//alloc(player_random_drop_order,40004)
//define(accounts,#10000)

// ebp = raid
newmem:
cmp dword ptr [esp+18],0 // Killer
je originalcode

push ebx
sub esp,stack_alloc

mov esi,esp // store the stack pointer

// clear the memory
push stack_alloc
push 0
push esi
call msvcrt.memset
add esp,C

lea eax, dword ptr [ebp+118]
mov dword ptr [esi+stack_alloc-4],eax
push eax
call dword ptr [005540DC] // ntdll.RtlEnterCriticalSection

mov ecx, dword ptr [esi+stack_alloc+C] // mob
xor ebx,ebx

random_next:
mov edx, dword ptr [ebp+ebx*8+18]

cmp edx, dword ptr [esi+stack_alloc+1C]
je random_ok // skip all further checks for killer

push edx
push ecx
call func_is_player_within_range
test eax,eax
je random_next_check

random_ok:
mov eax, dword ptr [esi+stack_alloc-8]
mov dword ptr [esi+eax*4],edx
inc dword ptr [esi+stack_alloc-8]

random_next_check:
inc ebx
cmp ebx, dword ptr [ebp+10]
jb random_next

call msvcrt.rand
cdq
idiv dword ptr [esi+stack_alloc-8]

mov edx, dword ptr [esi+edx*4]

push ebp
push edx
call func_get_player_index_in_party

mov edx,eax // index of player in party

mov eax, dword ptr [esi+stack_alloc-4]
push eax
call dword ptr [005540D4] // ntdll.RtlLeaveCriticalSection

exit:
add esp,stack_alloc
pop ebx
jmp returnhere

originalcode:
call 0051BD66
cdq
idiv dword ptr [ebp+10]
jmp returnhere

// push player
// push mob
// call func_is_player_within_range
func_is_player_within_range:
push ecx
push edx
push ebx
sub esp,4

xor eax,eax // clearing the return value (false)

mov ecx, dword ptr [esp+14] // mob
mov edx, dword ptr [esp+18] // player

// comparing zone pointers
mov ebx, dword ptr [ecx+8C]
cmp ebx, dword ptr [edx+E0]
jne func_is_player_within_range_exit

 // load mob.X
fld dword ptr [ecx+7C]
// subtract player.X from it
fsub dword ptr [edx+D0]
// get the absolute value
fabs
 // square it
fmul st(0),st(0)
// store result in the stack and pop floating point register
fstp dword ptr [esp]

// load mob.Z
fld dword ptr [ecx+84]
// subtract player.Z from it
fsub dword ptr [edx+D8]
// get the absolute value
fabs
// square it
fmul st(0),st(0)
// add the value previously stored in stack to it
fadd dword ptr [esp]

// square root
fsqrt
// store result in the stack and pop floating point register
fstp dword ptr [esp]

cmp dword ptr [esp],(float)100.000 // max range
ja func_is_player_within_range_exit

inc eax // set return value to true
func_is_player_within_range_exit:
add esp,4
pop ebx
pop edx
pop ecx
ret 8

// push party
// push player
// call func_get_player_index_in_party
func_get_player_index_in_party:
push ecx
push edx
push ebx

mov ecx, dword ptr [esp+10] // player
mov edx, dword ptr [esp+14] // party

mov eax, dword ptr [edx+10] // party member count

func_get_player_index_in_party_next:
dec eax

cmp dword ptr [edx+eax*8+18],ecx
je func_get_player_index_in_party_exit

test eax,eax
jne func_get_player_index_in_party_next

func_get_player_index_in_party_exit:
pop ebx
pop edx
pop ecx
ret 8

//player_random_drop_order:
//dd CCCCCCCC

004BB266:
jmp newmem
nop
nop
nop
nop
returnhere:

[DISABLE]
dealloc(newmem)
//dealloc(player_random_drop_order)

004BB266:
call 0051BD66
cdq
idiv dword ptr [ebp+10]
</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>476</ID>
              <Description>"rune_cutting"</Description>
              <Options moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
              <LastState Value="" RealAddress="00000000"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>637</ID>
                  <Description>"jump_cutting"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//Bowie 06/2020
[ENABLE]
alloc(jump_cutting,32)
label(return)
{stand/sit/jump packet bytes
06 05 01 00 00 00 00 - stand
06 05 01 00 00 00 01 - sit
06 05 01 00 00 00 02 - jump}
jump_cutting:
mov cl,[ebp+02]
cmp cl,02
//stops sending jump packets
je 00479155
//original code
mov [esp+22],edx
jmp return

0047894D:
jmp jump_cutting
nop
nop
return:

[DISABLE]
dealloc(jump_cutting)
0047894D:
mov cl,[ebp+02]
mov [esp+22],edx
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>635</ID>
                  <Description>"bootleggery"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//by Bowie
[ENABLE]
alloc(newmem,32)
label(return)

newmem:
cmp dword ptr [ebp+00001270],02
je 0047468A
//original code
cmp dword ptr [eax+000001A4],00
jmp return

00473ED7:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00473ED7:
cmp dword ptr [eax+000001A4],00
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>115</ID>
                  <Description>"arena recall"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//by Bowie
[ENABLE]
alloc(newmem,32)
label(return)

newmem:
cmp dword ptr [ebp+00001270],02
je 0047468A
//original code
cmp dword ptr [eax+000001A4],00
jmp return

00473FFD:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00473FFD:
cmp dword ptr [eax+000001A4],00
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>636</ID>
                  <Description>"capital recall"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//by Bowie
[ENABLE]
alloc(newmem,32)
label(return)

newmem:
cmp dword ptr [ebp+00001270],02
je 0047468A
//original code
cmp dword ptr [eax+000001A4],00
jmp return

00473DB0:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00473DB0:
cmp dword ptr [eax+000001A4],00
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>474</ID>
                  <Description>"guild house"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//by Bowie
[ENABLE]
alloc(newmem,32)
label(return)

newmem:
cmp dword ptr [ebp+00001270],02
je 004742B6
//original code
cmp dword ptr [eax+000001A4],06
jmp return

00474196:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00474196:
cmp dword ptr [eax+000001A4],06
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>475</ID>
                  <Description>"party summon"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//by [DEV]AkaneTendo
[ENABLE]
alloc(newmem,32)
label(return)

newmem:
cmp dword ptr [ebp+00001270],02
je 0047468A
//original code
cmp dword ptr [ebp+000058B8],00
jmp return

00473400:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00473400:
cmp dword ptr [ebp+000058B8],00
</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>639</ID>
              <Description>"Dex fix "</Description>
              <Options moHideChildren="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
              <LastState Value="" RealAddress="00000000"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>224</ID>
                  <Description>"DEX Override (Melee)"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(pop_originalcode)
label(originalcode)
label(success)

define(dex_per_percent,#12)
define(min_accuracy,#20)

// edi = attacker
// esi = target
newmem:
cmp byte ptr [edi+1385],1
je originalcode

push eax
push ecx
push edx
sub esp,10

mov eax, dword ptr [edi+1220]
mov ecx, dword ptr [esi+1220]

cmp eax,ecx
ja success

sub eax,ecx
mov dword ptr [esp],eax
mov dword ptr [esp+4],dex_per_percent
fild dword ptr [esp+4] // dex_per_percent
fild dword ptr [esp] // DEX difference
fabs
fdiv st(0), st(1)
fistp dword ptr [esp]
fistp dword ptr [esp+4]

mov esi,#100
sub esi, dword ptr [esp]

cmp esi,min_accuracy
jae pop_originalcode

mov esi,min_accuracy

pop_originalcode:
add esp,10
pop edx
pop ecx
pop eax

originalcode:
cmp esi,01
jmp returnhere

success:
mov esi,#100
jmp pop_originalcode

00463D4B:
jmp newmem
returnhere:

[DISABLE]
dealloc(newmem)

00463D4B:
mov esi,eax
cmp esi,01
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>225</ID>
                  <Description>"DEX Override (Ranged)"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(pop_originalcode)
label(originalcode)
label(success)

define(dex_per_percent,#12)
define(min_accuracy,#20)

// edi = attacker
// esi = target
newmem:
cmp byte ptr [edi+1395],1
je originalcode

push eax
push ecx
push edx
sub esp,10

mov eax, dword ptr [edi+1220]
mov ecx, dword ptr [esi+1220]

cmp eax,ecx
ja success

sub eax,ecx
mov dword ptr [esp],eax
mov dword ptr [esp+4],dex_per_percent
fild dword ptr [esp+4] // dex_per_percent
fild dword ptr [esp] // DEX difference
fabs
fdiv st(0), st(1)
fistp dword ptr [esp]
fistp dword ptr [esp+4]

mov esi,#100
sub esi, dword ptr [esp]

cmp esi,min_accuracy
jae pop_originalcode

mov esi,min_accuracy

pop_originalcode:
add esp,10
pop edx
pop ecx
pop eax

originalcode:
cmp esi,01
jmp returnhere

success:
mov esi,#100
jmp pop_originalcode

00463C9D:
jmp newmem
returnhere:

[DISABLE]
dealloc(newmem)

00463C9D:
mov esi,eax
cmp esi,01
</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>236</ID>
          <Description>"Guild"</Description>
          <Options moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1" moAllowManualCollapseAndExpand="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <Color>000080</Color>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>238</ID>
              <Description>"Creation"</Description>
              <Options moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1" moAllowManualCollapseAndExpand="1"/>
              <LastState Value="" RealAddress="00000000"/>
              <Color>000080</Color>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>237</ID>
                  <Description>"Require only 3 people to be in the party"</Description>
                  <LastState/>
                  <Color>000080</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
//place your code here

originalcode:
cmp eax,03

exit:
jmp returnhere

"ps_game.exe"+850A8:
jmp newmem
nop
nop
nop
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+850A8:
cmp eax,07
jg ps_game.exe+8520C
//Alt: db 83 F8 03 0F 8F 5B 01 00 00
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>239</ID>
                  <Description>"Require only 3 people to accept the guild creation request"</Description>
                  <LastState/>
                  <Color>000080</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
//place your code here

originalcode:
cmp dword ptr [esi+24],03
jl ps_game.exe+85456

exit:
jmp returnhere

"ps_game.exe"+8542C:
jmp newmem
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+8542C:
cmp dword ptr [esi+24],07
jl ps_game.exe+85456
//Alt: db 83 7E 24 03 7C 24
</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>173</ID>
              <Description>"Guild Officer Count"</Description>
              <LastState/>
              <Color>000080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]

0043491B:
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop

[DISABLE]

0043491B:
cmp dword ptr [edi+3C],7
jnl 00434A09
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>183</ID>
              <Description>"Guild Penalty Remove"</Description>
              <LastState/>
              <Color>000080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]

0048598F:
jmp 004859C8
nop
nop
nop
nop
nop
nop
nop

[DISABLE]

0048598F:
cmp dword ptr [ebp+5580],0
je 004859C8
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>229</ID>
          <Description>"Admin &amp; GM Restrictions"</Description>
          <Options moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <Color>800000</Color>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>241</ID>
              <Description>"Admins see both faction trade chats"</Description>
              <LastState/>
              <Color>FF0000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
cmp byte ptr [ecx+5808],0B
JL "ps_game.exe"+27944

originalcode:
cmp dl,[ecx+0000012D]

exit:
jmp returnhere

"ps_game.exe"+27938:
jmp newmem
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+27938:
cmp dl,[ecx+0000012D]
//Alt: db 3A 91 2D 01 00 00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>31</ID>
              <Description>"Ability to attack both factions"</Description>
              <LastState/>
              <Color>800000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(exit)

newmem:
cmp byte ptr [eax+5808],#10
jb 00457E35
cmp dl,[eax+0000012D]

exit:
jmp returnhere

"ps_game.exe"+57E2D:
jmp newmem
nop
returnhere:

[DISABLE]
dealloc(newmem)
"ps_game.exe"+57E2D:
cmp dl,[eax+0000012D]
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>376</ID>
              <Description>"Allow /set command only on self"</Description>
              <LastState/>
              <Color>800000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,128)

// ebx = command caller
newmem:
mov edi,eax

cmp edi,ebx
jne returnhere

test edi,edi
jne 00480DA6

jmp returnhere

00480D90:
jmp newmem
nop
returnhere:

[DISABLE]

00480D90:
mov edi,eax
test edi,edi
jne 00480DA6

dealloc(newmem)
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>157</ID>
              <Description>"Allow Join Manual Raid (Admin, GM)"</Description>
              <LastState/>
              <Color>800000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,128)

label(check_raid_auto_1)
label(ret_check_raid_auto_1)

label(check_raid_auto_2)
label(ret_check_raid_auto_2)

define(delta,3C0)

newmem:
check_raid_auto_1:
mov eax, dword ptr [edi+17F4]
cmp byte ptr [eax+114+delta],0
je 004757E7
cmp byte ptr [ebp+5808],2
jbe 004757F7
jmp ret_check_raid_auto_1

check_raid_auto_2:
cmp byte ptr [ebp+5808],2
jbe 00450507
cmp byte ptr [eax+115+delta],0
je 004504FA
jmp ret_check_raid_auto_2

004757D8:
jmp check_raid_auto_1
nop
ret_check_raid_auto_1:

004504FE:
jmp check_raid_auto_2
nop
nop
nop
nop
ret_check_raid_auto_2:

[DISABLE]
/*
004757D8:
mov eax, dword ptr [edi+17F4]

004504FE:
cmp byte ptr [eax+115],0
je 004504FA

dealloc(newmem)
*/
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>378</ID>
              <Description>"Allow Join Both Faction Raid (Admin, GM)"</Description>
              <LastState/>
              <Color>800000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,128)

newmem:
cmp byte ptr [ebp+5808],2
jbe 004757D8

originalcode:
mov dl, byte ptr [ebp+12D]
jmp returnhere

004757BA:
jmp newmem
nop
returnhere:

[DISABLE]

004757BA:
mov dl, byte ptr [ebp+12D]

dealloc(newmem)
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>307</ID>
          <Description>"Raid"</Description>
          <Options moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1" moAllowManualCollapseAndExpand="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <Color>800080</Color>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>139</ID>
              <Description>"Raid Allocation Size"</Description>
              <LastState/>
              <Color>800080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]

00452253:
push 610

[DISABLE]
/*
00452253:
push 150
*/
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>141</ID>
              <Description>"Raid Memory Clear"</Description>
              <LastState/>
              <Color>800080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,64)
label(returnhere)
label(next)

define(delta,3C0)

0044E08B:
mov dword ptr [eax+104+delta],ebx
mov dword ptr [eax+108+delta],ebx
mov dword ptr [eax+10C+delta],ebx

0044E0A6:
mov edx,#150

0044E0C1:
mov byte ptr [eax+114+delta],bl
mov byte ptr [eax+115+delta],bl
mov dword ptr [eax+110+delta],1

newmem:
mov edx,510
next:
mov dword ptr [eax+edx],0
add edx,4
cmp edx,610
jb next
jmp returnhere

0044E0D7:
jmp newmem
returnhere:
pop ebx
ret

[DISABLE]
/*
0044E08B:
mov dword ptr [eax+104],ebx
mov dword ptr [eax+108],ebx
mov dword ptr [eax+10C],ebx

0044E0A6:
mov edx,1E

0044E0C1:
mov byte ptr [eax+114],bl
mov byte ptr [eax+115],bl
mov dword ptr [eax+110],1

0044E0D7:
pop ebx
ret
db CC CC CC CC CC

dealloc(newmem)
*/
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>142</ID>
              <Description>"Raid Memory Expansion"</Description>
              <LastState/>
              <Color>800080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]

define(delta,3C0)

00450CBB:
mov [edi+104+delta],eax

00450CC2:
cmp [edi+114+delta],al

0044E170:
mov al,[edi+114+delta]

0044ED70:
cmp byte ptr [eax+114+delta],1

0044E979:
mov al,[esi+114+delta]

0044E170:
mov al,[edi+114+delta]

0044E219:
mov [edi+10C+delta],eax

0044EC06:
mov cl,[ebx+114+delta]

004A1DBE:
mov al,[edi+114+delta]

004A1F15:
mov eax,[edi+10C+delta]

004BA98B:
cmp dword ptr [eax+104+delta],4

0049BC2D:
mov al,[esi+114+delta]

0049127B:
mov al,[ebx+114+delta]

004911AE:
mov cl,[ebx+114+delta]

0044E8C4:
mov al,[edi+114+delta]

0044EC75:
mov byte ptr [esi+114+delta],1

0044ECA8:
cmp eax,[esi+110+delta]

0044ECBF:
mov [esi+110+delta],eax

004758C7:
mov [edx+114+delta],al

004758D6:
mov [ecx+104+delta],edx

004758E6:
mov [eax+115+delta],cl

004758FC:
movzx eax,byte ptr [esi+114+delta]

00475907:
movzx ecx,byte ptr [esi+115+delta]

00475912:
mov edx,[esi+104+delta]

00475927:
mov edx,[esi+110+delta]

004759E4:
cmp byte ptr [eax+114+delta],0

004759F4:
mov [eax+115+delta],cl

00475A0A:
mov al,[esi+115+delta]

00475976:
cmp byte ptr [eax+114+delta],0

00475986:
mov [eax+104+delta],edx

00475D46:
cmp byte ptr [edi+114+delta],0

00475DA2:
mov ecx,[esi+110+delta]

00475A99:
cmp byte ptr [eax+114+delta],0

0044E5CE:
mov [esi+110+delta],eax
mov ecx,[esi+110+delta]

00475A4C:
cmp byte ptr [eax+114+delta],0

0044E6E5:
cmp edi,[esi+110+delta]

0044E708:
mov [esi+110+delta],eax
mov ecx,[esi+110+delta]

00475DF5:
cmp byte ptr [esi+114+delta],0

0044DFD5:
lea eax,[esi+118+delta]

00450719:
add esi,130+delta

0044F4E7:
lea eax,[ebp+118+delta]

0049B131:
lea edi,[esi+118+delta]

0049B15B:
lea ebx,[edi+118+delta]

0049B184:
add esi,118+delta

0044F24C:
lea eax,[ebp+118+delta]

0044DFE7:
lea eax,[esi+130+delta]

0044E967:
lea eax,[esi+118+delta]

004509DE:
add edi,130+delta

0049B1A6:
add esi,118+delta

0044E0E0:
add eax,118+delta

0044E0F0:
add eax,118+delta

0044E11C:
add eax,118+delta

0044E133:
add eax,118+delta

0044E156:
add eax,118+delta

0044EC8D:
lea edi,[esi+118+delta]

00475423:
add eax,118+delta

0044EB85:
lea edi,[ebx+118+delta]

00478862:
add eax,118+delta

0044E4C3:
lea ebx,[edi+118+delta]

0044E669:
lea ebx,[esi+118+delta]

0044E261:
lea edi,[esi+118+delta]

0044EDBE:
lea esi,[ebp+118+delta]

0044EF59:
mov ecx,[ebp+110+delta]

0044EF6B:
mov cl,[ebp+115+delta]

0044EF78:
mov cx,[ebp+104+delta]

0044EF88:
movzx eax,byte ptr [ebp+114+delta]

0044E1CB:
mov [edi+10C+delta],edx

0044F17A:
lea eax,[ebp+118+delta]

0044EA14:
lea edi,[ebx+118+delta]

0044F5F6:
cmp byte ptr [ecx+114+delta],1

0044F641:
lea eax,[ebx+118+delta]

0044F6B3:
cmp edi,[ebx+110+delta]

00450622:
add edi,130+delta

0044FA81:
lea eax,[ebx+118+delta]

0044FB22:
mov eax,[ebx+108+delta]

0044E8B7:
lea ebx,[edi+118+delta]

00450238:
lea eax,[ebx+118+delta]

0044E597:
lea edi,[esi+118+delta]

0047583A:
cmp byte ptr [esi+114+delta],0

0044FDEB:
lea eax,[ebx+118+delta]

0044FE57:
cmp edi,[ebx+110+delta]

0044FEE2:
mov eax,[ebx+108+delta]

0044FF83:
mov [ebx+110+delta],eax

00450129:
mov edx,[ebx+110+delta]

0044F734:
mov eax,[ebx+108+delta]

0044E2A0:
cmp byte ptr [esi+114+delta],0

0044E2AF:
lea edi,[esi+118+delta]

0044E2C2:
mov eax,[esi+110+delta]

0044E2F2:
lea edi,[esi+118+delta]

004757DE:
cmp byte ptr [eax+115+delta],0

004504F1:
cmp byte ptr [eax+114+delta],0

004504FE:
cmp byte ptr [eax+115+delta],0

00450521:
add edi,130+delta

004505A1:
add edi,130+delta

004506A1:
add edi,130+delta

00450B17:
add edi,130+delta

004A1DAD:
lea eax,[edi+118+delta]

004A1E3C:
mov eax,[edi+10C+delta]

0049130E:
mov cl,[ebx+114+delta]

00465F95:
lea ebp,[esi+118+delta]

00465FFF:
add esi,118+delta

0046583C:
lea eax,[ebx+118+delta]

0046584D:
mov al,[ebx+114+delta]

00467758:
lea eax,[esi+118+delta]

004677DC:
mov ebx,[esi+108+delta]

00467804:
mov [esi+108+delta],ebx

004659F9:
mov eax,[edx+10C+delta]

0049B1F3:
lea edi,[esi+118+delta]

0049B21F:
add esi,118+delta

0046A871:
mov al,[ecx+114+delta]

0044EAA4:
lea esi,[ebp+118+delta]

0046776F:
mov eax,[esi+104+delta]

0046B401:
mov al,[ecx+114+delta]

00467419:
add eax,118+delta

004677CA:
cmp [esi+108+delta],eax

0046783B:
inc [esi+108+delta]

004677D2:
mov [esi+108+delta],0

00465D80:
lea ebx,[esi+118+delta]

00465DB8:
mov al,[ebx+114+delta]

00465E05:
add esi,118+delta

0044E059:
add esi,118+delta

00460494:
add edi,118+delta

0046066D:
add edi,118+delta

00467443:
add eax,118+delta

00475658:
add eax,118+delta

00475CF0:
add eax,118+delta

00476926:
add eax,118+delta

00476991:
add eax,118+delta

00478EBF:
add eax,118+delta

0047F92E:
add eax,118+delta

00480266:
add eax,118+delta

00482D6A:
add eax,118+delta

00482E2E:
add eax,118+delta

00483C42:
add eax,118+delta

00483C6F:
add eax,118+delta

004851CF:
add eax,118+delta

00485395:
add eax,118+delta

004856D0:
add eax,118+delta

0049093C:
add edi,118+delta

00490A4D:
add edi,118+delta

00490B5D:
add edi,118+delta

00490D3E:
add edi,118+delta

004912DA:
add edi,118+delta

00491807:
add ebp,118+delta

0049190D:
add esi,118+delta

0049B1BF:
add esi,118+delta

0049B232:
add esi,118+delta

0049BC84:
add ebx,118+delta

0049E589:
add eax,118+delta

004C6B30:
add eax,118+delta

004C6B54:
add eax,118+delta

00550A13:
add ecx,118+delta

00550A43:
add ecx,118+delta

005516F3:
add ecx,118+delta

004BAFE2:
cmp dword ptr [ebp+104+delta],4

004BB1DD:
cmp byte ptr [ebp+114+delta],1

004BB1E6:
cmp dword ptr [ebp+104+delta],4

004BB25B:
mov eax,[ebp+104+delta]

004BB2F0:
cmp [ebp+108+delta],eax

004BB302:
mov esi,[ebp+108+delta]

004BB370:
inc [ebp+108+delta]

004BB2F8:
mov [ebp+108+delta],0

004BB327:
mov [ebp+108+delta],esi

0044FB2D:
mov [ebx+108+delta],eax

00450B09:
mov eax,[edi+148+delta]

00450B11:
mov esi,[edi+130+delta]

0044E379:
lea edi,[ebp+118+delta]

0049BBEF:
lea esi,[ebx+118+delta]

0049124A:
lea ebx,[edi+118+delta]

0044E7C8:
lea ebp,[esi+118+delta]

0044FB61:
cmp byte ptr [ebx+114+delta],1

00450307:
cmp byte ptr [ebx+114+delta],1

004908D4:
lea ebx,[edi+118+delta]

00491767:
lea eax,[ebp+118+delta]

004917A4:
mov al,[edx+114+delta]

00490C8A:
lea ebx,[edi+118+delta]

00490CBF:
mov al,[ebx+114+delta]

004919C1:
mov al,[ebx+114+delta]

00491A12:
lea edi,[ebx+118+delta]

00490905:
mov al,[ebx+114+delta]

004909E5:
lea ebx,[edi+118+delta]

00490A16:
mov al,[ebx+114+delta]

00490AF5:
lea ebx,[edi+118+delta]

00490B26:
mov al,[ebx+114+delta]

004F22C1:
cmp dword ptr [ecx+118+delta],0

004F22D1:
mov ecx,[ecx+118+delta]

0044F71A:
mov edx,[ebx+110+delta]

0044F725:
mov [ebx+110+delta],edx

0044F792:
mov edx,[ebx+110+delta]

0044F7C2:
mov [ebx+110+delta],eax

0044F969:
mov edx,[ebx+110+delta]

00455C69:
cmp byte ptr [ecx+114+delta],1

0044FEC8:
mov edx,[ebx+110+delta]

0044F76E:
cmp byte ptr [ebx+114+delta],1

0044FF2F:
cmp byte ptr [ebx+114+delta],1

004604B4:
mov dl,[ecx+114+delta]

0047F95F:
cmp byte ptr [edi+114+delta],0

0047F971:
mov ecx,[edi+110+delta]

00475D5C:
mov edx,[edi+110+delta]

0049E4C6:
cmp byte ptr [ebx+114+delta],1

004609E0:
lea ebx,[esi+118+delta]

004734A2:
lea eax,[esi+118+delta]

0044E322:
lea edi,[esi+118+delta]

0044E331:
cmp [esi+114+delta],bl

0044E34A:
mov eax,[esi+110+delta]

0044E551:
lea edi,[esi+118+delta]

0044E567:
cmp eax,[esi+110+delta]

0044E611:
lea edi,[esi+118+delta]

0044E62C:
cmp eax,[esi+110+delta]

0044E645:
mov [esi+110+delta],eax

004600EE:
lea ebp,[esi+118+delta]

00460272:
lea esi,[ebp+118+delta]

0046028E:
mov cl,[ebp+114+delta]

0046083E:
lea ebp,[esi+118+delta]

00460B87:
lea edi,[esi+118+delta]

00491876:
lea ebx,[esi+118+delta]

004918AB:
mov al,[edx+114+delta]

0044F73F:
mov [ebx+108+delta],eax

0044ED43:
cmp byte ptr [ecx+114+delta],0

0044ED4D:
mov esi,[ecx+108+delta]

0044ECD0:
mov [eax+115+delta],cl

0044ECE0:
mov [eax+104+delta],ecx

0044ECE0:
mov [eax+104+delta],ecx

0044FEED:
mov [ebx+108+delta],eax

0044FF53:
mov edx,[ebx+110+delta]

00467869:
mov [esi+108+delta],0
mov ebx,[esi+108+delta]

0046789B:
mov [esi+108+delta],ebx

004678C4:
inc [esi+108+delta]

004BB39F:
mov [ebp+108+delta],0
mov esi,[ebp+108+delta]

004BB3D3:
mov [ebp+108+delta],esi

004BB424:
inc [ebp+108+delta]

004BB397:
cmp [ebp+108+delta],eax

0044FED3:
mov [ebx+110+delta],edx

00467861:
cmp [esi+108+delta],eax

[DISABLE]
/*
00450CBB:
mov [edi+104],eax

00450CC2:
cmp [edi+114],al

0044E170:
mov al,[edi+114]

0044ED70:
cmp byte ptr [eax+114],1

0044E979:
mov al,[esi+114]

0044E170:
mov al,[edi+114]

0044E219:
mov [edi+10C],eax

0044EC06:
mov cl,[ebx+114]

004A1DBE:
mov al,[edi+114]

004A1F15:
mov eax,[edi+10C]

004BA98B:
cmp dword ptr [eax+104],4

0049BC2D:
mov al,[esi+114]

0049127B:
mov al,[ebx+114]

004911AE:
mov cl,[ebx+114]

0044E8C4:
mov al,[edi+114]

0044EC75:
mov byte ptr [esi+114],1

0044ECA8:
cmp eax,[esi+110]

0044ECBF:
mov [esi+110],eax

004758C7:
mov [edx+114],al

004758D6:
mov [ecx+104],edx

004758E6:
mov [eax+115],cl

004758FC:
movzx eax,byte ptr [esi+114]

00475907:
movzx ecx,byte ptr [esi+115]

00475912:
mov edx,[esi+104]

00475927:
mov edx,[esi+110]

004759E4:
cmp byte ptr [eax+114],0

004759F4:
mov [eax+115],cl

00475A0A:
mov al,[esi+115]

00475976:
cmp byte ptr [eax+114],0

00475986:
mov [eax+104],edx

00475D46:
cmp byte ptr [edi+114],0

00475DA2:
mov ecx,[esi+110]

00475A99:
cmp byte ptr [eax+114],0

0044E5CE:
mov [esi+110],eax
mov ecx,[esi+110]

00475A4C:
cmp byte ptr [eax+114],0

0044E6E5:
cmp edi,[esi+110]

0044E708:
mov [esi+110],eax
mov ecx,[esi+110]

00475DF5:
cmp byte ptr [esi+114],0

0044DFD5:
lea eax,[esi+118]

00450719:
add esi,130

0044F4E7:
lea eax,[ebp+118]

0049B131:
lea edi,[esi+118]

0049B15B:
lea ebx,[edi+118]

0049B184:
add esi,118

0044F24C:
lea eax,[ebp+118]

0044DFE7:
lea eax,[esi+130]

0044E967:
lea eax,[esi+118]

004509DE:
add edi,130

0049B1A6:
add esi,118

0044E0E0:
add eax,118

0044E0F0:
add eax,118

0044E11C:
add eax,118

0044E133:
add eax,118

0044E156:
add eax,118

0044EC8D:
lea edi,[esi+118]

00475423:
add eax,118

0044EB85:
lea edi,[ebx+118]

00478862:
add eax,118

0044E4C3:
lea ebx,[edi+118]

0044E669:
lea ebx,[esi+118]

0044E261:
lea edi,[esi+118]

0044EDBE:
lea esi,[ebp+118]

0044EF59:
mov ecx,[ebp+110]

0044EF6B:
mov cl,[ebp+115]

0044EF78:
mov cx,[ebp+104]

0044EF88:
movzx eax,byte ptr [ebp+114]

0044E1CB:
mov [edi+10C],edx

0044F17A:
lea eax,[ebp+118]

0044EA14:
lea edi,[ebx+118]

0044F5F6:
cmp byte ptr [ecx+114],1

0044F641:
lea eax,[ebx+118]

0044F6B3:
cmp edi,[ebx+110]

00450622:
add edi,130

0044FA81:
lea eax,[ebx+118]

0044FB22:
mov eax,[ebx+108]

0044E8B7:
lea ebx,[edi+118]

00450238:
lea eax,[ebx+118]

0044E597:
lea edi,[esi+118]

0047583A:
cmp byte ptr [esi+114],0

0044FDEB:
lea eax,[ebx+118]

0044FE57:
cmp edi,[ebx+110]

0044FEE2:
mov eax,[ebx+108]

0044FF83:
mov [ebx+110],eax

00450129:
mov edx,[ebx+110]

0044F734:
mov eax,[ebx+108]

0044E2A0:
cmp byte ptr [esi+114],0

0044E2AF:
lea edi,[esi+118]

0044E2C2:
mov eax,[esi+110]

0044E2F2:
lea edi,[esi+118]

004757DE:
cmp byte ptr [eax+115],0

004504F1:
cmp byte ptr [eax+114],0

004504FE:
cmp byte ptr [eax+115],0

00450521:
add edi,130

004505A1:
add edi,130

004506A1:
add edi,130

00450B17:
add edi,130

004A1DAD:
lea eax,[edi+118]

004A1E3C:
mov eax,[edi+10C]

0049130E:
mov cl,[ebx+114]

00465F95:
lea ebp,[esi+118]

00465FFF:
add esi,118

0046583C:
lea eax,[ebx+118]

0046584D:
mov al,[ebx+114]

00467758:
lea eax,[esi+118]

004677DC:
mov ebx,[esi+108]

00467804:
mov [esi+108],ebx

004659F9:
mov eax,[edx+10C]

0049B1F3:
lea edi,[esi+118]

0049B21F:
add esi,118

0046A871:
mov al,[ecx+114]

0044EAA4:
lea esi,[ebp+118]

0046776F:
mov eax,[esi+104]

0046B401:
mov al,[ecx+114]

00467419:
add eax,118

004677CA:
cmp [esi+108],eax

0046783B:
inc [esi+108]

004677D2:
mov [esi+108],0

00465D80:
lea ebx,[esi+118]

00465DB8:
mov al,[ebx+114]

00465E05:
add esi,118

0044E059:
add esi,118

00460494:
add edi,118

0046066D:
add edi,118

00467443:
add eax,118

00475658:
add eax,118

00475CF0:
add eax,118

00476926:
add eax,118

00476991:
add eax,118

00478EBF:
add eax,118

0047F92E:
add eax,118

00480266:
add eax,118

00482D6A:
add eax,118

00482E2E:
add eax,118

00483C42:
add eax,118

00483C6F:
add eax,118

004851CF:
add eax,118

00485395:
add eax,118

004856D0:
add eax,118

0049093C:
add edi,118

00490A4D:
add edi,118

00490B5D:
add edi,118

00490D3E:
add edi,118

004912DA:
add edi,118

00491807:
add ebp,118

0049190D:
add esi,118

0049B1BF:
add esi,118

0049B232:
add esi,118

0049BC84:
add ebx,118

0049E589:
add eax,118

004C6B30:
add eax,118

004C6B54:
add eax,118

00550A13:
add ecx,118

00550A43:
add ecx,118

005516F3:
add ecx,118

004BAFE2:
cmp dword ptr [ebp+104],4

004BB1DD:
cmp byte ptr [ebp+114],1

004BB1E6:
cmp dword ptr [ebp+104],4

004BB25B:
mov eax,[ebp+104]

004BB2F0:
cmp [ebp+108],eax

004BB302:
mov esi,[ebp+108]

004BB370:
inc [ebp+108]

004BB2F8:
mov [ebp+108],0

004BB327:
mov [ebp+108],esi

0044FB2D:
mov [ebx+108],eax

00450B09:
mov eax,[edi+148]

00450B11:
mov esi,[edi+130]

0044E379:
lea edi,[ebp+118]

0049BBEF:
lea esi,[ebx+118]

0049124A:
lea ebx,[edi+118]

0044E7C8:
lea ebp,[esi+118]

0044FB61:
cmp byte ptr [ebx+114],1

00450307:
cmp byte ptr [ebx+114],1

004908D4:
lea ebx,[edi+118]

00491767:
lea eax,[ebp+118]

004917A4:
mov al,[edx+114]

00490C8A:
lea ebx,[edi+118]

00490CBF:
mov al,[ebx+114]

004919C1:
mov al,[ebx+114]

00491A12:
lea edi,[ebx+118]

00490905:
mov al,[ebx+114]

004909E5:
lea ebx,[edi+118]

00490A16:
mov al,[ebx+114]

00490AF5:
lea ebx,[edi+118]

00490B26:
mov al,[ebx+114]

004F22C1:
cmp dword ptr [ecx+118],0

004F22D1:
mov ecx,[ecx+118]

0044F71A:
mov edx,[ebx+110]

0044F725:
mov [ebx+110],edx

0044F792:
mov edx,[ebx+110]

0044F7C2:
mov [ebx+110],eax

0044F969:
mov edx,[ebx+110]

00455C69:
cmp byte ptr [ecx+114],1

0044FEC8:
mov edx,[ebx+110]

0044F76E:
cmp byte ptr [ebx+114],1

0044FF2F:
cmp byte ptr [ebx+114],1

004604B4:
mov dl,[ecx+114]

0047F95F:
cmp byte ptr [edi+114],0

0047F971:
mov ecx,[edi+110]

00475D5C:
mov edx,[edi+110]

0049E4C6:
cmp byte ptr [ebx+114],1

004609E0:
lea ebx,[esi+118]

004734A2:
lea eax,[esi+118]

0044E322:
lea edi,[esi+118]

0044E331:
cmp [esi+114],bl

0044E34A:
mov eax,[esi+110]

0044E551:
lea edi,[esi+118]

0044E567:
cmp eax,[esi+110]

0044E611:
lea edi,[esi+118]

0044E62C:
cmp eax,[esi+110]

0044E645:
mov [esi+110],eax

004600EE:
lea ebp,[esi+118]

00460272:
lea esi,[ebp+118]

0046028E:
mov cl,[ebp+114]

0046083E:
lea ebp,[esi+118]

00460B87:
lea edi,[esi+118]

00491876:
lea ebx,[esi+118]

004918AB:
mov al,[edx+114]

0044F73F:
mov [ebx+108],eax

0044ED43:
cmp byte ptr [ecx+114],0

0044ED4D:
mov esi,[ecx+108]

0044ECD0:
mov [eax+115],cl

0044ECE0:
mov [eax+104],ecx

0044ECE0:
mov [eax+104],ecx

0044FEED:
mov [ebx+108],eax

0044FF53:
mov edx,[ebx+110]

00467869:
mov [esi+108],0
mov ebx,[esi+108]

0046789B:
mov [esi+108],ebx

004678C4:
inc [esi+108]

004BB39F:
mov [ebp+108],0
mov esi,[ebp+108]

004BB3D3:
mov [ebp+108],esi

004BB424:
inc [ebp+108]

004BB397:
cmp [ebp+108],eax

0044FED3:
mov [ebx+110],edx

00467861:
cmp [esi+108],eax
*/
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>140</ID>
              <Description>"Raid Capacity"</Description>
              <LastState/>
              <Color>800080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,512)

label(raid_max_slots)
registersymbol(raid_max_slots)

newmem:

raid_max_slots:
dd #150

rc1:
push ecx
mov ecx, dword ptr [raid_max_slots]
cmp dword ptr [eax+10],ecx
pop ecx
jl 0047580D
jmp ret_rc1

rc2:
push eax
mov eax, dword ptr [raid_max_slots]
cmp dword ptr [ebp+10],eax
pop eax
push esi
jmp ret_rc2

rc3:
cmp eax, dword ptr [raid_max_slots]
jl 0044F587
jmp ret_rc3

rc4:
cmp eax, dword ptr [raid_max_slots]
mov [esp+24],eax
jmp ret_rc4

rc5:
cmp eax, dword ptr [raid_max_slots]
jl 0044E563
jmp ret_rc5

rc6:
cmp eax, dword ptr [raid_max_slots]
jl 0044ED58
jmp ret_rc6

rc7:
cmp eax, dword ptr [raid_max_slots]
jl 0044E6F4
jmp ret_rc7

rc8:
cmp esi, dword ptr [raid_max_slots]
jle 004658A4
jmp ret_rc8

rc9:
mov edi, dword ptr [raid_max_slots]
jmp ret_rc9

rc10:
mov edx, dword ptr [raid_max_slots]
jmp ret_rc10

rc11:
mov edi, dword ptr [raid_max_slots]
jmp ret_rc11

rc12:
mov edx, dword ptr [raid_max_slots]
jmp ret_rc12

rc13:
mov edx, dword ptr [raid_max_slots]
jmp ret_rc13

rc14:
cmp ecx, dword ptr [raid_max_slots]
jl 0044ED13
jmp ret_rc14

004757F7:
jmp rc1
nop
ret_rc1:

0044EDB0:
jmp rc2
ret_rc2:

0044F5A6:
jmp rc3
ret_rc3:

0044F128:
jmp rc4
nop
nop
ret_rc4:

0044E570:
jmp rc5
ret_rc5:

0044ED66:
jmp rc6
ret_rc6:

0044E701:
jmp rc7
ret_rc7:

0046589B:
jmp rc8
ret_rc8:

00475B1B:
jmp rc9
ret_rc9:

0045001B:
jmp rc10
ret_rc10:

00475E73:
jmp rc11
ret_rc11:

0044F85B:
jmp rc12
ret_rc12:

0044FC04:
jmp rc13
ret_rc13:

0044ED22:
jmp rc14
ret_rc14:

[DISABLE]
/*
004757F7:
cmp dword ptr [eax+10],1E
jl 0047580D

0044EDB0:
cmp dword ptr [ebp+10],1E
push esi

0044F5A6:
cmp eax,1E
jl 0044F587

0044F128:
cmp eax,1E
mov dword ptr [esp+24],eax

0044E570:
cmp eax,1E
jl 0044E563

0044ED66:
cmp eax,1E
jl 0044ED58

0044E701:
cmp eax,1E
jl 0044E6F4

0046589B:
cmp esi,1E
jle 004658A4

00475B1B:
mov edi,1E

0045001B:
mov edx,1E

00475E73:
mov edi,1E

0044F85B:
mov edx,1E

0044FC04:
mov edx,1E

0044ED22:
cmp ecx,1E
jl 0044ED13

unregistersymbol(raid_max_slots)
dealloc(newmem)
*/
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>379</ID>
              <Description>"Raid Organizers"</Description>
              <LastState/>
              <Color>800080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,1024)
define(move_ok,00475D6C)
define(move_fail,00475634)
define(delta,3C0)

newmem:
mov edx, dword ptr [edi+110+delta]
cmp dword ptr [edi+edx*8+18],ebp
je move_ok

push ebp
call func_get_player_slot_in_raid

cdq
mov ecx,#30
div ecx
cmp edx,#29

je is_raid_organizer

jmp move_fail

is_raid_organizer:
sub esp,18

mov dword ptr [esp],eax          // organizer raid
mov dword ptr [esp+4],edx        // organizer slot

mov eax, dword ptr [ebx+2]
cdq
mov ecx,#30
div ecx

mov dword ptr [esp+8],eax        // old raid
mov dword ptr [esp+C],edx        // old slot

mov eax, dword ptr [ebx+6]
cdq
mov ecx,#30
div ecx

mov dword ptr [esp+10],eax        // new raid
mov dword ptr [esp+14],edx        // new slot

// different raid
cmp eax, dword ptr [esp]
jne is_raid_organizer_move_fail

// different raid
mov eax, dword ptr [esp+8]
cmp eax, dword ptr [esp]
jne is_raid_organizer_move_fail

// organizer slot
cmp dword ptr [esp+C],#29
je is_raid_organizer_move_fail

// organizer slot
cmp dword ptr [esp+14],#29
je is_raid_organizer_move_fail

add esp,18
jmp move_ok

is_raid_organizer_move_fail:
add esp,18
jmp move_fail

// push player
func_get_player_slot_in_raid:
push ecx
push ebx
push edi

mov edx, dword ptr [esp+10] // player
mov edi, dword ptr [edx+17F4]
xor eax,eax

func_get_player_slot_in_raid_next:
cmp edx, dword ptr [edi+eax*8+18]
je func_get_player_slot_in_raid_found

inc eax
cmp eax, dword ptr [raid_max_slots]
jb func_get_player_slot_in_raid_next

mov eax,-1
jmp func_get_player_slot_in_raid_exit

func_get_player_slot_in_raid_found:
mov eax, dword ptr [edi+eax*8+14]

func_get_player_slot_in_raid_exit:
pop edi
pop ebx
pop ecx
ret 4

00475D5C:
jmp newmem
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop
nop

[DISABLE]
/*
00475D5C:
mov edx, dword ptr [edi+110]
cmp dword ptr [edi+edx*8+18],ebp
jne 00475634
*/
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>380</ID>
              <Description>"Allow Raid Notice (Admin, GM)"</Description>
              <LastState/>
              <Color>800080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,1024)
define(raid_notice_ok,0047F97D)
define(raid_notice_fail,0047F922)
define(delta,3C0)

newmem:
mov ecx, dword ptr [edi+110+delta]
cmp dword ptr [edi+ecx*8+18],ebp
je raid_notice_ok

cmp byte ptr [ebp+5808],2
jbe raid_notice_ok

jmp raid_notice_fail

0047F971:
jmp newmem
nop
nop
nop
nop
nop
nop
nop

[DISABLE]
/*
0047F971:
mov ecx, dword ptr [edi+110]
cmp dword ptr [edi+ecx*8+18],ebp
jne 0047F922
*/
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>158</ID>
              <Description>"Raid Kick Restrictions (Admin, GM, Restricted Players)"</Description>
              <LastState/>
              <Color>800080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,1024)

label(raid_kick)
label(ret_raid_kick)
label(raid_kick_adm)
label(raid_kick_gm)
label(raid_kick_adm_notice)
label(raid_kick_gm_notice)

newmem:
raid_kick:
cmp byte ptr [eax+5808],1
je raid_kick_adm
cmp byte ptr [eax+5808],2
je raid_kick_gm

mov ebx, dword ptr [ebp+17F4]
jmp ret_raid_kick

raid_kick_adm:
push ecx
push edx
mov ecx,ebp
mov edx,raid_kick_adm_notice
push 34
push edx
call 004ED0E0
pop edx
pop ecx
jmp 00475417

raid_kick_gm:
push ecx
push edx
mov ecx,ebp
mov edx,raid_kick_gm_notice
push 30
push edx
call 004ED0E0
pop edx
pop ecx
jmp 00475417

raid_kick_adm_notice:
db 0B F9 31
db 'One does not simply kick an admin out of a raid.'
db 00

raid_kick_gm_notice:
db 0B F9 2D
db 'One does not simply kick a GM out of a raid.'
db 00

0047586C:
jmp raid_kick
nop
ret_raid_kick:

[DISABLE]

0047586C:
mov ebx, dword ptr [ebp+17F4]

dealloc(newmem)

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>377</ID>
              <Description>"Raid Notice Tag And Name"</Description>
              <LastState/>
              <Color>800080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,1024)
label(exit)

define(malloc_size,200)
define(delta,3C0)

// ebx = /raid packet
// ebp = player
newmem:
sub esp,4

// allocate memory
push malloc_size
call msvcrt.malloc
add esp,4

mov dword ptr [esp],eax

push malloc_size
push 0
push eax
call msvcrt.memset
add esp,C

push ebp
call func_get_player_role_in_raid

push eax
call func_get_tag_by_role_in_raid

test eax,eax
je concat_name

mov ecx, dword ptr [esp]

push eax
push ecx
call msvcrt.strcat
add esp,8

concat_name:
lea eax, dword ptr [ebp+184]
mov ecx, dword ptr [esp]

push eax
push ecx
call msvcrt.strcat
add esp,8

mov ecx, dword ptr [esp]

push string_colon
push ecx
call msvcrt.strcat
add esp,8

lea eax, dword ptr [ebx+3]
mov ecx, dword ptr [esp]

push eax
push ecx
call msvcrt.strcat
add esp,8

lea eax, dword ptr [ebx+3]
mov ecx, dword ptr [esp]

push ecx
push eax
call msvcrt.strcpy
add esp,8

lea eax, dword ptr [ebx+3]

push eax
call msvcrt.strlen
add esp,4

mov byte ptr [ebx+2],al

// free memory
mov ecx, dword ptr [esp]
push ecx
call msvcrt.free
add esp,4

exit:
mov al, byte ptr [ebx+2]
add esp,4

originalcode:
mov ecx, dword ptr [ebp+128]
jmp returnhere

// push playerPointer
// call func_get_player_role_in_raid
// eax = 0 =&gt; lead
// eax = 1 =&gt; sub-lead
// eax = 2 =&gt; member
func_get_player_role_in_raid:
push ecx
push edx
push ebx

mov ecx, dword ptr [esp+10] // get player
mov ebx, dword ptr [ecx+17F4] // get raid

xor eax,eax

mov edx, dword ptr [ebx+C] // get leader index
mov edx, dword ptr [ebx+edx*8+18] // get leader pointer

cmp ecx,edx
je func_get_player_role_in_raid_exit

inc eax

mov edx, dword ptr [ebx+110+delta] // get sub-leader index
mov edx, dword ptr [ebx+edx*8+18] // get sub-leader pointer

cmp ecx,edx
je func_get_player_role_in_raid_exit

inc eax

func_get_player_role_in_raid_exit:
pop ebx
pop edx
pop ecx
ret 4

// push roleInRaid
// call func_get_tag_by_role_in_raid
func_get_tag_by_role_in_raid:
push ecx

mov ecx, dword ptr [esp+8]

mov eax,tag_leader

test ecx,ecx
je func_get_tag_by_role_in_raid_exit

mov eax,tag_sub_leader

dec ecx
je func_get_tag_by_role_in_raid_exit

xor eax,eax

func_get_tag_by_role_in_raid_exit:
pop ecx
ret 4

tag_leader:
db '[L]' 0

tag_sub_leader:
db '[S-L]' 0

string_colon:
db ':' 0

0047F995:
jmp newmem
nop
returnhere:

[DISABLE]

0047F995:
mov ecx, dword ptr [ebp+128]

dealloc(newmem)
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>260</ID>
              <Description>"Shared PvP Kills"</Description>
              <LastState/>
              <Color>800080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)
label(M1)
label(M2)
label(M3)
label(M4)
label(M5)
label(M6)
label(M7)
label(M8)
label(M9)

newmem:
pushad
mov edi,esi
mov edx,[esi+000000E0]
xor ecx,ecx
mov cl,[esi+0000012D]
cmp ecx,01
je setzero
mov ecx,01
jmp gocall
setzero:
mov ecx,00
gocall:
push ecx
push edx
call ShareKill
popad
originalcode:

exit:
jmp 00465ACF

ShareKill:
sub esp,10 { 16 }
push ebx
push ebp
mov ebp,[esp+1C]
push esi
call dword ptr [ps_game.exe+1540D0] { -&gt;kernel32.GetTickCount }
lea esi,[ebp+0000018C]
mov ebx,eax
push esi
add ebx,000003E8 { 1000 }
mov [esp+1C],esi
call dword ptr [ps_game.exe+1540DC] { -&gt;ntdll.RtlEnterCriticalSection }
mov ecx,[ebp+00000184]
mov eax,[ecx+04]
mov [ebp+00000188],eax
cmp eax,ecx
je M1
test eax,eax
je M1
M8:
mov eax,[eax+08]
test eax,eax
je M2
lea esi,[eax-000000D0]
jmp M3
M2:
xor esi,esi
M3:
// cmp byte ptr [esi+00005808],0A { if ( *(_BYTE *)(v8 + 22376) &gt; 0xAu )}
//ja M4
//mov eax,[ebp+00000188] {  v6 = (CObjectLink *)CZone-&gt;m_listUser.cursor-&gt;next;}
//mov eax,[eax+04]
//jmp M6

M4:
cmp edi,esi
jne M5
mov ecx,[ebp+00000188]
mov eax,[ecx+04]
jmp M6
M5:
mov dl,[esp+24]
cmp [esi+0000012D],dl { if ( *(_BYTE *)(v8 + 301) == byCountry )}
jne M9
// NEW CODE HERE //
fld dword ptr [edi+000000D0]
push ecx
fsub dword ptr [esi+000000D0]
fstp dword ptr [esp+14]
fld dword ptr [edi+000000D8]
fsub dword ptr [esi+000000D8]
fstp dword ptr [esp+24]
fld dword ptr [esp+24]
fld dword ptr [esp+14]
fmul st(0),st(0)
fld st(1)
fmulp st(2),st(0)
faddp
fstp dword ptr [esp+24]
fld dword ptr [esp+24]
fstp dword ptr [esp]
call ps_game.exe+1B8A0
fcomp dword ptr [RangeFloat] { [300.00] }
add esp,04 { 00000004 }
fnstsw ax
sahf
//test ah,41 { 65 }
jae M9 { if ( v11 &gt; 10.0 )}
//Need check party
cmp [esi+000017F4],00
je M9
mov ecx,esi
push edi
call ps_game.exe+67CE0
//               //
M9:
mov edx,[ebp+00000188]
mov eax,[edx+04]
M6:
cmp eax,[ebp+00000184] { while ( v6 != CZone-&gt;m_listUser.head &amp;&amp; v6 );}
mov [ebp+00000188],eax
je M7
test eax,eax
jne M8
M7:
mov esi,[esp+18] { v4 = &amp;this-&gt;m_listUser.m_csList.m_cs;}
M1:
push esi
call dword ptr [ps_game.exe+1540D4] { -&gt;ntdll.RtlLeaveCriticalSection }
pop esi
pop ebp
pop ebx
add esp,10 { 16 }
ret 0008 { 00000008 }

RangeFloat:
dd 42C80000

"ps_game.exe"+65AAD:
jmp newmem
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+65AAD:
call ps_game.exe+67EE0
//Alt: db E8 2E 24 00 00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>634</ID>
              <Description>"Leader Summon Raid"</Description>
              <LastState/>
              <Color>800080</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(ItemSummonRaid)
label(checkcountry)
label(failed)
label(exit)
label(checkleader)
newmem:
call ps_game.exe+4ECF0
//esi=target player,edi=source player
//check map
originalcode:
pushad
movzx eax,word ptr [esi+0x160]
movzx ebx,word ptr [edi+0x160]
cmp eax,(int)45
je checkcountry
cmp ebx,(int)45
je checkcountry

jmp ItemSummonRaid

//checkcountry and check if same map
checkcountry:
cmp eax,ebx        //if they are in the same map which we speicifys
je ItemSummonRaid

movzx eax,byte ptr [esi+0x12d]
movzx ebx,byte ptr [edi+0x12d]
cmp eax,ebx
jne failed

/*
push eax               //party table
push ecx               //leader id
mov eax,[edi+17f4]
mov ecx,[eax+0c]       //leader id
imul ecx,ecx,8
add  ecx,18
mov  ecx,[eax+ecx]   //leader address
cmp edi,ecx          //compare address check is leader
pop ecx
pop eax
je 0049e4ea        //if yes
*/

ItemSummonRaid:

mov eax,dword ptr ds:[edi+0x58FC]
mov ecx,dword ptr ds:[edi+0x5900]
lea eax,dword ptr ds:[eax+eax*2]     // eax=bag,ecx=slot
lea edx,dword ptr ds:[ecx+eax*8]
imul edx,edx,4
mov eax,dword ptr ds:[edi+edx+0x1C0]
mov eax,dword ptr ds:[eax+30]
cmp [eax],(int)100045                 //orginal item id
popad
jne checkleader   //success addr
/*
mov eax,dword ptr ds:[eax+0x30]
cmp byte ptr ds:[eax+0x46],0x1F
*/



exit:
jmp returnhere

checkleader:
push eax               //party table
push ecx               //leader id
mov eax,[edi+17f4]
mov ecx,[eax+0c]       //leader id
imul ecx,ecx,8
add  ecx,18
mov  ecx,[eax+ecx]   //leader address
cmp edi,ecx          //compare address check is leader
pop ecx
pop eax
je 0049e4ea        //if yes
jmp 0049E517

failed:
popad
jmp 0049E517



"ps_game.exe"+9E4E1:

jmp newmem

returnhere:

[DISABLE]

//code from here till the end of the code will be used to disable the cheat

dealloc(newmem)

"ps_game.exe"+9E4E1:

call ps_game.exe+4ECF0

//Alt: db E8 0A 08 FB FF
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>641</ID>
      <Description>"FFA"</Description>
      <VariableType>4 Bytes</VariableType>
      <Address>FFA</Address>
      <CheatEntries>
        <CheatEntry>
          <ID>321</ID>
          <Description>"RVR"</Description>
          <Options moRecursiveSetValue="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>322</ID>
              <Description>"All red"</Description>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr [ebp+160],(int)86 //MapID
jne originalcode2
push eax
mov ecx, [ebx+000017F4]
cmp ecx, 0
je code
mov eax, [ebp+000017F4]
cmp eax, 0
je code
cmp eax, ecx
jne code
movzx ecx, byte ptr [ebp+0000012D] //kogo gryzit
jmp originalcode
code:
movzx ecx, byte ptr [ebx+0000012D] //kogo gryzit
movzx eax, byte ptr [ebp+0000012D] //komy otpravit
cmp eax, ecx
jne originalcode
cmp eax, 1
jne ex
mov cl, 0
jmp originalcode
ex:
mov cl, 1
originalcode:
pop eax
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]

exit:
jmp returnhere
originalcode2:
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
jmp exit

"ps_game.exe"+26B17:
jmp newmem
nop
nop
nop
nop
nop
nop
returnhere:

 
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+26B17:
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>12</ID>
              <Description>"party kick"</Description>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
add dword ptr [ebx+10],-01
push edi
mov edi,[esp+18]
cmp byte ptr [edi+160],(int)86 //MapID
jne originalcode2
pop edi

mov eax,0
zanovo:
pushad
push eax
sub esp,128
mov ecx,[esp+128+20+18]
mov ebx,[eax*8+esi+18]
cmp ecx,ebx
je sameCharacter
push ecx
mov ecx,[ebx+000000DC]
mov eax,00000303 { 771 }
mov [esp+34],ax
mov [esp+36],ecx
movzx eax,byte ptr [ebx+0000144C]
movzx ecx,byte ptr [ebx+0000012D]
sete dl
mov [esp+3A],dl
movzx edx,byte ptr [ebx+0000012E]
mov [esp+3B],al
movzx eax,byte ptr [ebx+00000131]
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
mov [esp+3D],dl
movzx edx,byte ptr [ebx+00000133]
mov [esp+3E],al
movzx eax,byte ptr [ebx+00000134]
mov [esp+3F],cl
movzx ecx,byte ptr [ebx+00000135]
push ebx
mov [esp+44],dl
mov [esp+45],al
mov [esp+46],cl
call ps_game.exe+9B120
movzx edx,byte ptr [ebx+0000012F]
mov ecx,[ebx+00000184]
mov [esp+43],al
mov eax,[ebx+00000148]
mov [esp+45],eax
mov eax,[ebx+0000018C]
mov [esp+44],dl
mov edx,[ebx+00000188]
mov [esp+69],eax
movzx eax,byte ptr [ebx+00000198]
mov [esp+61],ecx
mov ecx,[ebx+00000190]
mov [esp+65],edx
mov edx,[ebx+00000194]
mov [esp+75],al
mov [esp+6D],ecx
mov [esp+71],edx
mov byte ptr [esp+75],00 { 0 }
lea edi,[esp+4A]
lea ebp,[ebx+000001C0]
mov [esp+14],00000008 { 8 }
label5:
cmp dword ptr [ebp+00],00 { 0 }
je label1
mov esi,[ebp+00]
mov cl,[esi+40]
mov [edi-01],cl
mov dl,[esi+41]
lea eax,[esi+4C]
mov [edi],dl
lea edx,[eax+01]
lea esp,[esp+00]
label2:
mov cl,[eax]
inc eax
test cl,cl
jne label2
sub eax,edx
cmp eax,14 { 20 }
jne label3
mov al,[esi+5E]
cmp al,30 { 48 }
jl label3
cmp al,39 { 57 }
jg label3
mov cl,[esi+5F]
cmp cl,30 { 48 }
jl label3
cmp cl,39 { 57 }
jg label3
sub al,30 { 48 }
mov dl,0A { 10 }
imul dl
add al,cl
sub al,30 { 48 }
mov [edi+01],al
jmp label4
label3:
xor al,al
mov [edi+01],al
jmp label4
label1:
mov byte ptr [edi-01],00 { 0 }
mov byte ptr [edi],00 { 0 }
mov byte ptr [edi+01],00 { 0 }
label4:
add ebp,04 { 4 }
add edi,03 { 3 }
sub dword ptr [esp+14],01 { 1 }
jne label5
mov eax,[ebx+000001DC]
jmp label6
mov ecx,[eax+46]
mov [esp+76],ecx
mov dx,[eax+4A]
lea eax,[esp+7C]
push eax
mov [esp+7E],dx
call ps_game.exe+84F50
lea eax,[esp+7C]
lea edx,[eax+01]
nop
label7:
mov cl,[eax]
inc eax
test cl,cl
jne label7
sub eax,edx
add eax,49 { 73 }
lea ecx,[esp+38]
jmp label10
label6:
lea edx,[esp+76]
push edx
call ps_game.exe+84F50
lea eax,[esp+76]
lea edx,[eax+01]
label9:
mov cl,[eax]
inc eax
test cl,cl
jne label9
//mov edi,0
//mov esi,ebx
lea ebx,[ebx+18]
label10:
pop ecx
mov eax,50
push eax
lea eax,[esp+34]
push eax
movzx eax, byte ptr [ecx+0000012D]
cmp al,1
je odina
mov al,1
jmp asda
odina:
mov al,0
asda:
mov [esp+40],al
call ps_game.exe+ED0E0 //send
sameCharacter:
add esp,128
pop eax
popad
inc eax
cmp eax,[ebx+10]
jl zanovo

pushad
sub esp,128
mov ebx,[esp+128+20+14]
mov ecx,[ebx+000000DC]
mov eax,00000303 { 771 }
mov [esp+34],ax
mov [esp+36],ecx
movzx eax,byte ptr [ebx+0000144C]
movzx ecx,byte ptr [ebx+0000012D]
sete dl
mov [esp+3A],dl
movzx edx,byte ptr [ebx+0000012E]
mov [esp+3B],al
movzx eax,byte ptr [ebx+00000131]
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
mov [esp+3D],dl
movzx edx,byte ptr [ebx+00000133]
mov [esp+3E],al
movzx eax,byte ptr [ebx+00000134]
mov [esp+3F],cl
movzx ecx,byte ptr [ebx+00000135]
push ebx
mov [esp+44],dl
mov [esp+45],al
mov [esp+46],cl
call ps_game.exe+9B120
movzx edx,byte ptr [ebx+0000012F]
mov ecx,[ebx+00000184]
mov [esp+43],al
mov eax,[ebx+00000148]
mov [esp+45],eax
mov eax,[ebx+0000018C]
mov [esp+44],dl
mov edx,[ebx+00000188]
mov [esp+69],eax
movzx eax,byte ptr [ebx+00000198]
mov [esp+61],ecx
mov ecx,[ebx+00000190]
mov [esp+65],edx
mov edx,[ebx+00000194]
mov [esp+75],al
mov [esp+6D],ecx
mov [esp+71],edx
mov byte ptr [esp+75],00 { 0 }
lea edi,[esp+4A]
lea ebp,[ebx+000001C0]
mov [esp+14],00000008 { 8 }
labell5:
cmp dword ptr [ebp+00],00 { 0 }
je labell1
mov esi,[ebp+00]
mov cl,[esi+40]
mov [edi-01],cl
mov dl,[esi+41]
lea eax,[esi+4C]
mov [edi],dl
lea edx,[eax+01]
lea esp,[esp+00]
labell2:
mov cl,[eax]
inc eax
test cl,cl
jne labell2
sub eax,edx
cmp eax,14 { 20 }
jne labell3
mov al,[esi+5E]
cmp al,30 { 48 }
jl labell3
cmp al,39 { 57 }
jg labell3
mov cl,[esi+5F]
cmp cl,30 { 48 }
jl labell3
cmp cl,39 { 57 }
jg labell3
sub al,30 { 48 }
mov dl,0A { 10 }
imul dl
add al,cl
sub al,30 { 48 }
mov [edi+01],al
jmp labell4
labell3:
xor al,al
mov [edi+01],al
jmp labell4
labell1:
mov byte ptr [edi-01],00 { 0 }
mov byte ptr [edi],00 { 0 }
mov byte ptr [edi+01],00 { 0 }
labell4:
add ebp,04 { 4 }
add edi,03 { 3 }
sub dword ptr [esp+14],01 { 1 }
jne labell5
mov eax,[ebx+000001DC]
jmp labell6
mov ecx,[eax+46]
mov [esp+76],ecx
mov dx,[eax+4A]
lea eax,[esp+7C]
push eax
mov [esp+7E],dx
call ps_game.exe+84F50
lea eax,[esp+7C]
lea edx,[eax+01]
nop
labell7:
mov cl,[eax]
inc eax
test cl,cl
jne labell7
sub eax,edx
add eax,49 { 73 }
lea ecx,[esp+38]
jmp labell10
labell6:
lea edx,[esp+76]
push edx
call ps_game.exe+84F50
lea eax,[esp+76]
lea edx,[eax+01]
labell9:
mov cl,[eax]
inc eax
test cl,cl
jne labell9
mov edx,ebx
mov edi,0
mov ebx,[esp+120]
mov esi,ebx
lea ebx,[ebx+18]
labell10:
mov ecx,[ebx]
cmp ecx,edx
je labell11
test ecx,ecx
je labell11
sub eax,edx
mov eax,50
push eax
lea eax,[esp+38]
push eax
movzx eax, byte ptr [ecx+0000012D]
cmp al,1
je odinaa
mov al,1
jmp asdaa
odinaa:
mov al,0
asdaa:
mov [esp+3C+8],al
call ps_game.exe+ED0E0 //send
labell11:
add edi,01 { 1 }
add ebx,08 { 8 }
cmp edi,[esi+10]
jl labell10
originalcode:
add esp,00000128 { 296 }
popad
mov eax,[ebx+10]

exit:
jmp returnhere

originalcode2:
pop edi
mov eax,[ebx+10]
jmp exit

"ps_game.exe"+502DE:
jmp newmem
nop
nop
returnhere:

 
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+502DE:
add dword ptr [ebx+10],-01
mov eax,[ebx+10]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>323</ID>
              <Description>"party leave"</Description>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
add dword ptr [ebx+10],-01
push edi
mov edi,[esp+28]
cmp byte ptr [edi+160],(int)86 //MapID
jne originalcode2
pop edi
mov eax,0
zanovo:
pushad
push eax
sub esp,128
mov ecx,[esp+128+20+28]
mov ebx,[eax*8+esi+18]
cmp ecx,ebx
je sameCharacter
push ecx
mov ecx,[ebx+000000DC]
mov eax,00000303 { 771 }
mov [esp+34],ax
mov [esp+36],ecx
movzx eax,byte ptr [ebx+0000144C]
movzx ecx,byte ptr [ebx+0000012D]
sete dl
mov [esp+3A],dl
movzx edx,byte ptr [ebx+0000012E]
mov [esp+3B],al
movzx eax,byte ptr [ebx+00000131]
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
mov [esp+3D],dl
movzx edx,byte ptr [ebx+00000133]
mov [esp+3E],al
movzx eax,byte ptr [ebx+00000134]
mov [esp+3F],cl
movzx ecx,byte ptr [ebx+00000135]
push ebx
mov [esp+44],dl
mov [esp+45],al
mov [esp+46],cl
call ps_game.exe+9B120
movzx edx,byte ptr [ebx+0000012F]
mov ecx,[ebx+00000184]
mov [esp+43],al
mov eax,[ebx+00000148]
mov [esp+45],eax
mov eax,[ebx+0000018C]
mov [esp+44],dl
mov edx,[ebx+00000188]
mov [esp+69],eax
movzx eax,byte ptr [ebx+00000198]
mov [esp+61],ecx
mov ecx,[ebx+00000190]
mov [esp+65],edx
mov edx,[ebx+00000194]
mov [esp+75],al
mov [esp+6D],ecx
mov [esp+71],edx
mov byte ptr [esp+75],00 { 0 }
lea edi,[esp+4A]
lea ebp,[ebx+000001C0]
mov [esp+14],00000008 { 8 }
label5:
cmp dword ptr [ebp+00],00 { 0 }
je label1
mov esi,[ebp+00]
mov cl,[esi+40]
mov [edi-01],cl
mov dl,[esi+41]
lea eax,[esi+4C]
mov [edi],dl
lea edx,[eax+01]
lea esp,[esp+00]
label2:
mov cl,[eax]
inc eax
test cl,cl
jne label2
sub eax,edx
cmp eax,14 { 20 }
jne label3
mov al,[esi+5E]
cmp al,30 { 48 }
jl label3
cmp al,39 { 57 }
jg label3
mov cl,[esi+5F]
cmp cl,30 { 48 }
jl label3
cmp cl,39 { 57 }
jg label3
sub al,30 { 48 }
mov dl,0A { 10 }
imul dl
add al,cl
sub al,30 { 48 }
mov [edi+01],al
jmp label4
label3:
xor al,al
mov [edi+01],al
jmp label4
label1:
mov byte ptr [edi-01],00 { 0 }
mov byte ptr [edi],00 { 0 }
mov byte ptr [edi+01],00 { 0 }
label4:
add ebp,04 { 4 }
add edi,03 { 3 }
sub dword ptr [esp+14],01 { 1 }
jne label5
mov eax,[ebx+000001DC]
jmp label6
mov ecx,[eax+46]
mov [esp+76],ecx
mov dx,[eax+4A]
lea eax,[esp+7C]
push eax
mov [esp+7E],dx
call ps_game.exe+84F50
lea eax,[esp+7C]
lea edx,[eax+01]
nop
label7:
mov cl,[eax]
inc eax
test cl,cl
jne label7
sub eax,edx
add eax,49 { 73 }
lea ecx,[esp+38]
mov ebx,[ebx+17F4]
lea ebx,[ebx+18]
jmp label10
label6:
lea edx,[esp+76]
push edx
call ps_game.exe+84F50
lea eax,[esp+76]
lea edx,[eax+01]
label9:
mov cl,[eax]
inc eax
test cl,cl
jne label9
//mov edi,0
//mov esi,ebx
lea ebx,[ebx+18]
label10:
pop ecx
mov eax,50
push eax
lea eax,[esp+34]
push eax
movzx eax, byte ptr [ecx+0000012D]
cmp al,1
je odina
mov al,1
jmp asda
odina:
mov al,0
asda:
mov [esp+40],al
call ps_game.exe+ED0E0 //send
sameCharacter:
add esp,128
pop eax
popad
inc eax
cmp eax,[ebx+10]
jl zanovo

pushad
sub esp,128
mov ebx,[esp+128+20+24]
mov ecx,[ebx+000000DC]
mov eax,00000303 { 771 }
mov [esp+34],ax
mov [esp+36],ecx
movzx eax,byte ptr [ebx+0000144C]
movzx ecx,byte ptr [ebx+0000012D]
sete dl
mov [esp+3A],dl
movzx edx,byte ptr [ebx+0000012E]
mov [esp+3B],al
movzx eax,byte ptr [ebx+00000131]
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
mov [esp+3D],dl
movzx edx,byte ptr [ebx+00000133]
mov [esp+3E],al
movzx eax,byte ptr [ebx+00000134]
mov [esp+3F],cl
movzx ecx,byte ptr [ebx+00000135]
push ebx
mov [esp+44],dl
mov [esp+45],al
mov [esp+46],cl
call ps_game.exe+9B120
movzx edx,byte ptr [ebx+0000012F]
mov ecx,[ebx+00000184]
mov [esp+43],al
mov eax,[ebx+00000148]
mov [esp+45],eax
mov eax,[ebx+0000018C]
mov [esp+44],dl
mov edx,[ebx+00000188]
mov [esp+69],eax
movzx eax,byte ptr [ebx+00000198]
mov [esp+61],ecx
mov ecx,[ebx+00000190]
mov [esp+65],edx
mov edx,[ebx+00000194]
mov [esp+75],al
mov [esp+6D],ecx
mov [esp+71],edx
mov byte ptr [esp+75],00 { 0 }
lea edi,[esp+4A]
lea ebp,[ebx+000001C0]
mov [esp+14],00000008 { 8 }
labell5:
cmp dword ptr [ebp+00],00 { 0 }
je labell1
mov esi,[ebp+00]
mov cl,[esi+40]
mov [edi-01],cl
mov dl,[esi+41]
lea eax,[esi+4C]
mov [edi],dl
lea edx,[eax+01]
lea esp,[esp+00]
labell2:
mov cl,[eax]
inc eax
test cl,cl
jne labell2
sub eax,edx
cmp eax,14 { 20 }
jne labell3
mov al,[esi+5E]
cmp al,30 { 48 }
jl labell3
cmp al,39 { 57 }
jg labell3
mov cl,[esi+5F]
cmp cl,30 { 48 }
jl labell3
cmp cl,39 { 57 }
jg labell3
sub al,30 { 48 }
mov dl,0A { 10 }
imul dl
add al,cl
sub al,30 { 48 }
mov [edi+01],al
jmp labell4
labell3:
xor al,al
mov [edi+01],al
jmp labell4
labell1:
mov byte ptr [edi-01],00 { 0 }
mov byte ptr [edi],00 { 0 }
mov byte ptr [edi+01],00 { 0 }
labell4:
add ebp,04 { 4 }
add edi,03 { 3 }
sub dword ptr [esp+14],01 { 1 }
jne labell5
mov eax,[ebx+000001DC]
jmp labell6
mov ecx,[eax+46]
mov [esp+76],ecx
mov dx,[eax+4A]
lea eax,[esp+7C]
push eax
mov [esp+7E],dx
call ps_game.exe+84F50
lea eax,[esp+7C]
lea edx,[eax+01]
nop
labell7:
mov cl,[eax]
inc eax
test cl,cl
jne labell7
sub eax,edx
add eax,49 { 73 }
lea ecx,[esp+38]
mov ebx,[ebx+17F4]
lea ebx,[ebx+18]
jmp labell10
labell6:
lea edx,[esp+76]
push edx
call ps_game.exe+84F50
lea eax,[esp+76]
lea edx,[eax+01]
labell9:
mov cl,[eax]
inc eax
test cl,cl
jne labell9
mov edx,ebx
mov edi,0
mov ebx,[esp+120]
mov esi,ebx
lea ebx,[ebx+18]
labell10:
mov ecx,[ebx]
cmp ecx,edx
je labell11
test ecx,ecx
je labell11
sub eax,edx
mov eax,50
push eax
lea eax,[esp+38]
push eax
movzx eax, byte ptr [ecx+0000012D]
cmp al,1
je odinaa
mov al,1
jmp asdaa
odinaa:
mov al,0
asdaa:
mov [esp+3C+8],al
call ps_game.exe+ED0E0 //send
labell11:
add edi,01 { 1 }
add ebx,08 { 8 }
cmp edi,[esi+10]
jl labell10
originalcode:
add esp,00000128 { 296 }
popad
mov eax,[ebx+10]

exit:
jmp returnhere

originalcode2:
pop edi
mov eax,[ebx+10]
jmp exit

"ps_game.exe"+4FB33:
jmp newmem
nop
nop
returnhere:

 
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+4FB33:
add dword ptr [ebx+10],-01
mov eax,[ebx+10]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>324</ID>
              <Description>"party enter"</Description>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
inc [ebp+10]
cmp byte ptr[ebx+160],(int)86//MapID
jne originalcode2
cmp [ebp+10],1
je originalcode2
mov eax,0

zanovo:
push eax
pushad
mov ebx,[eax*8+ebp+18]
mov ecx,[ebx+000000DC]
mov eax,00000303 { 771 }
mov [esp+34],ax
mov [esp+36],ecx
movzx eax,byte ptr [ebx+0000144C]
movzx ecx,byte ptr [ebx+0000012D]
sete dl
mov [esp+3A],dl
movzx edx,byte ptr [ebx+0000012E]
mov [esp+3B],al
movzx eax,byte ptr [ebx+00000131]
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
mov [esp+3D],dl
movzx edx,byte ptr [ebx+00000133]
mov [esp+3E],al
movzx eax,byte ptr [ebx+00000134]
mov [esp+3F],cl
movzx ecx,byte ptr [ebx+00000135]
push ebx
mov [esp+44],dl
mov [esp+45],al
mov [esp+46],cl
call ps_game.exe+9B120
movzx edx,byte ptr [ebx+0000012F]
mov ecx,[ebx+00000184]
mov [esp+43],al
mov eax,[ebx+00000148]
mov [esp+45],eax
mov eax,[ebx+0000018C]
mov [esp+44],dl
mov edx,[ebx+00000188]
mov [esp+69],eax
movzx eax,byte ptr [ebx+00000198]
mov [esp+61],ecx
mov ecx,[ebx+00000190]
mov [esp+65],edx
mov edx,[ebx+00000194]
mov [esp+75],al
mov [esp+6D],ecx
mov [esp+71],edx
mov byte ptr [esp+75],00 { 0 }
lea edi,[esp+4A]
lea ebp,[ebx+000001C0]
mov [esp+14],00000008 { 8 }
label5:
cmp dword ptr [ebp+00],00 { 0 }
je label1
mov esi,[ebp+00]
mov cl,[esi+40]
mov [edi-01],cl
mov dl,[esi+41]
lea eax,[esi+4C]
mov [edi],dl
lea edx,[eax+01]
lea esp,[esp+00]
label2:
mov cl,[eax]
inc eax
test cl,cl
jne label2
sub eax,edx
cmp eax,14 { 20 }
jne label3
mov al,[esi+5E]
cmp al,30 { 48 }
jl label3
cmp al,39 { 57 }
jg label3
mov cl,[esi+5F]
cmp cl,30 { 48 }
jl label3
cmp cl,39 { 57 }
jg label3
sub al,30 { 48 }
mov dl,0A { 10 }
imul dl
add al,cl
sub al,30 { 48 }
mov [edi+01],al
jmp label4
label3:
xor al,al
mov [edi+01],al
jmp label4
label1:
mov byte ptr [edi-01],00 { 0 }
mov byte ptr [edi],00 { 0 }
mov byte ptr [edi+01],00 { 0 }
label4:
add ebp,04 { 4 }
add edi,03 { 3 }
sub dword ptr [esp+14],01 { 1 }
jne label5
mov eax,[ebx+000001DC]
jmp label6
mov ecx,[eax+46]
mov [esp+76],ecx
mov dx,[eax+4A]
lea eax,[esp+7C]
push eax
mov [esp+7E],dx
call ps_game.exe+84F50
lea eax,[esp+7C]
lea edx,[eax+01]
nop
label7:
mov cl,[eax]
inc eax
test cl,cl
jne label7
sub eax,edx
add eax,49 { 73 }
lea ecx,[esp+38]
mov ebx,[ebx+17F4]
lea ebx,[ebx+18]
jmp label10
label6:
lea edx,[esp+76]
push edx
call ps_game.exe+84F50
lea eax,[esp+76]
lea edx,[eax+01]
label9:
mov cl,[eax]
inc eax
test cl,cl
jne label9
mov edi,0
mov ebx,[ebx+000017F4]
mov esi,ebx
lea ebx,[ebx+18]
label10:
mov ecx,[ebx]
test ecx,ecx
je label11
sub eax,edx
mov eax,50
push eax
lea eax,[esp+38]
push eax
movzx eax, byte ptr [ecx+0000012D]
mov [esp+3C+8],al
call ps_game.exe+ED0E0 //send
label11:
add edi,01 { 1 }
add ebx,08 { 8 }
cmp edi,[esi+10]
jl label10
popad
pop eax
inc eax
cmp eax,[ebp+10]
jl zanovo
originalcode:
mov edi,ebp

exit:
jmp returnhere

originalcode2:
mov edi,ebp
jmp exit

"ps_game.exe"+4F4D6:
jmp newmem
returnhere:



[DISABLE]
dealloc(newmem)
"ps_game.exe"+4F4D6:
inc [ebp+10]
mov edi,ebp
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>640</ID>
              <Description>"raid kick"</Description>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
add dword ptr [ebx+10],-01
push edi
mov edi,[esp+1C]
cmp byte ptr [edi+160],(int)86 //MapID
jne originalcode2
pop edi
mov eax,0
zanovo:
pushad
push eax
sub esp,128
mov ecx,[esp+128+20+1c]
mov ebx,[eax*8+esi+18]
cmp ecx,ebx
je sameCharacter
push ecx
mov ecx,[ebx+000000DC]
mov eax,00000303 { 771 }
mov [esp+34],ax
mov [esp+36],ecx
movzx eax,byte ptr [ebx+0000144C]
movzx ecx,byte ptr [ebx+0000012D]
sete dl
mov [esp+3A],dl
movzx edx,byte ptr [ebx+0000012E]
mov [esp+3B],al
movzx eax,byte ptr [ebx+00000131]
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
mov [esp+3D],dl
movzx edx,byte ptr [ebx+00000133]
mov [esp+3E],al
movzx eax,byte ptr [ebx+00000134]
mov [esp+3F],cl
movzx ecx,byte ptr [ebx+00000135]
push ebx
mov [esp+44],dl
mov [esp+45],al
mov [esp+46],cl
call ps_game.exe+9B120
movzx edx,byte ptr [ebx+0000012F]
mov ecx,[ebx+00000184]
mov [esp+43],al
mov eax,[ebx+00000148]
mov [esp+45],eax
mov eax,[ebx+0000018C]
mov [esp+44],dl
mov edx,[ebx+00000188]
mov [esp+69],eax
movzx eax,byte ptr [ebx+00000198]
mov [esp+61],ecx
mov ecx,[ebx+00000190]
mov [esp+65],edx
mov edx,[ebx+00000194]
mov [esp+75],al
mov [esp+6D],ecx
mov [esp+71],edx
mov byte ptr [esp+75],00 { 0 }
lea edi,[esp+4A]
lea ebp,[ebx+000001C0]
mov [esp+14],00000008 { 8 }
label5:
cmp dword ptr [ebp+00],00 { 0 }
je label1
mov esi,[ebp+00]
mov cl,[esi+40]
mov [edi-01],cl
mov dl,[esi+41]
lea eax,[esi+4C]
mov [edi],dl
lea edx,[eax+01]
lea esp,[esp+00]
label2:
mov cl,[eax]
inc eax
test cl,cl
jne label2
sub eax,edx
cmp eax,14 { 20 }
jne label3
mov al,[esi+5E]
cmp al,30 { 48 }
jl label3
cmp al,39 { 57 }
jg label3
mov cl,[esi+5F]
cmp cl,30 { 48 }
jl label3
cmp cl,39 { 57 }
jg label3
sub al,30 { 48 }
mov dl,0A { 10 }
imul dl
add al,cl
sub al,30 { 48 }
mov [edi+01],al
jmp label4
label3:
xor al,al
mov [edi+01],al
jmp label4
label1:
mov byte ptr [edi-01],00 { 0 }
mov byte ptr [edi],00 { 0 }
mov byte ptr [edi+01],00 { 0 }
label4:
add ebp,04 { 4 }
add edi,03 { 3 }
sub dword ptr [esp+14],01 { 1 }
jne label5
mov eax,[ebx+000001DC]
jmp label6
mov ecx,[eax+46]
mov [esp+76],ecx
mov dx,[eax+4A]
lea eax,[esp+7C]
push eax
mov [esp+7E],dx
call ps_game.exe+84F50
lea eax,[esp+7C]
lea edx,[eax+01]
nop
label7:
mov cl,[eax]
inc eax
test cl,cl
jne label7
sub eax,edx
add eax,49 { 73 }
lea ecx,[esp+38]
jmp label10
label6:
lea edx,[esp+76]
push edx
call ps_game.exe+84F50
lea eax,[esp+76]
lea edx,[eax+01]
label9:
mov cl,[eax]
inc eax
test cl,cl
jne label9
//mov edi,0
//mov esi,ebx
lea ebx,[ebx+18]
label10:
pop ecx
mov eax,50
push eax
lea eax,[esp+34]
push eax
movzx eax, byte ptr [ecx+0000012D]
cmp al,1
je odina
mov al,1
jmp asda
odina:
mov al,0
asda:
mov [esp+40],al
call ps_game.exe+ED0E0 //send
sameCharacter:
add esp,128
pop eax
popad
inc eax
cmp eax,[ebx+10]
jl zanovo

pushad
sub esp,128
mov ebx,[esp+128+20+18]
mov ecx,[ebx+000000DC]
mov eax,00000303 { 771 }
mov [esp+34],ax
mov [esp+36],ecx
movzx eax,byte ptr [ebx+0000144C]
movzx ecx,byte ptr [ebx+0000012D]
sete dl
mov [esp+3A],dl
movzx edx,byte ptr [ebx+0000012E]
mov [esp+3B],al
movzx eax,byte ptr [ebx+00000131]
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
mov [esp+3D],dl
movzx edx,byte ptr [ebx+00000133]
mov [esp+3E],al
movzx eax,byte ptr [ebx+00000134]
mov [esp+3F],cl
movzx ecx,byte ptr [ebx+00000135]
push ebx
mov [esp+44],dl
mov [esp+45],al
mov [esp+46],cl
call ps_game.exe+9B120
movzx edx,byte ptr [ebx+0000012F]
mov ecx,[ebx+00000184]
mov [esp+43],al
mov eax,[ebx+00000148]
mov [esp+45],eax
mov eax,[ebx+0000018C]
mov [esp+44],dl
mov edx,[ebx+00000188]
mov [esp+69],eax
movzx eax,byte ptr [ebx+00000198]
mov [esp+61],ecx
mov ecx,[ebx+00000190]
mov [esp+65],edx
mov edx,[ebx+00000194]
mov [esp+75],al
mov [esp+6D],ecx
mov [esp+71],edx
mov byte ptr [esp+75],00 { 0 }
lea edi,[esp+4A]
lea ebp,[ebx+000001C0]
mov [esp+14],00000008 { 8 }
labell5:
cmp dword ptr [ebp+00],00 { 0 }
je labell1
mov esi,[ebp+00]
mov cl,[esi+40]
mov [edi-01],cl
mov dl,[esi+41]
lea eax,[esi+4C]
mov [edi],dl
lea edx,[eax+01]
lea esp,[esp+00]
labell2:
mov cl,[eax]
inc eax
test cl,cl
jne labell2
sub eax,edx
cmp eax,14 { 20 }
jne labell3
mov al,[esi+5E]
cmp al,30 { 48 }
jl labell3
cmp al,39 { 57 }
jg labell3
mov cl,[esi+5F]
cmp cl,30 { 48 }
jl labell3
cmp cl,39 { 57 }
jg labell3
sub al,30 { 48 }
mov dl,0A { 10 }
imul dl
add al,cl
sub al,30 { 48 }
mov [edi+01],al
jmp labell4
labell3:
xor al,al
mov [edi+01],al
jmp labell4
labell1:
mov byte ptr [edi-01],00 { 0 }
mov byte ptr [edi],00 { 0 }
mov byte ptr [edi+01],00 { 0 }
labell4:
add ebp,04 { 4 }
add edi,03 { 3 }
sub dword ptr [esp+14],01 { 1 }
jne labell5
mov eax,[ebx+000001DC]
jmp labell6
mov ecx,[eax+46]
mov [esp+76],ecx
mov dx,[eax+4A]
lea eax,[esp+7C]
push eax
mov [esp+7E],dx
call ps_game.exe+84F50
lea eax,[esp+7C]
lea edx,[eax+01]
nop
labell7:
mov cl,[eax]
inc eax
test cl,cl
jne labell7
sub eax,edx
add eax,49 { 73 }
lea ecx,[esp+38]
jmp labell10
labell6:
lea edx,[esp+76]
push edx
call ps_game.exe+84F50
lea eax,[esp+76]
lea edx,[eax+01]
labell9:
mov cl,[eax]
inc eax
test cl,cl
jne labell9
mov edx,ebx
mov edi,0
mov ebx,[esp+0000012C]
mov esi,ebx
lea ebx,[ebx+18]
labell10:
mov ecx,[ebx]
cmp ecx,edx
je labell11
test ecx,ecx
je labell11
sub eax,edx
mov eax,50
push eax
lea eax,[esp+38]
push eax
movzx eax, byte ptr [ecx+0000012D]
cmp al,1
je odinaa
mov al,1
jmp asdaa
odinaa:
mov al,0
asdaa:
mov [esp+3C+8],al
call ps_game.exe+ED0E0 //send
labell11:
add edi,01 { 1 }
add ebx,08 { 8 }
cmp edi,[esi+10]
jl labell10
originalcode:
add esp,00000128 { 296 }
popad
mov ecx,[ebx+10]

exit:
jmp returnhere

originalcode2:
pop edi
mov ecx,[ebx+10]
jmp exit

"ps_game.exe"+4FEF3:
jmp newmem
nop
nop
returnhere:


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+4FEF3:
add dword ptr [ebx+10],-01
mov ecx,[ebx+10]
//Alt: db 83 43 10 FF 8B 4B 10
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>15</ID>
              <Description>"raid leave"</Description>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
add dword ptr [ebx+10],-01
push edi
mov edi,[esp+1C]
cmp byte ptr [edi+160],(int)86 //MapID
jne originalcode2
pop edi
mov eax,0
zanovo:
pushad
push eax
sub esp,128
mov ecx,[esp+128+20+1c]
mov ebx,[eax*8+esi+18]
cmp ecx,ebx
je sameCharacter
push ecx
mov ecx,[ebx+000000DC]
mov eax,00000303 { 771 }
mov [esp+34],ax
mov [esp+36],ecx
movzx eax,byte ptr [ebx+0000144C]
movzx ecx,byte ptr [ebx+0000012D]
sete dl
mov [esp+3A],dl
movzx edx,byte ptr [ebx+0000012E]
mov [esp+3B],al
movzx eax,byte ptr [ebx+00000131]
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
mov [esp+3D],dl
movzx edx,byte ptr [ebx+00000133]
mov [esp+3E],al
movzx eax,byte ptr [ebx+00000134]
mov [esp+3F],cl
movzx ecx,byte ptr [ebx+00000135]
push ebx
mov [esp+44],dl
mov [esp+45],al
mov [esp+46],cl
call ps_game.exe+9B120
movzx edx,byte ptr [ebx+0000012F]
mov ecx,[ebx+00000184]
mov [esp+43],al
mov eax,[ebx+00000148]
mov [esp+45],eax
mov eax,[ebx+0000018C]
mov [esp+44],dl
mov edx,[ebx+00000188]
mov [esp+69],eax
movzx eax,byte ptr [ebx+00000198]
mov [esp+61],ecx
mov ecx,[ebx+00000190]
mov [esp+65],edx
mov edx,[ebx+00000194]
mov [esp+75],al
mov [esp+6D],ecx
mov [esp+71],edx
mov byte ptr [esp+75],00 { 0 }
lea edi,[esp+4A]
lea ebp,[ebx+000001C0]
mov [esp+14],00000008 { 8 }
label5:
cmp dword ptr [ebp+00],00 { 0 }
je label1
mov esi,[ebp+00]
mov cl,[esi+40]
mov [edi-01],cl
mov dl,[esi+41]
lea eax,[esi+4C]
mov [edi],dl
lea edx,[eax+01]
lea esp,[esp+00]
label2:
mov cl,[eax]
inc eax
test cl,cl
jne label2
sub eax,edx
cmp eax,14 { 20 }
jne label3
mov al,[esi+5E]
cmp al,30 { 48 }
jl label3
cmp al,39 { 57 }
jg label3
mov cl,[esi+5F]
cmp cl,30 { 48 }
jl label3
cmp cl,39 { 57 }
jg label3
sub al,30 { 48 }
mov dl,0A { 10 }
imul dl
add al,cl
sub al,30 { 48 }
mov [edi+01],al
jmp label4
label3:
xor al,al
mov [edi+01],al
jmp label4
label1:
mov byte ptr [edi-01],00 { 0 }
mov byte ptr [edi],00 { 0 }
mov byte ptr [edi+01],00 { 0 }
label4:
add ebp,04 { 4 }
add edi,03 { 3 }
sub dword ptr [esp+14],01 { 1 }
jne label5
mov eax,[ebx+000001DC]
jmp label6
mov ecx,[eax+46]
mov [esp+76],ecx
mov dx,[eax+4A]
lea eax,[esp+7C]
push eax
mov [esp+7E],dx
call ps_game.exe+84F50
lea eax,[esp+7C]
lea edx,[eax+01]
nop
label7:
mov cl,[eax]
inc eax
test cl,cl
jne label7
sub eax,edx
add eax,49 { 73 }
lea ecx,[esp+38]
jmp label10
label6:
lea edx,[esp+76]
push edx
call ps_game.exe+84F50
lea eax,[esp+76]
lea edx,[eax+01]
label9:
mov cl,[eax]
inc eax
test cl,cl
jne label9
//mov edi,0
//mov esi,ebx
lea ebx,[ebx+18]
label10:
pop ecx
mov eax,50
push eax
lea eax,[esp+34]
push eax
movzx eax, byte ptr [ecx+0000012D]
cmp al,1
je odina
mov al,1
jmp asda
odina:
mov al,0
asda:
mov [esp+40],al
call ps_game.exe+ED0E0 //send
sameCharacter:
add esp,128
pop eax
popad
inc eax
cmp eax,[ebx+10]
jl zanovo

pushad
sub esp,128
mov ebx,[esp+128+20+18]
mov ecx,[ebx+000000DC]
mov eax,00000303 { 771 }
mov [esp+34],ax
mov [esp+36],ecx
movzx eax,byte ptr [ebx+0000144C]
movzx ecx,byte ptr [ebx+0000012D]
sete dl
mov [esp+3A],dl
movzx edx,byte ptr [ebx+0000012E]
mov [esp+3B],al
movzx eax,byte ptr [ebx+00000131]
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
mov [esp+3D],dl
movzx edx,byte ptr [ebx+00000133]
mov [esp+3E],al
movzx eax,byte ptr [ebx+00000134]
mov [esp+3F],cl
movzx ecx,byte ptr [ebx+00000135]
push ebx
mov [esp+44],dl
mov [esp+45],al
mov [esp+46],cl
call ps_game.exe+9B120
movzx edx,byte ptr [ebx+0000012F]
mov ecx,[ebx+00000184]
mov [esp+43],al
mov eax,[ebx+00000148]
mov [esp+45],eax
mov eax,[ebx+0000018C]
mov [esp+44],dl
mov edx,[ebx+00000188]
mov [esp+69],eax
movzx eax,byte ptr [ebx+00000198]
mov [esp+61],ecx
mov ecx,[ebx+00000190]
mov [esp+65],edx
mov edx,[ebx+00000194]
mov [esp+75],al
mov [esp+6D],ecx
mov [esp+71],edx
mov byte ptr [esp+75],00 { 0 }
lea edi,[esp+4A]
lea ebp,[ebx+000001C0]
mov [esp+14],00000008 { 8 }
labell5:
cmp dword ptr [ebp+00],00 { 0 }
je labell1
mov esi,[ebp+00]
mov cl,[esi+40]
mov [edi-01],cl
mov dl,[esi+41]
lea eax,[esi+4C]
mov [edi],dl
lea edx,[eax+01]
lea esp,[esp+00]
labell2:
mov cl,[eax]
inc eax
test cl,cl
jne labell2
sub eax,edx
cmp eax,14 { 20 }
jne labell3
mov al,[esi+5E]
cmp al,30 { 48 }
jl labell3
cmp al,39 { 57 }
jg labell3
mov cl,[esi+5F]
cmp cl,30 { 48 }
jl labell3
cmp cl,39 { 57 }
jg labell3
sub al,30 { 48 }
mov dl,0A { 10 }
imul dl
add al,cl
sub al,30 { 48 }
mov [edi+01],al
jmp labell4
labell3:
xor al,al
mov [edi+01],al
jmp labell4
labell1:
mov byte ptr [edi-01],00 { 0 }
mov byte ptr [edi],00 { 0 }
mov byte ptr [edi+01],00 { 0 }
labell4:
add ebp,04 { 4 }
add edi,03 { 3 }
sub dword ptr [esp+14],01 { 1 }
jne labell5
mov eax,[ebx+000001DC]
jmp labell6
mov ecx,[eax+46]
mov [esp+76],ecx
mov dx,[eax+4A]
lea eax,[esp+7C]
push eax
mov [esp+7E],dx
call ps_game.exe+84F50
lea eax,[esp+7C]
lea edx,[eax+01]
nop
labell7:
mov cl,[eax]
inc eax
test cl,cl
jne labell7
sub eax,edx
add eax,49 { 73 }
lea ecx,[esp+38]
jmp labell10
labell6:
lea edx,[esp+76]
push edx
call ps_game.exe+84F50
lea eax,[esp+76]
lea edx,[eax+01]
labell9:
mov cl,[eax]
inc eax
test cl,cl
jne labell9
mov edx,ebx
mov edi,0
mov ebx,[esp+120]
mov esi,ebx
lea ebx,[ebx+18]
labell10:
mov ecx,[ebx]
cmp ecx,edx
je labell11
test ecx,ecx
je labell11
sub eax,edx
mov eax,50
push eax
lea eax,[esp+38]
push eax
movzx eax, byte ptr [ecx+0000012D]
cmp al,1
je odinaa
mov al,1
jmp asdaa
odinaa:
mov al,0
asdaa:
mov [esp+3C+8],al
call ps_game.exe+ED0E0 //send
labell11:
add edi,01 { 1 }
add ebx,08 { 8 }
cmp edi,[esi+10]
jl labell10
originalcode:
add esp,00000128 { 296 }
popad
mov ecx,[ebx+10]

exit:
jmp returnhere

originalcode2:
pop edi
mov ecx,[ebx+10]
jmp exit

"ps_game.exe"+4F745:
jmp newmem
nop
nop
returnhere:


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+4F745:
add dword ptr [ebx+10],-01
mov ecx,[ebx+10]
//Alt: db 83 43 10 FF 8B 4B 10
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>16</ID>
              <Description>"raid enter"</Description>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
inc [ebp+10]
cmp byte ptr[ebx+160],(int)86//MapID
jne originalcode2
cmp [ebp+10],1
je originalcode2
mov eax,0

zanovo:
push eax
pushad
mov ebx,[eax*8+ebp+18]
mov ecx,[ebx+000000DC]
mov eax,00000303 { 771 }
mov [esp+34],ax
mov [esp+36],ecx
movzx eax,byte ptr [ebx+0000144C]
movzx ecx,byte ptr [ebx+0000012D]
sete dl
mov [esp+3A],dl
movzx edx,byte ptr [ebx+0000012E]
mov [esp+3B],al
movzx eax,byte ptr [ebx+00000131]
mov [esp+3C],cl
movzx ecx,byte ptr [ebx+00000132]
mov [esp+3D],dl
movzx edx,byte ptr [ebx+00000133]
mov [esp+3E],al
movzx eax,byte ptr [ebx+00000134]
mov [esp+3F],cl
movzx ecx,byte ptr [ebx+00000135]
push ebx
mov [esp+44],dl
mov [esp+45],al
mov [esp+46],cl
call ps_game.exe+9B120
movzx edx,byte ptr [ebx+0000012F]
mov ecx,[ebx+00000184]
mov [esp+43],al
mov eax,[ebx+00000148]
mov [esp+45],eax
mov eax,[ebx+0000018C]
mov [esp+44],dl
mov edx,[ebx+00000188]
mov [esp+69],eax
movzx eax,byte ptr [ebx+00000198]
mov [esp+61],ecx
mov ecx,[ebx+00000190]
mov [esp+65],edx
mov edx,[ebx+00000194]
mov [esp+75],al
mov [esp+6D],ecx
mov [esp+71],edx
mov byte ptr [esp+75],00 { 0 }
lea edi,[esp+4A]
lea ebp,[ebx+000001C0]
mov [esp+14],00000008 { 8 }
label5:
cmp dword ptr [ebp+00],00 { 0 }
je label1
mov esi,[ebp+00]
mov cl,[esi+40]
mov [edi-01],cl
mov dl,[esi+41]
lea eax,[esi+4C]
mov [edi],dl
lea edx,[eax+01]
lea esp,[esp+00]
label2:
mov cl,[eax]
inc eax
test cl,cl
jne label2
sub eax,edx
cmp eax,14 { 20 }
jne label3
mov al,[esi+5E]
cmp al,30 { 48 }
jl label3
cmp al,39 { 57 }
jg label3
mov cl,[esi+5F]
cmp cl,30 { 48 }
jl label3
cmp cl,39 { 57 }
jg label3
sub al,30 { 48 }
mov dl,0A { 10 }
imul dl
add al,cl
sub al,30 { 48 }
mov [edi+01],al
jmp label4
label3:
xor al,al
mov [edi+01],al
jmp label4
label1:
mov byte ptr [edi-01],00 { 0 }
mov byte ptr [edi],00 { 0 }
mov byte ptr [edi+01],00 { 0 }
label4:
add ebp,04 { 4 }
add edi,03 { 3 }
sub dword ptr [esp+14],01 { 1 }
jne label5
mov eax,[ebx+000001DC]
jmp label6
mov ecx,[eax+46]
mov [esp+76],ecx
mov dx,[eax+4A]
lea eax,[esp+7C]
push eax
mov [esp+7E],dx
call ps_game.exe+84F50
lea eax,[esp+7C]
lea edx,[eax+01]
nop
label7:
mov cl,[eax]
inc eax
test cl,cl
jne label7
sub eax,edx
add eax,49 { 73 }
lea ecx,[esp+38]
jmp label10
label6:
lea edx,[esp+76]
push edx
call ps_game.exe+84F50
lea eax,[esp+76]
lea edx,[eax+01]
label9:
mov cl,[eax]
inc eax
test cl,cl
jne label9
mov edi,0
mov ebx,[ebx+000017F4]
mov esi,ebx
lea ebx,[ebx+18]
label10:
mov ecx,[ebx]
test ecx,ecx
je label11
sub eax,edx
mov eax,50
push eax
lea eax,[esp+38]
push eax
movzx eax, byte ptr [ecx+0000012D]
mov [esp+3C+8],al
call ps_game.exe+ED0E0 //send
label11:
add edi,01 { 1 }
add ebx,08 { 8 }
cmp edi,[esi+10]
jl label10
popad
pop eax
inc eax
cmp eax,[ebp+10]
jl zanovo
originalcode:
mov edi,ebp

exit:
jmp returnhere

originalcode2:
mov edi,ebp
jmp exit

"ps_game.exe"+4F169:
jmp newmem
returnhere:


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+4F169:
inc [ebp+10]
mov edi,ebp
//Alt: db FF 45 10 8B FD
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>325</ID>
              <Description>"FFA party (/party in raid leader)"</Description>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr [ebp+160],(int)86 //MapID
jne originalcode
jmp 00475F09
originalcode:
mov al,[ebx+0000012D]

exit:
jmp returnhere

"ps_game.exe"+75EEC:
jmp newmem
nop
returnhere:

 
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+75EEC:
mov al,[ebx+0000012D]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>326</ID>
              <Description>"FFA party (/party)"</Description>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr [ebp+160],(int)86//MapID
jne originalcode
jmp 00475514
originalcode:
mov cl,[edi+0000012D]

exit:
jmp returnhere

"ps_game.exe"+754F7:
jmp newmem
nop
returnhere:

 
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+754F7:
mov cl,[edi+0000012D]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>327</ID>
              <Description>"FFA party (/join)"</Description>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr [ebp+160],(int)86 //MapID
jne originalcode
cmp byte ptr [edi+160],(int)86 //MapID
je 004757D8
originalcode:
mov dl,[ebp+0000012D]

exit:
jmp returnhere

"ps_game.exe"+757BA:
jmp newmem
nop
returnhere:

 
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+757BA:
mov dl,[ebp+0000012D]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>328</ID>
              <Description>"FFA party (search)"</Description>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr [eax+160],(int)86 //MapID
jne originalcode
jmp 00484C77
originalcode:
mov cl,[eax+0000012D]

exit:
jmp returnhere

"ps_game.exe"+84C69:
jmp newmem
nop
returnhere:

 
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+84C69:
mov cl,[eax+0000012D]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>329</ID>
              <Description>"FFA attack"</Description>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr [eax+160],(int)86 //MapID
je mycode
jmp originalcode
mycode:
push eax
push ebx
mov ebx,[edx+000017F4]
cmp ebx,00
je NotInParty
mov eax,[eax+000017F4]
cmp eax,00
je NotInParty
cmp eax,ebx
jne NotInParty
pop ebx
pop eax
jmp 00457E39 //can not be attacked
NotInParty:
pop ebx
pop eax
jmp 00457E35 //can be attacked
originalcode:
mov dl,[edx+0000012D]

exit:
jmp returnhere

"ps_game.exe"+57E27:
jmp newmem
nop
returnhere:

 
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+57E27:
mov dl,[edx+0000012D]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>11</ID>
              <Description>"FFA Items"</Description>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr [ebp+160],(int)86 //MapID
je mycode
jmp originalcode
mycode:
push eax
push ebx
mov eax,[eax+000017F4]
cmp eax,00
je NotInParty
mov ebx,[ebp+000017F4]
cmp ebx,00
je NotInParty
cmp eax,ebx
jne NotInParty
pop ebx
pop eax
jmp 00473A87
NotInParty:
pop ebx
pop eax
jmp 0047468A
originalcode:
mov dl,[ebp+0000012D]

exit:
jmp returnhere

"ps_game.exe"+73A75:
jmp newmem
nop
returnhere:

 
 
[DISABLE]
"ps_game.exe"+73A75:
mov dl,[ebp+0000012D]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>330</ID>
              <Description>"FFA Skills"</Description>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr[esi+160],(int)86//MapID
je mycode
jmp originalcode
mycode:
push eax
push ebx
mov eax,[esi+000017F4]
cmp eax,00
je NotInParty
mov ebx,[edx+000017F4]
cmp ebx,00
je NotInParty
cmp eax,ebx
jne NotInParty
pop ebx
pop eax
jmp 00457F41 //SameParty
NotInParty:
pop ebx
pop eax
jmp 00457F01
originalcode:
mov al,[esi+0000012D]

exit:
jmp returnhere

"ps_game.exe"+57F33:
jmp newmem
nop
returnhere:

 
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+57F33:
mov al,[esi+0000012D]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>331</ID>
              <Description>"Leave from party if TP to map or from map"</Description>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr[esi+160],(int)86//mapid
je leaveFromParty
cmp ax,(int)0//mapid
je leaveFromParty
jmp originalcode
leaveFromParty:
cmp [esi+000017F4],00
je originalcode
pushad
mov ecx,[esi+000017F4]
mov eax,esi
call ps_game.exe+4F5F0
popad
originalcode:
mov [esi+00000160],ax

exit:
jmp returnhere

"ps_game.exe"+148E0:
jmp newmem
nop
nop
returnhere:

 
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+148E0:
mov [esi+00000160],ax
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>743</ID>
      <Description>"Capital Recall Rune"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]

// Capital Spawn Points

// Light
0056E608:
dd #35 // MapID

dd (float)0.0 // X
dd (float)0.0 // Y
dd (float)0.0 // Z

// Fury
0056E618:
dd #36 // MapID

dd (float)0.0 // X
dd (float)0.0 // Y
dd (float)0.0 // Z

[DISABLE]

0056E608:
dd 00000023

dd 441277AE
dd 41D80000
dd 43607D71

0056E618:
dd 00000024

dd 44094666
dd 42280000
dd 43A2B70A

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>744</ID>
      <Description>"Auction House Recall Rune"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]

// Light Auction House Spawn Points

// Light
0056E628:
dd #42 // MapID

dd (float)1683 // X
dd (float)2.0 // Y
dd (float)694 // Z

// Fury
0056E638:
dd #42 // MapID

dd (float)1683 // X
dd (float)2.0 // Y
dd (float)694 // Z

[DISABLE]

0056E628:
dd 0000002A

dd 429D3852
dd 4175C28F
dd 41DF999A

0056E638:
dd 0000002A

dd 41BB1EB8
dd 4175C28F
dd 42D4CCCD
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>14</ID>
      <Description>"Arena Recall Rune"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]

// Arena Spawn Points

// Light
0056E648:
dd #40 // MapID

dd (float)0.0 // X
dd (float)0.0 // Y
dd (float)0.0 // Z

// Fury
0056E658:
dd #40 // MapID

dd (float)0.0 // X
dd (float)0.0 // Y
dd (float)0.0 // Z

[DISABLE]

0056E648:
dd 00000028

dd 43000000
dd 40600000
dd 42A40000

0056E658:
dd 00000028

dd 42680000
dd 46600000
dd 42A40000

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>23</ID>
      <Description>"Guild House Recall Rune"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]

// Guild House Spawn Points

// Light
0056E688:
dd #51 // MapID

dd (float)0.0 // X
dd (float)0.0 // Y
dd (float)0.0 // Z

// Fury
0056E698:
dd #52 // MapID

dd (float)0.0 // X
dd (float)0.0 // Y
dd (float)0.0 // Z

[DISABLE]

0056E688:
dd 00000033

dd 43F5BEB8
dd 42275C29
dd 43A3251F

0056E698:
dd 00000034

dd 43F12F5C
dd 42275C29
dd 43A0F47B

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>748</ID>
      <Description>"Automatic Drops / Recreation / DEX overwrite"</Description>
      <Options moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1" moAllowManualCollapseAndExpand="1"/>
      <LastState Value="" RealAddress="00000000"/>
      <GroupHeader>1</GroupHeader>
      <CheatEntries>
        <CheatEntry>
          <ID>136</ID>
          <Description>"trade exploit fix"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(exit)

newmem:
call ps_game.exe+ED0E0

push 04
lea eax,[esp+18]
push eax
mov ecx,ebx
mov byte ptr [esp+1C],0A
mov byte ptr [esp+1D],0A
mov byte ptr [esp+1E],01
mov byte ptr [esp+1F],00
call 004ED0E0
push 04
lea eax,[esp+18]
push eax
mov ecx,ebx
mov byte ptr [esp+1C],0A
mov byte ptr [esp+1D],0A
mov byte ptr [esp+1E],02
mov byte ptr [esp+1F],00
call 004ED0E0
push 04
lea eax,[esp+18]
push eax
mov ecx,esi
mov byte ptr [esp+1C],0A
mov byte ptr [esp+1D],0A
mov byte ptr [esp+1E],01
mov byte ptr [esp+1F],00
call 004ED0E0
push 04
lea eax,[esp+18]
push eax
mov ecx,esi
mov byte ptr [esp+1C],0A
mov byte ptr [esp+1D],0A
mov byte ptr [esp+1E],02
mov byte ptr [esp+1F],00
call 004ED0E0

exit:
jmp returnhere

"ps_game.exe"+7E007:
jmp newmem
returnhere:
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+7E007:
call ps_game.exe+ED0E0
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>749</ID>
          <Description>"DEX Override (Melee)"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(pop_originalcode)
label(originalcode)
label(success)

define(dex_per_percent,#12)
define(min_accuracy,#20)

// edi = attacker
// esi = target
newmem:
cmp byte ptr [edi+1385],1
je originalcode

push eax
push ecx
push edx
sub esp,10

mov eax, dword ptr [edi+1220]
mov ecx, dword ptr [esi+1220]

cmp eax,ecx
ja success

sub eax,ecx
mov dword ptr [esp],eax
mov dword ptr [esp+4],dex_per_percent
fild dword ptr [esp+4] // dex_per_percent
fild dword ptr [esp] // DEX difference
fabs
fdiv st(0), st(1)
fistp dword ptr [esp]
fistp dword ptr [esp+4]

mov esi,#100
sub esi, dword ptr [esp]

cmp esi,min_accuracy
jae pop_originalcode

mov esi,min_accuracy

pop_originalcode:
add esp,10
pop edx
pop ecx
pop eax

originalcode:
cmp esi,01
jmp returnhere

success:
mov esi,#100
jmp pop_originalcode

00463D4B:
jmp newmem
returnhere:

[DISABLE]
dealloc(newmem)

00463D4B:
mov esi,eax
cmp esi,01
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>750</ID>
          <Description>"DEX Override (Ranged)"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(pop_originalcode)
label(originalcode)
label(success)

define(dex_per_percent,#12)
define(min_accuracy,#20)

// edi = attacker
// esi = target
newmem:
cmp byte ptr [edi+1395],1
je originalcode

push eax
push ecx
push edx
sub esp,10

mov eax, dword ptr [edi+1220]
mov ecx, dword ptr [esi+1220]

cmp eax,ecx
ja success

sub eax,ecx
mov dword ptr [esp],eax
mov dword ptr [esp+4],dex_per_percent
fild dword ptr [esp+4] // dex_per_percent
fild dword ptr [esp] // DEX difference
fabs
fdiv st(0), st(1)
fistp dword ptr [esp]
fistp dword ptr [esp+4]

mov esi,#100
sub esi, dword ptr [esp]

cmp esi,min_accuracy
jae pop_originalcode

mov esi,min_accuracy

pop_originalcode:
add esp,10
pop edx
pop ecx
pop eax

originalcode:
cmp esi,01
jmp returnhere

success:
mov esi,#100
jmp pop_originalcode

00463C9D:
jmp newmem
returnhere:

[DISABLE]
dealloc(newmem)

00463C9D:
mov esi,eax
cmp esi,01
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>751</ID>
          <Description>"Leader can't activate Leader Loot in MM"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,1024)
label(returnhere)
label(originalcode)
label(exit)

define(stack_alloc,100)

// 4 bytes - global random drop count
// 4 bytes - x10,000 account random drop count
//alloc(player_random_drop_order,40004)
//define(accounts,#10000)

// ebp = raid
newmem:
cmp dword ptr [esp+18],0 // Killer
je originalcode

push ebx
sub esp,stack_alloc

mov esi,esp // store the stack pointer

// clear the memory
push stack_alloc
push 0
push esi
call msvcrt.memset
add esp,C

lea eax, dword ptr [ebp+118]
mov dword ptr [esi+stack_alloc-4],eax
push eax
call dword ptr [005540DC] // ntdll.RtlEnterCriticalSection

mov ecx, dword ptr [esi+stack_alloc+C] // mob
xor ebx,ebx

random_next:
mov edx, dword ptr [ebp+ebx*8+18]

cmp edx, dword ptr [esi+stack_alloc+1C]
je random_ok // skip all further checks for killer

push edx
push ecx
call func_is_player_within_range
test eax,eax
je random_next_check

random_ok:
mov eax, dword ptr [esi+stack_alloc-8]
mov dword ptr [esi+eax*4],edx
inc dword ptr [esi+stack_alloc-8]

random_next_check:
inc ebx
cmp ebx, dword ptr [ebp+10]
jb random_next

call msvcrt.rand
cdq
idiv dword ptr [esi+stack_alloc-8]

mov edx, dword ptr [esi+edx*4]

push ebp
push edx
call func_get_player_index_in_party

mov edx,eax // index of player in party

mov eax, dword ptr [esi+stack_alloc-4]
push eax
call dword ptr [005540D4] // ntdll.RtlLeaveCriticalSection

exit:
add esp,stack_alloc
pop ebx
jmp returnhere

originalcode:
call 0051BD66
cdq
idiv dword ptr [ebp+10]
jmp returnhere

// push player
// push mob
// call func_is_player_within_range
func_is_player_within_range:
push ecx
push edx
push ebx
sub esp,4

xor eax,eax // clearing the return value (false)

mov ecx, dword ptr [esp+14] // mob
mov edx, dword ptr [esp+18] // player

// comparing zone pointers
mov ebx, dword ptr [ecx+8C]
cmp ebx, dword ptr [edx+E0]
jne func_is_player_within_range_exit

 // load mob.X
fld dword ptr [ecx+7C]
// subtract player.X from it
fsub dword ptr [edx+D0]
// get the absolute value
fabs
 // square it
fmul st(0),st(0)
// store result in the stack and pop floating point register
fstp dword ptr [esp]

// load mob.Z
fld dword ptr [ecx+84]
// subtract player.Z from it
fsub dword ptr [edx+D8]
// get the absolute value
fabs
// square it
fmul st(0),st(0)
// add the value previously stored in stack to it
fadd dword ptr [esp]

// square root
fsqrt
// store result in the stack and pop floating point register
fstp dword ptr [esp]

cmp dword ptr [esp],(float)100.000 // max range
ja func_is_player_within_range_exit

inc eax // set return value to true
func_is_player_within_range_exit:
add esp,4
pop ebx
pop edx
pop ecx
ret 8

// push party
// push player
// call func_get_player_index_in_party
func_get_player_index_in_party:
push ecx
push edx
push ebx

mov ecx, dword ptr [esp+10] // player
mov edx, dword ptr [esp+14] // party

mov eax, dword ptr [edx+10] // party member count

func_get_player_index_in_party_next:
dec eax

cmp dword ptr [edx+eax*8+18],ecx
je func_get_player_index_in_party_exit

test eax,eax
jne func_get_player_index_in_party_next

func_get_player_index_in_party_exit:
pop ebx
pop edx
pop ecx
ret 8

//player_random_drop_order:
//dd CCCCCCCC

004BB266:
jmp newmem
nop
nop
nop
nop
returnhere:

[DISABLE]
dealloc(newmem)
//dealloc(player_random_drop_order)

004BB266:
call 0051BD66
cdq
idiv dword ptr [ebp+10]
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>235</ID>
          <Description>"fix oracle"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
cmp edi,5
JE 0049B438

originalcode:
jmp dword ptr [edi*4+0049B980]

exit:
jmp returnhere

"ps_game.exe"+9B3DA:
jmp newmem
nop
nop
returnhere:


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+9B3DA:
jmp dword ptr [edi*4+0049B980]
//Alt: db FF 24 BD 80 B9 49 00
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>4</ID>
          <Description>"fix oracle stat reset"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
movzx eax,byte ptr [edi+00000134]


originalcode:
jmp dword ptr [eax*4+0048FB84]

exit:
jmp returnhere

"ps_game.exe"+8F77C:
jmp newmem
nop
nop
returnhere:


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+8F77C:
jmp dword ptr [eax*4+0048FB84]
//Alt: db FF 24 85 84 FB 48 00
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>629</ID>
          <Description>"Lv1 Resurrects UM"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>//lv1 resurrects um toons by Bowie 03/2020
[ENABLE]
0045A610:
jmp ps_game.exe+5A61C

[DISABLE]
0045A610:
jne ps_game.exe+5A61C
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>1</ID>
          <Description>"Endless Potions"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(return)
label(remove)
label(exit)

newmem: //items that will be decremented
mov edx,[ebx+30]
cmp [edx],#100000 //all AP items
jg remove
cmp [edx],#25224 //fortune bags 224-228
je remove
cmp [edx],#25225
je remove
cmp [edx],#25226
je remove
cmp [edx],#25227
je remove
cmp [edx],#25228
je remove
cmp byte ptr [ebx+40],#27 //all quest items 27-29
je remove
cmp byte ptr [ebx+40],#28
je remove
cmp byte ptr [ebx+40],#29
je remove
cmp byte ptr [ebx+40],#44 //i wouldn't remove this
je remove
mov ecx,[ebx+30] //items that won't be decremented
cmp [ecx],0 //all other items will be infinite if 0
jne return //avoid decrementing ecx items

remove: //decrement edx items
dec [ebx+42]

exit:
jmp return

00472ACD:
jmp newmem
return:

[DISABLE]
dealloc(newmem)
00472ACD:
dec al
mov [ebx+42],al
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>428</ID>
          <Description>"Stack Fortune Bag Drops"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,1024)
label(returnhere)
label(originalcode)
label(exit)

// esp+4 = bag
// esp+8 = player
// esp+14 = slot
newmem:
cmp dword ptr [esp+15C],00473BD4 // return point for fortune bag opening
jne originalcode
cmp eax,1
jne originalcode
push eax
push ecx
push edx
push ebx
push esi
push edi

// esp+1C = bag
// esp+20 = player
// esp+2C = slot

mov ebx, dword ptr [esp+1C]
imul ebx,ebx,#24
add ebx, dword ptr [esp+2C]
imul ebx,ebx,#4
add ebx,1C0
mov edi, dword ptr [esp+20]
add ebx,edi
mov esi, dword ptr [ebx] // get item pointer

push esi // item pointer
push edi // player pointer
call func_get_bag_slot_next_identical_item

test eax,eax
je exit

mov edx, dword ptr [esp+2C]
mov ebx, dword ptr [esp+1C]

movzx ecx,ah
push ecx
movzx ecx,al
push ecx

push edx
push ebx

mov ecx,edi
call 004685A0

exit:
pop edi
pop esi
pop ebx
pop edx
pop ecx
pop eax

originalcode:
add esp,15C
jmp returnhere

// push itemPointer
// push playerPointer
// call func_get_bag_slot_next_identical_item
// success: al = bag, ah = slot
// failure: eax = 0
func_get_bag_slot_next_identical_item:
push ecx
push edx
push ebx
push esi
push edi

mov esi, dword ptr [esp+1C] // item pointer
mov edi, dword ptr [esp+18] // player pointer


cmp esi,400000
jl nort
cmp [esi+30],400000
jl nort
cmp [edi],(int)5708456
jne nort
mov eax,[esi+30]
cmp [eax],(int)1001
jl nort
cmp [eax],(int)150255
jg nort



mov al,#1
mov ah,#0
add edi,220

func_get_bag_slot_next_identical_item_next:
mov ecx, dword ptr [edi]

// check if item exists
test ecx,ecx
je func_get_bag_slot_next_identical_item_next_check_slot

// check if same item
cmp ecx,esi
je func_get_bag_slot_next_identical_item_next_check_slot

// check if same item def
mov edx, dword ptr [ecx+30]
cmp edx, dword ptr [esi+30]
jne func_get_bag_slot_next_identical_item_next_check_slot

// check if max count isn't reached
movzx ebx, byte ptr [edx+4B]
cmp bl, byte ptr [ecx+42]
ja func_get_bag_slot_next_identical_item_exit

func_get_bag_slot_next_identical_item_next_check_slot:
add edi,4
inc ah
cmp ah,#24
jb func_get_bag_slot_next_identical_item_next

func_get_bag_slot_next_identical_item_next_check_bag:
xor ah,ah
inc al
cmp al,#5
jbe func_get_bag_slot_next_identical_item_next

nort:
xor eax,eax

func_get_bag_slot_next_identical_item_exit:
pop edi
pop esi
pop ebx
pop edx
pop ecx
ret 8

0046C27E:
jmp newmem
nop
returnhere:

[DISABLE]
dealloc(newmem)

0046C27E:
add esp,15C
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>755</ID>
          <Description>"Confirm Button Fix"</Description>
          <LastState Value="" RealAddress="00000000"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>81</ID>
              <Description>"Confirm Button Fix 1"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,512)
label(returnhere)
label(originalcode)
label(confirm)
label(confirm_set_1)
label(confirm_set_0)

newmem:
cmp ecx,0A0A
je confirm

originalcode:
mov edx,edi
mov ecx,ebx
call 0047D940
jmp returnhere

// ebx = player
// edi = packet
// player+15C4 = Trading With
// player+15E4 = Trade OK Button State
// player+6310 = Trade Confirm Button State
confirm:
cmp dword ptr [ebx+15C4],0
je returnhere

cmp byte ptr [edi+2],1
je confirm_set_1
cmp byte ptr [edi+2],0
je confirm_set_0
jmp returnhere

confirm_set_1:
sub esp,4

mov ecx,ebx

mov dword ptr [ecx+6310],1

mov word ptr [esp],0A0A
mov byte ptr [esp+2],1
mov byte ptr [esp+3],1

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Confirm1 On

mov ecx, dword ptr [ebx+15C4]

mov word ptr [esp],0A0A
mov byte ptr [esp+2],2
mov byte ptr [esp+3],1

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Confirm1 On

add esp,4

jmp returnhere

confirm_set_0:
sub esp,4

mov ecx,ebx
mov dword ptr [ecx+6310],0

mov word ptr [esp],0A0A
mov byte ptr [esp+2],1
mov byte ptr [esp+3],0

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Confirm1 Off

mov ecx,ebx
mov byte ptr [esp+2],2
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Confirm2 Off

mov ecx,ebx

mov byte ptr [ecx+15E4],0

mov word ptr [esp],0A05
mov byte ptr [esp+2],3
mov byte ptr [esp+3],1

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Cancel OK

mov ecx, dword ptr [ebx+15C4]

mov dword ptr [ecx+6310],0

mov word ptr [esp],0A0A
mov byte ptr [esp+2],1
mov byte ptr [esp+3],0

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Confirm1 Off

mov ecx, dword ptr [ebx+15C4]
mov byte ptr [esp+2],2
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Confirm2 Off

mov ecx, dword ptr [ebx+15C4]

mov byte ptr [ecx+15E4],0

mov word ptr [esp],0A05
mov byte ptr [esp+2],3
mov byte ptr [esp+3],1
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Cancel OK

add esp,4

jmp returnhere

00474E07:
jmp newmem
nop
nop
nop
nop
returnhere:

[DISABLE]
dealloc(newmem)

00474E07:
mov edx,edi
mov ecx,ebx
call 0047D940
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>200</ID>
              <Description>"Confirm Button Fix 2"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,128)
label(returnhere)
label(originalcode)

newmem:
cmp [ecx+6310],al
jne 0047E263
cmp [esi+6310],al
jne 0047E263

originalcode:
cmp [ecx+000015E4],al
jne 0047E263
jmp returnhere

0047E253:
jmp newmem
nop
nop
nop
returnhere:

[DISABLE]
dealloc(newmem)

0047E253:
cmp [ecx+000015E4],al
jne 0047E263
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>82</ID>
              <Description>"Confirm Button Fix 3"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,512)
label(returnhere)
label(originalcode)

newmem:
mov dword ptr [ecx+6310],0
mov dword ptr [esi+6310],0

push ecx
push edx

sub esp,4

mov word ptr [esp],0A0A
mov byte ptr [esp+2],1
mov byte ptr [esp+3],0

mov edx,esp

push ecx

push 4
push edx
call 004ED0E0
// Send P1 Confirm1 Off

pop ecx

mov byte ptr [esp+2],2

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Confirm2 Off

mov ecx,esi
mov byte ptr [esp+2],1
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Confirm1 Off

mov ecx,esi
mov byte ptr [esp+2],2
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Confirm2 Off

add esp,4

pop edx
pop ecx

originalcode:
push 04
lea edx,[esp+04]

jmp returnhere

0047E26F:
jmp newmem
nop
returnhere:

[DISABLE]
dealloc(newmem)

0047E26F:
push 04
lea edx,[esp+04]
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>85</ID>
              <Description>"Confirm Button Fix 4"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,256)
label(returnhere)
label(originalcode)
label(remove_confirm_ok)

// player = ebx
// usable: eax, edx, ecx
newmem:
cmp dword ptr [ebx+6310],0
jne remove_confirm_ok
mov ecx, dword ptr [ebx+15C4]
cmp dword ptr [ecx+6310],0
je originalcode

remove_confirm_ok:
sub esp,4

mov ecx,ebx
mov dword ptr [ecx+6310],0

mov word ptr [esp],0A0A
mov byte ptr [esp+2],1
mov byte ptr [esp+3],0

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Confirm1 Off

mov ecx,ebx
mov byte ptr [esp+2],2
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Confirm2 Off

mov ecx,ebx

mov byte ptr [ecx+15E4],0

mov word ptr [esp],0A05
mov byte ptr [esp+2],3
mov byte ptr [esp+3],1

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Cancel OK

mov ecx, dword ptr [ebx+15C4]

mov dword ptr [ecx+6310],0

mov word ptr [esp],0A0A
mov byte ptr [esp+2],1
mov byte ptr [esp+3],0

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Confirm1 Off

mov ecx, dword ptr [ebx+15C4]
mov byte ptr [esp+2],2
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Confirm2 Off

mov ecx, dword ptr [ebx+15C4]

mov byte ptr [ecx+15E4],0

mov word ptr [esp],0A05
mov byte ptr [esp+2],3
mov byte ptr [esp+3],1
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Cancel OK

add esp,4

originalcode:
mov ecx,ebx
call 0047E250
jmp returnhere

0047DE08:
jmp newmem
returnhere:

[DISABLE]
dealloc(newmem)

0047DE08:
call 0047E250
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>86</ID>
              <Description>"Confirm Button Fix 5"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,256)
label(returnhere)
label(originalcode)
label(remove_confirm_ok)

// player = ebx
// usable: eax, edx, ecx
newmem:
cmp dword ptr [ebx+6310],0
jne remove_confirm_ok
mov ecx, dword ptr [ebx+15C4]
cmp dword ptr [ecx+6310],0
je originalcode

remove_confirm_ok:
sub esp,4

mov ecx,ebx
mov dword ptr [ecx+6310],0

mov word ptr [esp],0A0A
mov byte ptr [esp+2],1
mov byte ptr [esp+3],0

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Confirm1 Off

mov ecx,ebx
mov byte ptr [esp+2],2
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Confirm2 Off

mov ecx,ebx

mov byte ptr [ecx+15E4],0

mov word ptr [esp],0A05
mov byte ptr [esp+2],3
mov byte ptr [esp+3],1

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P1 Cancel OK

mov ecx, dword ptr [ebx+15C4]

mov dword ptr [ecx+6310],0

mov word ptr [esp],0A0A
mov byte ptr [esp+2],1
mov byte ptr [esp+3],0

mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Confirm1 Off

mov ecx, dword ptr [ebx+15C4]
mov byte ptr [esp+2],2
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Confirm2 Off

mov ecx, dword ptr [ebx+15C4]

mov byte ptr [ecx+15E4],0

mov word ptr [esp],0A05
mov byte ptr [esp+2],3
mov byte ptr [esp+3],1
mov edx,esp

push 4
push edx
call 004ED0E0
// Send P2 Cancel OK

add esp,4

originalcode:
mov ecx,ebx
call 0047E250
jmp returnhere

0047DFC0:
jmp newmem
returnhere:

[DISABLE]
dealloc(newmem)

0047DFC0:
call 0047E250
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>756</ID>
      <Description>"Prevent SQL Injection"</Description>
      <Options moHideChildren="1" moManualExpandCollapse="1" moActivateChildrenAsWell="1" moAllowManualCollapseAndExpand="1"/>
      <LastState Value="" RealAddress="00000000"/>
      <GroupHeader>1</GroupHeader>
      <CheatEntries>
        <CheatEntry>
          <ID>757</ID>
          <Description>"fix sql injection gm commands"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(exit)

alloc(check_characters,512)
//label(check_characters)
label(escape)
registersymbol(check_characters)

newmem:
call check_characters
mov [edx+eax],cl
inc eax
test cl,cl

exit:
jmp returnhere

check_characters:
cmp cl,27 // '
je escape
ret

escape:
mov cl,20 // space
ret

"ps_game.exe"+80A62:
jmp newmem
nop
returnhere:

[DISABLE]
dealloc(newmem)
unregistersymbol(check_characters)
dealloc(check_characters)
"ps_game.exe"+80A62:
mov [edx+eax],cl
inc eax
test cl,cl
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>632</ID>
          <Description>""NoticeWarning" (Credit: Cups)"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>// Disables the call to the database for /warning (fixes SQL injection via warning)
[ENABLE]
ps_game.exe+836C6:
jmp ps_game.exe+841B8

[DISABLE]
ps_game.exe+836C6:
mov ebx,[esp+18]
push edi
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>6</ID>
          <Description>""NoticeAdmin""</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,32)

newmem:
mov ebx,00571E2F
jmp 004833C8

00482E95:
jmp newmem
nop

[DISABLE]
dealloc(newmem)
00482E95:
push ebx
mov ebx,00571E2F
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>758</ID>
          <Description>""NoticeNormal""</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,32)

newmem:
mov ebx,00571E2F
jmp 004833C8

00482F96:
jmp newmem
nop

[DISABLE]
dealloc(newmem)
00482F96:
push ebx
mov ebx,00571E2F
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>10</ID>
          <Description>""NoticeTo""</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,32)

newmem:
mov ebx,[esp+20]
jmp 004833C8

004830AD:
jmp newmem

[DISABLE]
dealloc(newmem)
004830AD:
push ebx
mov ebx,[esp+20]
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>759</ID>
          <Description>""NoticeMap""</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,32)

newmem:
mov ebx,00571E2F
jmp 004833C8

004831A2:
jmp newmem
nop

[DISABLE]
dealloc(newmem)
004831A2:
push edi
mov ebx,00571E2F
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>760</ID>
          <Description>""NoticeCountry""</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,32)

newmem:
mov ebx,00571E2F
jmp 004833C8

004832AB:
jmp newmem
nop

[DISABLE]
dealloc(newmem)
004832AB:
push edi
mov ebx,00571E2F
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>13</ID>
          <Description>""NoticeAll""</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,32)

newmem:
mov ebx,00571E2F
jmp 004833C8

004833AA:
jmp newmem
nop

[DISABLE]
dealloc(newmem)
004833AA:
push edi
mov ebx,00571E2F
</AssemblerScript>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>22</ID>
      <Description>"Autre Script"</Description>
      <LastState Value="" RealAddress="00000000"/>
      <GroupHeader>1</GroupHeader>
      <CheatEntries>
        <CheatEntry>
          <ID>24</ID>
          <Description>"Disable viewing of buffs"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
/////////////////////////////script by -AMI-/////////////////////////////
alloc(newmem,2048)

newmem:

"ps_game.exe"+91752:
jmp 00491792
nop
nop
nop
nop
nop
"ps_game.exe"+56C95:
nop
"ps_game.exe"+56CA1:
nop
"ps_game.exe"+56CA6:
nop
nop
nop
nop
nop


[DISABLE]
dealloc(newmem)
"ps_game.exe"+91752:
push ebx
push esi
call ps_game.exe+56CF0

"ps_game.exe"+56C95:
push ecx
"ps_game.exe"+56CA1:
push edx
"ps_game.exe"+56CA6:
call 004ED0E0
//Alt: db 53 56 E8 97 55 FC FF
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>17</ID>
          <Description>"Union Summon Raid"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(ItemSummonRaid)
label(checkcountry)
label(failed)
label(exit)

newmem:
call ps_game.exe+4ECF0
//esi=target player,edi=source player
//check map
originalcode:
pushad
movzx eax,word ptr [esi+0x160]
movzx ebx,word ptr [edi+0x160]
cmp eax,(int)45
je checkcountry
cmp ebx,(int)45
je checkcountry

jmp ItemSummonRaid

//checkcountry and check if same map
checkcountry:
cmp eax,ebx        //if they are in the same map which we speicifys
je ItemSummonRaid

movzx eax,byte ptr [esi+0x12d]
movzx ebx,byte ptr [edi+0x12d]
cmp eax,ebx
jne failed

/*
push eax               //party table
push ecx               //leader id
mov eax,[edi+17f4]
mov ecx,[eax+0c]       //leader id
imul ecx,ecx,8
add  ecx,18
mov  ecx,[eax+ecx]   //leader address
cmp edi,ecx          //compare address check is leader
pop ecx
pop eax
je 0049e4ea        //if yes
*/

ItemSummonRaid:

mov eax,dword ptr ds:[edi+0x58FC]
mov ecx,dword ptr ds:[edi+0x5900]
lea eax,dword ptr ds:[eax+eax*2]     // eax=bag,ecx=slot
lea edx,dword ptr ds:[ecx+eax*8]
imul edx,edx,4
mov eax,dword ptr ds:[edi+edx+0x1C0]
mov eax,dword ptr ds:[eax+30]
cmp [eax],(int)100045                 //orginal item id
popad
jne 0049e4ea   //success addr
/*
mov eax,dword ptr ds:[eax+0x30]
cmp byte ptr ds:[eax+0x46],0x1F
*/



exit:
jmp returnhere

failed:
popad
jmp 0049E517



"ps_game.exe"+9E4E1:

jmp newmem

returnhere:

[DISABLE]

//code from here till the end of the code will be used to disable the cheat

dealloc(newmem)

"ps_game.exe"+9E4E1:

call ps_game.exe+4ECF0

//Alt: db E8 0A 08 FB FF
</AssemblerScript>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>761</ID>
      <Description>"Make sure to run after the restart"</Description>
      <Options moRecursiveSetValue="1" moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1" moAllowManualCollapseAndExpand="1"/>
      <LastState Value="" RealAddress="00000000"/>
      <GroupHeader>1</GroupHeader>
      <CheatEntries>
        <CheatEntry>
          <ID>601</ID>
          <Description>"Raid Kill Sharing"</Description>
          <LastState/>
          <Color>0000FF</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)
label(M1)
label(M2)
label(M3)
label(M4)
label(M5)
label(M6)
label(M7)
label(M8)
label(M9)

newmem:
call CustomFuncDeath
pushad
mov edi,esi
mov edx,[esi+000000E0]
xor ecx,ecx
mov cl,[esi+0000012D]
cmp ecx,01
je setzero
mov ecx,01
jmp gocall
setzero:
mov ecx,00
gocall:
push ecx
push edx
call ShareKill
popad
originalcode:

exit:
jmp 00465ACF

ShareKill:
sub esp,10 { 16 }
push ebx
push ebp
mov ebp,[esp+1C]
push esi
call dword ptr [ps_game.exe+1540D0] { -&gt;kernel32.GetTickCount }
lea esi,[ebp+0000018C]
mov ebx,eax
push esi
add ebx,000003E8 { 1000 }
mov [esp+1C],esi
call dword ptr [ps_game.exe+1540DC] { -&gt;ntdll.RtlEnterCriticalSection }
mov ecx,[ebp+00000184]
mov eax,[ecx+04]
mov [ebp+00000188],eax
cmp eax,ecx
je M1
test eax,eax
je M1
M8:
mov eax,[eax+08]
test eax,eax
je M2
lea esi,[eax-000000D0]
jmp M3
M2:
xor esi,esi
M3:
// cmp byte ptr [esi+00005808],0A { if ( *(_BYTE *)(v8 + 22376) &gt; 0xAu )}
//ja M4
//mov eax,[ebp+00000188] {  v6 = (CObjectLink *)CZone-&gt;m_listUser.cursor-&gt;next;}
//mov eax,[eax+04]
//jmp M6

M4:
cmp edi,esi
jne M5
mov ecx,[ebp+00000188]
mov eax,[ecx+04]
jmp M6
M5:
mov dl,[esp+24]
cmp [esi+0000012D],dl { if ( *(_BYTE *)(v8 + 301) == byCountry )}
jne M9
// NEW CODE HERE //
fld dword ptr [edi+000000D0]
push ecx
fsub dword ptr [esi+000000D0]
fstp dword ptr [esp+14]
fld dword ptr [edi+000000D8]
fsub dword ptr [esi+000000D8]
fstp dword ptr [esp+24]
fld dword ptr [esp+24]
fld dword ptr [esp+14]
fmul st(0),st(0)
fld st(1)
fmulp st(2),st(0)
faddp
fstp dword ptr [esp+24]
fld dword ptr [esp+24]
fstp dword ptr [esp]
call ps_game.exe+1B8A0
fcomp dword ptr [RangeFloat] { [100.00] }
add esp,04 { 00000004 }
fnstsw ax
sahf
//test ah,41 { 65 }
jae M9 { if ( v11 &gt; 10.0 )}
//Need check party
cmp [esi+000017F4],00
je M9
mov ecx,esi
push edi
call ps_game.exe+67CE0
//               //
M9:
mov edx,[ebp+00000188]
mov eax,[edx+04]
M6:
cmp eax,[ebp+00000184] { while ( v6 != CZone-&gt;m_listUser.head &amp;&amp; v6 );}
mov [ebp+00000188],eax
je M7
test eax,eax
jne M8
M7:
mov esi,[esp+18] { v4 = &amp;this-&gt;m_listUser.m_csList.m_cs;}
M1:
push esi
call dword ptr [ps_game.exe+1540D4] { -&gt;ntdll.RtlLeaveCriticalSection }
pop esi
pop ebp
pop ebx
add esp,10 { 16 }
ret 0008 { 00000008 }

RangeFloat:
dd 42C80000

CustomFuncDeath:
sub esp,14 { 20 }
mov eax,[esi+0000014C]
cmp eax,[ps_game.exe+1823AC] { [000F4240] }
jae FuncDeathM
mov edx,[esi+0000582C]
inc eax
mov [esi+0000014C],eax
mov ecx,0000060C { 1548 }
mov [esp+0F],eax
push 0B { 11 }
lea eax,[esp+0C]
mov [esp+0C],cx
mov ecx,[ps_game.exe+18796C] { [010A2628] }
push eax
mov [esp+12],edx
mov byte ptr [esp+16],01 { 1 }
call ps_game.exe+ED2D0
mov edx,[esi+0000014C]
mov ecx,0000020E { 526 }
push 07 { 7 }
lea eax,[esp+04]
mov [esp+04],cx
push eax
mov ecx,esi
mov byte ptr [esp+0A],01 { 1 }
mov [esp+0B],edx
call ps_game.exe+ED0E0
FuncDeathM:
add esp,14 { 20 }
ret

"ps_game.exe"+65AAD:
jmp newmem
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+65AAD:
call ps_game.exe+67EE0
//Alt: db E8 2E 24 00 00
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>554</ID>
          <Description>"kil x5"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
//place your code here

originalcode:
add [edi+00000148],1//KillBoost

exit:
jmp returnhere

"ps_game.exe"+67DC0:
jmp newmem
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+67DC0:
add [edi+00000148],ecx
//Alt: db 01 8F 48 01 00 00
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>614</ID>
          <Description>"helmet and cape drop fix"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>// Credits to Eric-Dutra16 and andr3y_you96
[ENABLE]
004BAFC8:
db 90 90 90 90 90 90 90 90 90

004BAFD1:
db 90 90 90 90 90 90 90 90 90

00473BBD:
db 90 90 90 90 90 90 90 90 90 90 90 90 90

[DISABLE]
004BAFC8:
cmp eax,10
je 004BB47A

004BAFD1:
cmp eax,18
je 004BB47A

00473BBD:
cmp dword ptr [eax+000000A0],18
je 0047468A
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>620</ID>
          <Description>"GM Enchantment +1"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>// Credits to Eric-Dutra16
[ENABLE]
alloc(newmem2,2048)
alloc(typeid,4)
label(returnhere2)
label(originalcode2)
label(exit2)

newmem2:
push eax
mov eax,[edx+41]
mov [typeid],eax
pop eax

originalcode2:
cmp byte ptr [edx+40],5F
jne ps_game.exe+6CAB7

exit2:
jmp returnhere2

"ps_game.exe"+6C9FE:
jmp newmem2
nop
nop
nop
nop
nop
returnhere2:

alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp byte ptr [typeid],(int)1// typeid perfect lapisia
je 0046CD83
cmp byte ptr [typeid],(int)9 // typeid perfect lapisia
je 0046CD83

originalcode:
cmp esi,eax
jae ps_game.exe+6D11C

exit:
jmp returnhere

"ps_game.exe"+6CD7B:
jmp newmem
nop
nop
nop
returnhere:

[DISABLE]
dealloc(typeid)
dealloc(newmem2)
"ps_game.exe"+6C9FE:
cmp byte ptr [edx+40],5F
jne ps_game.exe+6CAB7

dealloc(newmem)
"ps_game.exe"+6CD7B:
cmp esi,eax
jae ps_game.exe+6D11C
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>621</ID>
          <Description>"Arena Duel only"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
//place your code here

originalcode:
nop
nop
movzx eax,word ptr [ebp+00000160]

exit:
jmp returnhere

"ps_game.exe"+8BE8C:
jmp newmem
nop
nop
nop
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+8BE8C:
nop
nop
movzx eax,word ptr [ebp+00000160]
//Alt: db 90 90 0F B7 85 60 01 00 00
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>38</ID>
          <Description>"Between Parties"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1" moAllowManualCollapseAndExpand="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <Color>FF0000</Color>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>2</ID>
              <Description>"Cross-Party Barter 5.4"</Description>
              <LastState/>
              <Color>FF0000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
0047D9B6:
db 90 90 90 90 90 90



[DISABLE]
0047D9B6:
db 0F 85 1E 07 00 00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>762</ID>
              <Description>"GM Seeing Two Sides Chat 5.4"</Description>
              <LastState/>
              <Color>FF0013</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
cmp byte ptr [ecx+5808],0B
JL ps_game.exe+27944

originalcode:
cmp dl,[ecx+0000012D]

exit:
jmp returnhere

"ps_game.exe"+27938:
jmp newmem
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+27938:
cmp dl,[ecx+0000012D]
//Alt: db 3A 91 2D 01 00 00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>414</ID>
              <Description>"GM Can Attack 2 Side 5.4"</Description>
              <LastState/>
              <Color>FF0013</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(exit)

newmem:
cmp byte ptr [eax+5808],#10
jb 00457E35
cmp dl,[eax+0000012D]

exit:
jmp returnhere

"ps_game.exe"+57E2D:
jmp newmem
nop
returnhere:

[DISABLE]
dealloc(newmem)
"ps_game.exe"+57E2D:
cmp dl,[eax+0000012D]
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>9</ID>
              <Description>"GM Manual Raide Joinleyebilir"</Description>
              <LastState/>
              <Color>FF0000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>{
Author: Cups, 6th March 2018

Allows users with an admin status to join a manual raid
}
[ENABLE]
alloc(raid_autojoin_override, 128)
alloc(raid_autojoin_override2, 128)
define(allow_join, ps_game.exe+50507)
define(allow_join2, ps_game.exe+7580D)
label(return)
label(return2)

// Override the check for joining a manual raid
raid_autojoin_override2:

// If the user has an admin status
cmp [ebp+5808],#11
jl allow_join2

// If the user is not an admin, check if the raid is manual before allowing entry
cmp byte ptr [eax+00000115],00
jmp return2

// Override the check for joining a manual raid
raid_autojoin_override:

// If the user has an admin status
cmp [ebx+5808],#11
jl allow_join

// If the user is not an admin, check if the raid is manual before allowing entry
cmp byte ptr [eax+00000115],00
jmp return

// Checks if the raid is manual
ps_game.exe+757DE:
jmp raid_autojoin_override2
db 90 90
return2:

// Checks if the raid is manual
ps_game.exe+504FE:
jmp raid_autojoin_override
db 90 90
return:

[DISABLE]
dealloc(raid_autojoin_override)

ps_game.exe+504FE:
cmp byte ptr [eax+00000115],00

ps_game.exe+757DE:
cmp byte ptr [eax+00000115],00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>763</ID>
              <Description>"GM Can Join The Raid Of Both Sides"</Description>
              <LastState/>
              <Color>FF0000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>{
Author: Cups, 6th March 2018

Allows users with an admin status to join a raid regardless of it's faction
}
[ENABLE]
alloc(raid_faction_override, 128)
define(allow_join, ps_game.exe+757D8)
label(return)

// Override the check for faction when joining a raid
raid_faction_override:

// If the user has an admin status
cmp [ebp+5808],#11
jl allow_join

// If the user is not an admin, check if the raid is of the same faction
cmp dl,[edi+0000012D]
jmp return

// Checks if the user is in the same faction
ps_game.exe+757C0:
jmp raid_faction_override
db 90
return:

[DISABLE]
dealloc(raid_autojoin_override)

ps_game.exe+757C0:
cmp dl,[edi+0000012D]
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>19</ID>
              <Description>"Inter-Party Review 5.4"</Description>
              <LastState/>
              <Color>FF0000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
00477d49:
db 90 90 90 90 90 90



[DISABLE]
00477d49:
db 0F 85 F9 02 00 00
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>764</ID>
              <Description>"Whisper Between Parties 5.4"</Description>
              <LastState/>
              <Color>FF0000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
0047f629:
db 90 90 90 90 90 90

0047ff69:
db 90 90 90 90 90 90


[DISABLE]
0047f629:
db 0F 85 DF 00 00 00

0047ff69:
db 0F 85 DF 00 00 00
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>765</ID>
          <Description>"Fixed jump cut"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1" moAllowManualCollapseAndExpand="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <Color>008000</Color>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>153</ID>
              <Description>"1"</Description>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>//jump cut solution by Bowie and alvx9 06/2020
[ENABLE]
alloc(newmem,128)
label(return)
label(exit)
{packets for sit/stand/jump
06 05 01 00 00 00 01 - sit
06 05 01 00 00 00 00 - stand
06 05 01 00 00 00 02 - jump}
newmem: //avoids sending jump packets
mov cl,[ebp+02]
cmp cl,02 //if the lowest byte is 02
je 00479155 //don't send the packet
mov [esp+22],edx

exit:
jmp return

0047894D:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
0047894D:
mov cl,[ebp+02]
mov [esp+22],edx

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>604</ID>
              <Description>"Trade Bug Fix"</Description>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(exit)

newmem:
call ps_game.exe+ED0E0

push 04
lea eax,[esp+18]
push eax
mov ecx,ebx
mov byte ptr [esp+1C],0A
mov byte ptr [esp+1D],0A
mov byte ptr [esp+1E],01
mov byte ptr [esp+1F],00
call 004ED0E0
push 04
lea eax,[esp+18]
push eax
mov ecx,ebx
mov byte ptr [esp+1C],0A
mov byte ptr [esp+1D],0A
mov byte ptr [esp+1E],02
mov byte ptr [esp+1F],00
call 004ED0E0
push 04
lea eax,[esp+18]
push eax
mov ecx,esi
mov byte ptr [esp+1C],0A
mov byte ptr [esp+1D],0A
mov byte ptr [esp+1E],01
mov byte ptr [esp+1F],00
call 004ED0E0
push 04
lea eax,[esp+18]
push eax
mov ecx,esi
mov byte ptr [esp+1C],0A
mov byte ptr [esp+1D],0A
mov byte ptr [esp+1E],02
mov byte ptr [esp+1F],00
call 004ED0E0

exit:
jmp returnhere

"ps_game.exe"+7E007:
jmp newmem
returnhere:
 
[DISABLE]
dealloc(newmem)
"ps_game.exe"+7E007:
call ps_game.exe+ED0E0
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>8</ID>
              <Description>"Block Cape Enchant"</Description>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>//block cape enchantment by Bowie 03/2020
[ENABLE]
alloc(newmem,128)
label(return)
label(exit)

newmem:
cmp byte ptr [edi+40],18 //aol cape typeid 24
je 0046D5BE
cmp byte ptr [edi+40],27 //uof cape typeid 39
je 0046D5BE
cmp byte ptr [edi+42],01
jne 0046D5BE

exit:
jmp return

0046CC79:
jmp newmem
nop
nop
nop
nop
nop
return:

[DISABLE]
dealloc(newmem)
0046CC79:
cmp byte ptr [edi+42],01
jne 0046D5BE
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>135</ID>
              <Description>"Enchant Crash"</Description>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,128)
label(returnhere)
label(originalcode)

newmem:
cmp byte ptr [ebp+4],5
jg 00460524
cmp byte ptr [ebp+5],18
jnb 00460524

originalcode:
movzx edx,dl
lea ecx,[ecx+ecx*2]
jmp returnhere

0045FB7A:
jmp newmem
nop
returnhere:

[DISABLE]
dealloc(newmem)

0045FB7A:
movzx edx,dl
lea ecx,[ecx+ecx*2]
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>607</ID>
              <Description>"fix sql injection gm commands"</Description>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(exit)

alloc(check_characters,512)
//label(check_characters)
label(escape)
registersymbol(check_characters)

newmem:
call check_characters
mov [edx+eax],cl
inc eax
test cl,cl

exit:
jmp returnhere

check_characters:
cmp cl,27 // '
je escape
ret

escape:
mov cl,20 // space
ret

"ps_game.exe"+80A62:
jmp newmem
nop
returnhere:

[DISABLE]
dealloc(newmem)
unregistersymbol(check_characters)
dealloc(check_characters)
"ps_game.exe"+80A62:
mov [edx+eax],cl
inc eax
test cl,cl
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>116</ID>
              <Description>"Delay Runes After Skills"</Description>
              <Options moManualExpandCollapse="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1" moAllowManualCollapseAndExpand="1"/>
              <LastState Value="" RealAddress="00000000"/>
              <Color>008000</Color>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>117</ID>
                  <Description>"Arena Recall Rune"</Description>
                  <LastState/>
                  <Color>008000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//delays using arena recall runes after using skills
[ENABLE]
alloc(newmem,128)
label(return)
label(exit)

newmem:
cmp dword ptr [ebp+00001270],02
je 0047468A
cmp dword ptr [eax+000001A4],00

exit:
jmp return

00473FFD:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00473FFD:
cmp dword ptr [eax+000001A4],00
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>118</ID>
                  <Description>"Bootleggery Rune"</Description>
                  <LastState/>
                  <Color>008000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//delays using bootleggery runes after using skills
[ENABLE]
alloc(newmem,128)
label(return)
label(exit)

newmem:
cmp dword ptr [ebp+00001270],02
je 0047468A
cmp dword ptr [eax+000001A4],00

exit:
jmp return

00473ED7:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00473ED7:
cmp dword ptr [eax+000001A4],00
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>120</ID>
                  <Description>"Capital Recall Rune"</Description>
                  <LastState/>
                  <Color>008000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//delays using capital recall runes after using skills
[ENABLE]
alloc(newmem,128)
label(return)
label(exit)

newmem:
cmp dword ptr [ebp+00001270],02
je 0047468A
cmp dword ptr [eax+000001A4],00

exit:
jmp return

00473DB0:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00473DB0:
cmp dword ptr [eax+000001A4],00
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>122</ID>
                  <Description>"Guild House Rune"</Description>
                  <LastState/>
                  <Color>008000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//delays using guild house rune after using skills
[ENABLE]
alloc(newmem,128)
label(return)
label(exit)

newmem:
cmp dword ptr [ebp+00001270],02
je 004742B6
cmp dword ptr [eax+000001A4],06

exit:
jmp return

00474196:
jmp newmem
nop
nop
return:

[DISABLE]
dealloc(newmem)
00474196:
cmp dword ptr [eax+000001A4],06
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>606</ID>
                  <Description>"Delay Mount after Using Skills"</Description>
                  <LastState/>
                  <Color>008000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//delays using mounts after using skills
[ENABLE]
alloc(newmem,1024)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp dword ptr [ebp+00001270],02
je ps_game.exe+77999

originalcode:
cmp dword ptr [ebp+0000147C],03

exit:
jmp returnhere

"ps_game.exe"+77058:
jmp newmem
nop 2
returnhere:

[DISABLE]
dealloc(newmem)
"ps_game.exe"+77058:
cmp dword ptr [ebp+0000147C],03
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>605</ID>
                  <Description>"Delay Party Summon Rune after Using Skills"</Description>
                  <LastState/>
                  <Color>008000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>//delays using party summon rune after using skills
[ENABLE]
alloc(newmem,1024)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp dword ptr [ebp+00001270],02
je ps_game.exe+7468A

originalcode:
cmp dword ptr [ebp+000058B8],00

exit:
jmp returnhere

"ps_game.exe"+73400:
jmp newmem
nop 2
returnhere:

[DISABLE]
dealloc(newmem)
"ps_game.exe"+73400:
cmp dword ptr [ebp+000058B8],00
</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>429</ID>
          <Description>"Stack Drops Bag"</Description>
          <Options moHideChildren="1" moActivateChildrenAsWell="1" moDeactivateChildrenAsWell="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>768</ID>
              <Description>"Stack Fortune Bag Drops"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
alloc(newmem,1024)
label(returnhere)
label(originalcode)
label(exit)

// esp+4 = bag
// esp+8 = player
// esp+14 = slot
newmem:
cmp dword ptr [esp+15C],00473BD4 // return point for fortune bag opening
jne originalcode
cmp eax,1
jne originalcode
push eax
push ecx
push edx
push ebx
push esi
push edi

// esp+1C = bag
// esp+20 = player
// esp+2C = slot

mov ebx, dword ptr [esp+1C]
imul ebx,ebx,#24
add ebx, dword ptr [esp+2C]
imul ebx,ebx,#4
add ebx,1C0
mov edi, dword ptr [esp+20]
add ebx,edi
mov esi, dword ptr [ebx] // get item pointer

push esi // item pointer
push edi // player pointer
call func_get_bag_slot_next_identical_item

test eax,eax
je exit

mov edx, dword ptr [esp+2C]
mov ebx, dword ptr [esp+1C]

movzx ecx,ah
push ecx
movzx ecx,al
push ecx

push edx
push ebx

mov ecx,edi
call 004685A0

exit:
pop edi
pop esi
pop ebx
pop edx
pop ecx
pop eax

originalcode:
add esp,15C
jmp returnhere

// push itemPointer
// push playerPointer
// call func_get_bag_slot_next_identical_item
// success: al = bag, ah = slot
// failure: eax = 0
func_get_bag_slot_next_identical_item:
push ecx
push edx
push ebx
push esi
push edi

mov esi, dword ptr [esp+1C] // item pointer
mov edi, dword ptr [esp+18] // player pointer


cmp esi,400000
jl nort
cmp [esi+30],400000
jl nort
cmp [edi],(int)5708456
jne nort
mov eax,[esi+30]
cmp [eax],(int)1001
jl nort
cmp [eax],(int)150255
jg nort



mov al,#1
mov ah,#0
add edi,220

func_get_bag_slot_next_identical_item_next:
mov ecx, dword ptr [edi]

// check if item exists
test ecx,ecx
je func_get_bag_slot_next_identical_item_next_check_slot

// check if same item
cmp ecx,esi
je func_get_bag_slot_next_identical_item_next_check_slot

// check if same item def
mov edx, dword ptr [ecx+30]
cmp edx, dword ptr [esi+30]
jne func_get_bag_slot_next_identical_item_next_check_slot

// check if max count isn't reached
movzx ebx, byte ptr [edx+4B]
cmp bl, byte ptr [ecx+42]
ja func_get_bag_slot_next_identical_item_exit

func_get_bag_slot_next_identical_item_next_check_slot:
add edi,4
inc ah
cmp ah,#24
jb func_get_bag_slot_next_identical_item_next

func_get_bag_slot_next_identical_item_next_check_bag:
xor ah,ah
inc al
cmp al,#5
jbe func_get_bag_slot_next_identical_item_next

nort:
xor eax,eax

func_get_bag_slot_next_identical_item_exit:
pop edi
pop esi
pop ebx
pop edx
pop ecx
ret 8

0046C27E:
jmp newmem
nop
returnhere:

[DISABLE]
dealloc(newmem)

0046C27E:
add esp,15C
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>775</ID>
          <Description>"When the map changes, the appearance is fixed"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{
 Author: Cups, 8th May 2019

 Sends a player their appearance data when the enter the zone, to "fix"
 the bug that causes player appearances to become mismatched when they change zones
 after another player has used an Appearance Change scroll.
}
[ENABLE]
alloc(SendAppearance, 128)
label(Return)

// Create an appearance packet for our user
SendAppearance:
pushad
pushfd

// Remind the user of their own appearance
mov ecx,[edi+128]
mov edx,[edi+E0]

push edi
push edx
call ps_game.exe+268B0 // CZone::SendUserShape

popfd
popad

// Return control flow to the zone enter procedure
push ebx
push esi
mov esi,eax
xor eax,eax
jmp Return

ps_game.exe+55E70: // CUser::EnterZone
jmp SendAppearance
nop
Return:

[DISABLE]
dealloc(SendAppearance)

ps_game.exe+55E70:
push ebx
push esi
mov esi,eax
xor eax,eax
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>133</ID>
          <Description>"guard tek atma"</Description>
          <LastState/>
          <Color>0762F8</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem: //this is allocated memory, you have read,write,execute access
//place your code here

originalcode:
nop
nop
mov eax,edi
mov [edi+00001234],00000000

exit:
jmp returnhere

"ps_game.exe"+581A5:
jmp newmem
nop
nop
nop
nop
nop
nop
nop
nop
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+581A5:
nop
nop
mov eax,edi
mov [edi+00001234],00000000
//Alt: db 90 90 8B C7 C7 87 34 12 00 00 00 00 00 00
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>44</ID>
          <Description>"Max Recrune 1"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
registersymbol(rune)
registersymbol(gecici)
registersymbol(itemname)
registersymbol(counter16)
registersymbol(strpointer)
registersymbol(dexpointer)
registersymbol(recpointer)
registersymbol(intpointer)
registersymbol(wispointer)
registersymbol(lucpointer)
registersymbol(hppointer)
registersymbol(mppointer)
registersymbol(sppointer)
alloc(counter16,4)
alloc(gecici,4)
alloc(itemname,4)
alloc(strpointer,4)
alloc(dexpointer,4)
alloc(recpointer,4)
alloc(intpointer,4)
alloc(wispointer,4)
alloc(lucpointer,4)
alloc(hppointer,4)
alloc(mppointer,4)
alloc(sppointer,4)
alloc(rune,4)
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)
label(dexxx)
label(reccc)
label(inttt)
label(wisss)
label(luccc)
label(hppp)
label(mppp)
label(sppp)
label(removalrune)

newmem: //this is allocated memory, you have read,write,execute access
mov esi,[ebp+30]
mov esi,[esi]
mov [itemname],esi
mov esi,0
mov [strpointer],0
mov [dexpointer],0
mov [recpointer],0
mov [intpointer],0
mov [wispointer],0
mov [lucpointer],0
mov [hppointer],0
mov [sppointer],0
mov [mppointer],0
mov [counter16],0
cmp byte ptr [ebp+84],00
JE dexxx
add [counter16],1
mov [strpointer],1

dexxx:
cmp byte ptr [ebp+86],00
JE reccc
add [counter16],1
mov [dexpointer],1

reccc:
cmp byte ptr [ebp+88],00
JE inttt
add [counter16],1
mov [recpointer],1

inttt:
cmp byte ptr [ebp+8A],00
JE wisss
add [counter16],1
mov [intpointer],1

wisss:
cmp byte ptr [ebp+8C],00
JE luccc
add [counter16],1
mov [wispointer],1

luccc:
cmp byte ptr [ebp+8E],00
JE hppp
add [counter16],1
mov [lucpointer],1

hppp:
cmp byte ptr [ebp+90],00
JE mppp
add [counter16],1
mov [hppointer],1

mppp:
cmp byte ptr [ebp+92],00
JE sppp
add [counter16],1
mov [mppointer],1

sppp:
cmp byte ptr [ebp+94],00
JE originalcode
add [counter16],1
mov [sppointer],1


originalcode:
mov dl,[ecx]
mov [rune],dl

//Check
cmp [rune], (int)75 //StdRune
je removalrune
cmp [rune], (int)155 //StdRune
je removalrune
cmp [rune], (int)106 //Str
je CheckStrRune
CheckDexPointer:
cmp [rune], (int)107 //Dex
je CheckDexRune
CheckRecPointer:
cmp [rune], (int)108 // Rec
je CheckRecRune
CheckIntPointer:
cmp [rune], (int)109 // Int
je CheckIntRune
CheckWisPointer:
cmp [rune], (int)110 // Wis
je CheckWisRune
CheckLucPointer:
cmp [rune], (int)111 // Luc
je CheckLucRune
CheckHPPointer:
cmp [rune], (int)112 // HP
je CheckHPRune
CheckMPPointer:
cmp [rune], (int)113 // MP
je CheckMPRune
CheckSPPointer:
cmp [rune], (int)114 //SP
je CheckSPRune
SPPointerLast:
cmp [rune],(int)115
JE removalrune
cmp [rune],(int)116
JE removalrune
cmp [rune],(int)117
JE removalrune
cmp [rune],(int)118
JE removalrune
cmp [rune],(int)119
JE removalrune
cmp [rune],(int)120
JE removalrune
cmp [rune],(int)121
JE removalrune
cmp [rune],(int)122
JE removalrune
cmp [rune],(int)123
JE removalrune
// Perfect Runes
cmp [rune], (int)137 //Str
je CheckStrRunePerf
CheckDexPointerPerf:
cmp [rune], (int)138 //Dex
je CheckDexRunePerf
CheckRecPointerPerf:
cmp [rune], (int)139 // Rec
je CheckRecRunePerf
CheckIntPointerPerf:
cmp [rune], (int)140 // Int
je CheckIntRunePerf
CheckWisPointerPerf:
cmp [rune], (int)141 // Wis
je CheckWisRunePerf
CheckLucPointerPerf:
cmp [rune], (int)142 // Luc
je CheckLucRunePerf
CheckHPPointerPerf:
cmp [rune], (int)143 // HP
je CheckHPRunePerf
CheckMPPointerPerf:
cmp [rune], (int)144 // MP
je CheckMPRunePerf
CheckSPPointerPerf:
cmp [rune], (int)145 //SP
je CheckSPRunePerf
SPPointerLastPerf:
jmp ps_game.exe+6D901
removalrune:
cmp byte ptr [ecx+46],3E
jne ps_game.exe+6D901

exit:
jmp returnhere

CheckStrRune:
cmp [strpointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckDexPointer
CheckDexRune:
cmp [dexpointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckRecPointer
CheckRecRune:
cmp [recpointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckIntPointer
CheckIntRune:
cmp [intpointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckWisPointer
CheckWisRune:
cmp [wispointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckLucPointer
CheckLucRune:
cmp [lucpointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckHPPointer
CheckHPRune:
cmp [hppointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckMPPointer
CheckMPRune:
cmp [mppointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckSPPointer
CheckSPRune:
cmp [sppointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A] ||86 //////////////////////////////////////////////////
cmp [counter16],eax
pop eax
jl exit
jmp SPPointerLast
// PerfectRunes
CheckStrRunePerf:
cmp [strpointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckDexPointerPerf
CheckDexRunePerf:
cmp [dexpointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckRecPointerPerf
CheckRecRunePerf:
cmp [recpointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckIntPointerPerf
CheckIntRunePerf:
cmp [intpointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckWisPointerPerf
CheckWisRunePerf:
cmp [wispointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckLucPointerPerf
CheckLucRunePerf:
cmp [lucpointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckHPPointerPerf
CheckHPRunePerf:
cmp [hppointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckMPPointerPerf
CheckMPRunePerf:
cmp [mppointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckSPPointerPerf
CheckSPRunePerf:
cmp [sppointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp SPPointerLastPerf

"ps_game.exe"+6D6A9:
jmp newmem
nop
nop
nop
nop
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+6D6A9:
cmp byte ptr [ecx+46],3E
jne ps_game.exe+6D901
//Alt: db 80 79 46 3E 0F 85 4E 02 00 00
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>45</ID>
          <Description>"Max rec Rune 2"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
registersymbol(ecxpointer)
registersymbol(orangecount)
alloc(orangecount,4)
alloc(ecxpointer,4)
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)
label(equality)
label(reroll)
label(gmcheck)
label(end)
label(backend)
label(hpcheck)
label(mpcheck)
label(spcheck)
label(strreroll)
label(dexreroll)
label(recreroll)
label(intreroll)
label(wisreroll)
label(lucreroll)
label(hpreroll)
label(mpreroll)
label(spreroll)
label(strrerollr)
label(dexrerollr)
label(recrerollr)
label(intrerollr)
label(wisrerollr)
label(lucrerollr)
label(hprerollr)
label(mprerollr)
label(sprerollr)
label(strrerollequality)
label(dexrerollequality)
label(recrerollequality)
label(intrerollequality)
label(wisrerollequality)
label(lucrerollequality)
label(hprerollequality)
label(mprerollequality)
label(sprerollequality)
label(rerollremoval)
label(strrerollremoval)
label(dexrerollremoval)
label(recrerollremoval)
label(intrerollremoval)
label(wisrerollremoval)
label(lucrerollremoval)
label(hprerollremoval)
label(mprerollremoval)
label(sprerollremoval)
label(strrerollremovalr)
label(dexrerollremovalr)
label(recrerollremovalr)
label(intrerollremovalr)
label(wisrerollremovalr)
label(lucrerollremovalr)
label(hprerollremovalr)
label(mprerollremovalr)
label(sprerollremovalr)
label(strrerollremovalequality)
label(dexrerollremovalequality)
label(recrerollremovalequality)
label(intrerollremovalequality)
label(wisrerollremovalequality)
label(lucrerollremovalequality)
label(hprerollremovalequality)
label(mprerollremovalequality)
label(sprerollremovalequality)
label(removal)


newmem: //this is allocated memory, you have read,write,execute access
cmp [rune],4B // StdRune
je originalcode
cmp [rune],9B // StdRune
je originalcode
lea ebp,[esi+00000084]
mov [orangecount],eax
cmp [counter16],eax
JG originalcode
cmp [counter16],eax
JE equality
cmp [rune],(int)106
JE strreroll
cmp [rune],(int)107
JE dexreroll
cmp [rune],(int)108
JE recreroll
cmp [rune],(int)109
JE intreroll
cmp [rune],(int)110
JE wisreroll
cmp [rune],(int)111
JE lucreroll
cmp [rune],(int)112
JE hpcheck
cmp [rune],(int)113
JE mpcheck
cmp [rune],(int)114
JE spcheck
cmp [rune],(int)115
JE strrerollremoval
cmp [rune],(int)116
JE dexrerollremoval
cmp [rune],(int)117
JE recrerollremoval
cmp [rune],(int)118
JE intrerollremoval
cmp [rune],(int)119
JE wisrerollremoval
cmp [rune],(int)120
JE lucrerollremoval
cmp [rune],(int)121
JE hprerollremoval
cmp [rune],(int)122
JE mprerollremoval
cmp [rune],(int)123
JE sprerollremoval
//PerfectRunes
cmp [rune],(int)137
JE strreroll
cmp [rune],(int)138
JE dexreroll
cmp [rune],(int)139
JE recreroll
cmp [rune],(int)140
JE intreroll
cmp [rune],(int)141
JE wisreroll
cmp [rune],(int)142
JE lucreroll
cmp [rune],(int)143
JE hpcheck
cmp [rune],(int)144
JE mpcheck
cmp [rune],(int)145
JE spcheck
cmp [rune],(int)146

originalcode:
lea ebp,[esi+00000084]
jmp exit

equality:
cmp [rune],(int)106
JE strrerollequality
cmp [rune],(int)107
JE dexrerollequality
cmp [rune],(int)108
JE recrerollequality
cmp [rune],(int)109
JE intrerollequality
cmp [rune],(int)110
JE wisrerollequality
cmp [rune],(int)111
JE lucrerollequality
cmp [rune],(int)112
JE hprerollequality
cmp [rune],(int)113
JE mprerollequality
cmp [rune],(int)114
JE sprerollequality
cmp [rune],(int)115
JE strrerollremovalequality
cmp [rune],(int)116
JE dexrerollremovalequality
cmp [rune],(int)117
JE recrerollremovalequality
cmp [rune],(int)118
JE intrerollremovalequality
cmp [rune],(int)119
JE wisrerollremovalequality
cmp [rune],(int)120
JE lucrerollremovalequality
cmp [rune],(int)121
JE hprerollremovalequality
cmp [rune],(int)122
JE mprerollremovalequality
cmp [rune],(int)123
JE sprerollremovalequality
//PerfectRunes
cmp [rune],(int)137
JE strrerollequality
cmp [rune],(int)138
JE dexrerollequality
cmp [rune],(int)139
JE recrerollequality
cmp [rune],(int)140
JE intrerollequality
cmp [rune],(int)141
JE wisrerollequality
cmp [rune],(int)142
JE lucrerollequality
cmp [rune],(int)143
JE hprerollequality
cmp [rune],(int)144
JE mprerollequality
cmp [rune],(int)145
JE sprerollequality
cmp [rune],(int)146
jmp originalcode

hpcheck:
cmp dword ptr [itemname],(int)16001
JL 004D2C7B
cmp dword ptr [itemname],(int)22001
JL hpreroll
cmp dword ptr [itemname],(int)23255
JLE 004D2C7B
cmp dword ptr [itemname],(int)40001
JL hpreroll
cmp dword ptr [itemname],(int)69001
JL 004D2C7B
cmp dword ptr [itemname],(int)92255
JL hpreroll
jmp 004D2C7B

mpcheck:
cmp dword ptr [itemname],(int)16001
JL 004D2C7B
cmp dword ptr [itemname],(int)22001
JL mpreroll
cmp dword ptr [itemname],(int)23255
JLE 004D2C7B
cmp dword ptr [itemname],(int)40001
JL mpreroll
cmp dword ptr [itemname],(int)69001
JL 004D2C7B
cmp dword ptr [itemname],(int)92255
JL mpreroll
jmp 004D2C7B


spcheck:
cmp dword ptr [itemname],(int)16001
JL 004D2C7B
cmp dword ptr [itemname],(int)22001
JL spreroll
cmp dword ptr [itemname],(int)23255
JLE 004D2C7B
cmp dword ptr [itemname],(int)40001
JL spreroll
cmp dword ptr [itemname],(int)69001
JL 004D2C7B
cmp dword ptr [itemname],(int)92255
JL spreroll
jmp 004D2C7B

strrerollequality:
cmp [strpointer],1
JE strreroll
mov edi,0
jmp removal

dexrerollequality:
cmp [dexpointer],1
JE dexreroll
mov edi,1
jmp removal

recrerollequality:
cmp [recpointer],1
JE recreroll
mov edi,2
jmp removal

intrerollequality:
cmp [intpointer],1
JE intreroll
mov edi,3
jmp removal

wisrerollequality:
cmp [wispointer],1
JE wisreroll
mov edi,4
jmp removal

lucrerollequality:
cmp [lucpointer],1
JE lucreroll
mov edi,5
jmp removal

hprerollequality:
cmp [hppointer],1
JE hpcheck
mov edi,6
jmp removal

mprerollequality:
cmp [mppointer],1
JE mpcheck
mov edi,7
jmp removal

sprerollequality:
cmp [sppointer],1
JE spcheck
mov edi,8
jmp removal

strrerollremovalequality:
cmp [strpointer],1
JE strrerollremoval
mov edi,0
jmp removal

dexrerollremovalequality:
cmp [dexpointer],1
JE dexrerollremoval
mov edi,1
jmp removal

recrerollremovalequality:
cmp [recpointer],1
JE recrerollremoval
mov edi,2
jmp removal

intrerollremovalequality:
cmp [intpointer],1
JE intrerollremoval
mov edi,3
jmp removal

wisrerollremovalequality:
cmp [wispointer],1
JE wisrerollremoval
mov edi,4
jmp removal

lucrerollremovalequality:
cmp [lucpointer],1
JE lucrerollremoval
mov edi,5
jmp removal

hprerollremovalequality:
cmp [hppointer],1
JE hprerollremoval
mov edi,6
jmp removal

mprerollremovalequality:
cmp [mppointer],1
JE mprerollremoval
mov edi,7
jmp removal

sprerollremovalequality:
cmp [sppointer],1
JE sprerollremoval
mov edi,8
jmp removal

strreroll:
mov edi,0
jmp reroll

dexreroll:
mov edi,1
jmp reroll

recreroll:
mov edi,2
jmp reroll

intreroll:
mov edi,3
jmp reroll

wisreroll:
mov edi,4
jmp reroll

lucreroll:
mov edi,5
jmp reroll

hpreroll:
mov edi,6
jmp reroll

mpreroll:
mov edi,7
jmp reroll

spreroll:
mov edi,8
jmp reroll

strrerollremoval:
cmp [strpointer],0
JE removal
mov edi,0
jmp rerollremoval

dexrerollremoval:
cmp [dexpointer],0
JE removal
mov edi,1
jmp rerollremoval

recrerollremoval:
cmp [recpointer],0
JE removal
mov edi,2
jmp rerollremoval

intrerollremoval:
cmp [intpointer],0
JE removal
mov edi,3
jmp rerollremoval

wisrerollremoval:
cmp [wispointer],0
JE removal
mov edi,4
jmp rerollremoval

lucrerollremoval:
cmp [lucpointer],0
JE removal
mov edi,5
jmp rerollremoval

hprerollremoval:
cmp [hppointer],0
JE removal
mov edi,6
jmp rerollremoval

mprerollremoval:
cmp [mppointer],0
JE removal
mov edi,7
jmp rerollremoval

sprerollremoval:
cmp [sppointer],0
JE removal
mov edi,8
jmp rerollremoval


reroll:
//PerfectRunes
cmp [rune],(int)137
JE Perfect
cmp [rune],(int)138
JE Perfect
cmp [rune],(int)139
JE Perfect
cmp [rune],(int)140
JE Perfect
cmp [rune],(int)141
JE Perfect
cmp [rune],(int)142
JE Perfect
cmp [rune],(int)143
JE Perfect
cmp [rune],(int)144
JE Perfect
cmp [rune],(int)145
JE Perfect
JMP NotPerfect
Perfect:
mov edx,[esi+30]
movzx ecx,word ptr [edx+3E]
mov bl,cl
jmp end
NotPerfect:

call 0051BD66
mov edx,[esi+30]
movzx ecx,word ptr [edx+3E]
cdq
inc ecx
idiv ecx
mov bl,dl
call 0051BD66
mov edx,[esi+30]
movzx ecx,word ptr [edx+3E]
inc ecx
cdq
idiv ecx
cmp bl,dl
jb gmcheck
mov bl,dl

gmcheck:
cmp dword ptr [esp+2C],00
jne end
call 0051BD66
mov edx,[esi+30]
movzx ecx,word ptr [edx+3E]
inc ecx
cdq
idiv ecx
cmp bl,dl
jb end
mov bl,dl

end:
movzx dx,bl
cmp [rune],(int)106
JE strrerollr
cmp [rune],(int)107
JE dexrerollr
cmp [rune],(int)108
JE recrerollr
cmp [rune],(int)109
JE intrerollr
cmp [rune],(int)110
JE wisrerollr
cmp [rune],(int)111
JE lucrerollr
cmp [rune],(int)112
JE hprerollr
cmp [rune],(int)113
JE mprerollr
cmp [rune],(int)114
JE sprerollr
//PerfectRunes
cmp [rune],(int)137
JE strrerollrPerf
cmp [rune],(int)138
JE dexrerollrPerf
cmp [rune],(int)139
JE recrerollrPerf
cmp [rune],(int)140
JE intrerollrPerf
cmp [rune],(int)141
JE wisrerollrPerf
cmp [rune],(int)142
JE lucrerollrPerf
cmp [rune],(int)143
JE hprerollrPerf
cmp [rune],(int)144
JE mprerollrPerf
cmp [rune],(int)145
JE sprerollrPerf

backend:
movzx eax,bl
cdq
mov ecx,0000000A
idiv ecx
movzx ecx,word ptr [edi*2+00581C74]
add al,30
mov [ecx+esi+4C],al
movzx eax,word ptr [edi*2+00581C74]
add dl,30
mov [eax+esi+4D],dl
Jmp 004D2C7B

strrerollr:
mov [ebp+00],dx
Jmp backend
dexrerollr:
mov [ebp+02],dx
Jmp backend
recrerollr:
mov [ebp+04],dx
Jmp backend
intrerollr:
mov [ebp+06],dx
Jmp backend
wisrerollr:
mov [ebp+08],dx
Jmp backend
lucrerollr:
mov [ebp+0A],dx
Jmp backend
hprerollr:
mov [ebp+0C],dx
Jmp backend
mprerollr:
mov [ebp+0E],dx
Jmp backend
sprerollr:
mov [ebp+10],dx
Jmp backend

//PerfectRunes
strrerollrPerf:
mov [ebp+00],dx
Jmp backend
dexrerollrPerf:
mov [ebp+02],dx
Jmp backend
recrerollrPerf:
mov [ebp+04],dx
Jmp backend
intrerollrPerf:
mov [ebp+06],dx
Jmp backend
wisrerollrPerf:
mov [ebp+08],dx
Jmp backend
lucrerollrPerf:
mov [ebp+0A],dx
Jmp backend
hprerollrPerf:
mov [ebp+0C],dx
Jmp backend
mprerollrPerf:
mov [ebp+0E],dx
Jmp backend
sprerollrPerf:
mov [ebp+10],dx
Jmp backend

rerollremoval:
mov word ptr [ebp+00],0000
movzx edx,word ptr [edi*2+00581C74]
mov byte ptr [edx+esi+4C],30
movzx eax,word ptr [edi*2+00581C74]
mov byte ptr [eax+esi+4D],30
cmp [rune],(int)115
JE strrerollremovalr
cmp [rune],(int)116
JE dexrerollremovalr
cmp [rune],(int)117
JE recrerollremovalr
cmp [rune],(int)118
JE intrerollremovalr
cmp [rune],(int)119
JE wisrerollremovalr
cmp [rune],(int)120
JE lucrerollremovalr
cmp [rune],(int)121
JE hprerollremovalr
cmp [rune],(int)122
JE mprerollremovalr
cmp [rune],(int)123
JE sprerollremovalr
Jmp 004D2C7B

strrerollremovalr:
mov byte ptr [esi+84],0
Jmp 004D2C7B

dexrerollremovalr:
mov byte ptr [esi+86],0
Jmp 004D2C7B

recrerollremovalr:
mov byte ptr [esi+88],0
Jmp 004D2C7B

intrerollremovalr:
mov byte ptr [esi+8a],0
Jmp 004D2C7B

wisrerollremovalr:
mov byte ptr [esi+8c],0
Jmp 004D2C7B

lucrerollremovalr:
mov byte ptr [esi+8e],0
Jmp 004D2C7B

hprerollremovalr:
mov byte ptr [esi+90],0
Jmp 004D2C7B

mprerollremovalr:
mov byte ptr [esi+92],0
Jmp 004D2C7B

sprerollremovalr:
mov byte ptr [esi+94],0
Jmp 004D2C7B

removal:
jmp 004D2C7B

exit:
jmp returnhere

"ps_game.exe"+D2BC7:
jmp newmem
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+D2BC7:
lea ebp,[esi+00000084]
//Alt: db 8D AE 84 00 00 00
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>46</ID>
          <Description>"Stat removal "</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
registersymbol(rune)
registersymbol(gecici)
registersymbol(itemname)
registersymbol(counter16)
registersymbol(strpointer)
registersymbol(dexpointer)
registersymbol(recpointer)
registersymbol(intpointer)
registersymbol(wispointer)
registersymbol(lucpointer)
registersymbol(hppointer)
registersymbol(mppointer)
registersymbol(sppointer)
alloc(counter16,4)
alloc(gecici,4)
alloc(itemname,4)
alloc(strpointer,4)
alloc(dexpointer,4)
alloc(recpointer,4)
alloc(intpointer,4)
alloc(wispointer,4)
alloc(lucpointer,4)
alloc(hppointer,4)
alloc(mppointer,4)
alloc(sppointer,4)
alloc(rune,4)
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)
label(dexxx)
label(reccc)
label(inttt)
label(wisss)
label(luccc)
label(hppp)
label(mppp)
label(sppp)
label(removalrune)

newmem: //this is allocated memory, you have read,write,execute access
mov esi,[ebp+30]
mov esi,[esi]
mov [itemname],esi
mov esi,0
mov [strpointer],0
mov [dexpointer],0
mov [recpointer],0
mov [intpointer],0
mov [wispointer],0
mov [lucpointer],0
mov [hppointer],0
mov [sppointer],0
mov [mppointer],0
mov [counter16],0
cmp byte ptr [ebp+84],00
JE dexxx
add [counter16],1
mov [strpointer],1

dexxx:
cmp byte ptr [ebp+86],00
JE reccc
add [counter16],1
mov [dexpointer],1

reccc:
cmp byte ptr [ebp+88],00
JE inttt
add [counter16],1
mov [recpointer],1

inttt:
cmp byte ptr [ebp+8A],00
JE wisss
add [counter16],1
mov [intpointer],1

wisss:
cmp byte ptr [ebp+8C],00
JE luccc
add [counter16],1
mov [wispointer],1

luccc:
cmp byte ptr [ebp+8E],00
JE hppp
add [counter16],1
mov [lucpointer],1

hppp:
cmp byte ptr [ebp+90],00
JE mppp
add [counter16],1
mov [hppointer],1

mppp:
cmp byte ptr [ebp+92],00
JE sppp
add [counter16],1
mov [mppointer],1

sppp:
cmp byte ptr [ebp+94],00
JE originalcode
add [counter16],1
mov [sppointer],1


originalcode:
mov dl,[ecx]
mov [rune],dl

//Check
cmp [rune], (int)75 //StdRune
je removalrune
cmp [rune], (int)155 //StdRune
je removalrune
cmp [rune], (int)106 //Str
je CheckStrRune
CheckDexPointer:
cmp [rune], (int)107 //Dex
je CheckDexRune
CheckRecPointer:
cmp [rune], (int)108 // Rec
je CheckRecRune
CheckIntPointer:
cmp [rune], (int)109 // Int
je CheckIntRune
CheckWisPointer:
cmp [rune], (int)110 // Wis
je CheckWisRune
CheckLucPointer:
cmp [rune], (int)111 // Luc
je CheckLucRune
CheckHPPointer:
cmp [rune], (int)112 // HP
je CheckHPRune
CheckMPPointer:
cmp [rune], (int)113 // MP
je CheckMPRune
CheckSPPointer:
cmp [rune], (int)114 //SP
je CheckSPRune
SPPointerLast:
cmp [rune],(int)115
JE removalrune
cmp [rune],(int)116
JE removalrune
cmp [rune],(int)117
JE removalrune
cmp [rune],(int)118
JE removalrune
cmp [rune],(int)119
JE removalrune
cmp [rune],(int)120
JE removalrune
cmp [rune],(int)121
JE removalrune
cmp [rune],(int)122
JE removalrune
cmp [rune],(int)123
JE removalrune
// Perfect Runes
cmp [rune], (int)137 //Str
je CheckStrRunePerf
CheckDexPointerPerf:
cmp [rune], (int)138 //Dex
je CheckDexRunePerf
CheckRecPointerPerf:
cmp [rune], (int)139 // Rec
je CheckRecRunePerf
CheckIntPointerPerf:
cmp [rune], (int)140 // Int
je CheckIntRunePerf
CheckWisPointerPerf:
cmp [rune], (int)141 // Wis
je CheckWisRunePerf
CheckLucPointerPerf:
cmp [rune], (int)142 // Luc
je CheckLucRunePerf
CheckHPPointerPerf:
cmp [rune], (int)143 // HP
je CheckHPRunePerf
CheckMPPointerPerf:
cmp [rune], (int)144 // MP
je CheckMPRunePerf
CheckSPPointerPerf:
cmp [rune], (int)145 //SP
je CheckSPRunePerf
SPPointerLastPerf:
jmp ps_game.exe+6D901
removalrune:
cmp byte ptr [ecx+46],3E
jne ps_game.exe+6D901

exit:
jmp returnhere

CheckStrRune:
cmp [strpointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckDexPointer
CheckDexRune:
cmp [dexpointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckRecPointer
CheckRecRune:
cmp [recpointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckIntPointer
CheckIntRune:
cmp [intpointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckWisPointer
CheckWisRune:
cmp [wispointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckLucPointer
CheckLucRune:
cmp [lucpointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckHPPointer
CheckHPRune:
cmp [hppointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckMPPointer
CheckMPRune:
cmp [mppointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckSPPointer
CheckSPRune:
cmp [sppointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp SPPointerLast
// PerfectRunes
CheckStrRunePerf:
cmp [strpointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckDexPointerPerf
CheckDexRunePerf:
cmp [dexpointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckRecPointerPerf
CheckRecRunePerf:
cmp [recpointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckIntPointerPerf
CheckIntRunePerf:
cmp [intpointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckWisPointerPerf
CheckWisRunePerf:
cmp [wispointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckLucPointerPerf
CheckLucRunePerf:
cmp [lucpointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckHPPointerPerf
CheckHPRunePerf:
cmp [hppointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckMPPointerPerf
CheckMPRunePerf:
cmp [mppointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp CheckSPPointerPerf
CheckSPRunePerf:
cmp [sppointer], 1
je exit
push eax
mov eax,[ebp+30]
movzx eax,byte ptr [eax+4A]
cmp [counter16],eax
pop eax
jl exit
jmp SPPointerLastPerf

"ps_game.exe"+6D6A9:
jmp newmem
nop
nop
nop
nop
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+6D6A9:
cmp byte ptr [ecx+46],3E
jne ps_game.exe+6D901
//Alt: db 80 79 46 3E 0F 85 4E 02 00 00
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>776</ID>
          <Description>"Stat rec Rune"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat
registersymbol(ecxpointer)
registersymbol(orangecount)
alloc(orangecount,4)
alloc(ecxpointer,4)
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)
label(equality)
label(reroll)
label(gmcheck)
label(end)
label(backend)
label(hpcheck)
label(mpcheck)
label(spcheck)
label(strreroll)
label(dexreroll)
label(recreroll)
label(intreroll)
label(wisreroll)
label(lucreroll)
label(hpreroll)
label(mpreroll)
label(spreroll)
label(strrerollr)
label(dexrerollr)
label(recrerollr)
label(intrerollr)
label(wisrerollr)
label(lucrerollr)
label(hprerollr)
label(mprerollr)
label(sprerollr)
label(strrerollequality)
label(dexrerollequality)
label(recrerollequality)
label(intrerollequality)
label(wisrerollequality)
label(lucrerollequality)
label(hprerollequality)
label(mprerollequality)
label(sprerollequality)
label(rerollremoval)
label(strrerollremoval)
label(dexrerollremoval)
label(recrerollremoval)
label(intrerollremoval)
label(wisrerollremoval)
label(lucrerollremoval)
label(hprerollremoval)
label(mprerollremoval)
label(sprerollremoval)
label(strrerollremovalr)
label(dexrerollremovalr)
label(recrerollremovalr)
label(intrerollremovalr)
label(wisrerollremovalr)
label(lucrerollremovalr)
label(hprerollremovalr)
label(mprerollremovalr)
label(sprerollremovalr)
label(strrerollremovalequality)
label(dexrerollremovalequality)
label(recrerollremovalequality)
label(intrerollremovalequality)
label(wisrerollremovalequality)
label(lucrerollremovalequality)
label(hprerollremovalequality)
label(mprerollremovalequality)
label(sprerollremovalequality)
label(removal)


newmem: //this is allocated memory, you have read,write,execute access
cmp [rune],4B // StdRune
je originalcode
cmp [rune],9B // StdRune
je originalcode
lea ebp,[esi+00000084]
mov [orangecount],eax
cmp [counter16],eax
JG originalcode
cmp [counter16],eax
JE equality
cmp [rune],(int)106
JE strreroll
cmp [rune],(int)107
JE dexreroll
cmp [rune],(int)108
JE recreroll
cmp [rune],(int)109
JE intreroll
cmp [rune],(int)110
JE wisreroll
cmp [rune],(int)111
JE lucreroll
cmp [rune],(int)112
JE hpcheck
cmp [rune],(int)113
JE mpcheck
cmp [rune],(int)114
JE spcheck
cmp [rune],(int)115
JE strrerollremoval
cmp [rune],(int)116
JE dexrerollremoval
cmp [rune],(int)117
JE recrerollremoval
cmp [rune],(int)118
JE intrerollremoval
cmp [rune],(int)119
JE wisrerollremoval
cmp [rune],(int)120
JE lucrerollremoval
cmp [rune],(int)121
JE hprerollremoval
cmp [rune],(int)122
JE mprerollremoval
cmp [rune],(int)123
JE sprerollremoval
//PerfectRunes
cmp [rune],(int)137
JE strreroll
cmp [rune],(int)138
JE dexreroll
cmp [rune],(int)139
JE recreroll
cmp [rune],(int)140
JE intreroll
cmp [rune],(int)141
JE wisreroll
cmp [rune],(int)142
JE lucreroll
cmp [rune],(int)143
JE hpcheck
cmp [rune],(int)144
JE mpcheck
cmp [rune],(int)145
JE spcheck
cmp [rune],(int)146

originalcode:
lea ebp,[esi+00000084]
jmp exit

equality:
cmp [rune],(int)106
JE strrerollequality
cmp [rune],(int)107
JE dexrerollequality
cmp [rune],(int)108
JE recrerollequality
cmp [rune],(int)109
JE intrerollequality
cmp [rune],(int)110
JE wisrerollequality
cmp [rune],(int)111
JE lucrerollequality
cmp [rune],(int)112
JE hprerollequality
cmp [rune],(int)113
JE mprerollequality
cmp [rune],(int)114
JE sprerollequality
cmp [rune],(int)115
JE strrerollremovalequality
cmp [rune],(int)116
JE dexrerollremovalequality
cmp [rune],(int)117
JE recrerollremovalequality
cmp [rune],(int)118
JE intrerollremovalequality
cmp [rune],(int)119
JE wisrerollremovalequality
cmp [rune],(int)120
JE lucrerollremovalequality
cmp [rune],(int)121
JE hprerollremovalequality
cmp [rune],(int)122
JE mprerollremovalequality
cmp [rune],(int)123
JE sprerollremovalequality
//PerfectRunes
cmp [rune],(int)137
JE strrerollequality
cmp [rune],(int)138
JE dexrerollequality
cmp [rune],(int)139
JE recrerollequality
cmp [rune],(int)140
JE intrerollequality
cmp [rune],(int)141
JE wisrerollequality
cmp [rune],(int)142
JE lucrerollequality
cmp [rune],(int)143
JE hprerollequality
cmp [rune],(int)144
JE mprerollequality
cmp [rune],(int)145
JE sprerollequality
cmp [rune],(int)146
jmp originalcode

hpcheck:
cmp dword ptr [itemname],(int)16001
JL 004D2C7B
cmp dword ptr [itemname],(int)22001
JL hpreroll
cmp dword ptr [itemname],(int)23255
JLE 004D2C7B
cmp dword ptr [itemname],(int)40001
JL hpreroll
cmp dword ptr [itemname],(int)69001
JL 004D2C7B
cmp dword ptr [itemname],(int)92255
JL hpreroll
jmp 004D2C7B

mpcheck:
cmp dword ptr [itemname],(int)16001
JL 004D2C7B
cmp dword ptr [itemname],(int)22001
JL mpreroll
cmp dword ptr [itemname],(int)23255
JLE 004D2C7B
cmp dword ptr [itemname],(int)40001
JL mpreroll
cmp dword ptr [itemname],(int)69001
JL 004D2C7B
cmp dword ptr [itemname],(int)92255
JL mpreroll
jmp 004D2C7B


spcheck:
cmp dword ptr [itemname],(int)16001
JL 004D2C7B
cmp dword ptr [itemname],(int)22001
JL spreroll
cmp dword ptr [itemname],(int)23255
JLE 004D2C7B
cmp dword ptr [itemname],(int)40001
JL spreroll
cmp dword ptr [itemname],(int)69001
JL 004D2C7B
cmp dword ptr [itemname],(int)92255
JL spreroll
jmp 004D2C7B

strrerollequality:
cmp [strpointer],1
JE strreroll
mov edi,0
jmp removal

dexrerollequality:
cmp [dexpointer],1
JE dexreroll
mov edi,1
jmp removal

recrerollequality:
cmp [recpointer],1
JE recreroll
mov edi,2
jmp removal

intrerollequality:
cmp [intpointer],1
JE intreroll
mov edi,3
jmp removal

wisrerollequality:
cmp [wispointer],1
JE wisreroll
mov edi,4
jmp removal

lucrerollequality:
cmp [lucpointer],1
JE lucreroll
mov edi,5
jmp removal

hprerollequality:
cmp [hppointer],1
JE hpcheck
mov edi,6
jmp removal

mprerollequality:
cmp [mppointer],1
JE mpcheck
mov edi,7
jmp removal

sprerollequality:
cmp [sppointer],1
JE spcheck
mov edi,8
jmp removal

strrerollremovalequality:
cmp [strpointer],1
JE strrerollremoval
mov edi,0
jmp removal

dexrerollremovalequality:
cmp [dexpointer],1
JE dexrerollremoval
mov edi,1
jmp removal

recrerollremovalequality:
cmp [recpointer],1
JE recrerollremoval
mov edi,2
jmp removal

intrerollremovalequality:
cmp [intpointer],1
JE intrerollremoval
mov edi,3
jmp removal

wisrerollremovalequality:
cmp [wispointer],1
JE wisrerollremoval
mov edi,4
jmp removal

lucrerollremovalequality:
cmp [lucpointer],1
JE lucrerollremoval
mov edi,5
jmp removal

hprerollremovalequality:
cmp [hppointer],1
JE hprerollremoval
mov edi,6
jmp removal

mprerollremovalequality:
cmp [mppointer],1
JE mprerollremoval
mov edi,7
jmp removal

sprerollremovalequality:
cmp [sppointer],1
JE sprerollremoval
mov edi,8
jmp removal

strreroll:
mov edi,0
jmp reroll

dexreroll:
mov edi,1
jmp reroll

recreroll:
mov edi,2
jmp reroll

intreroll:
mov edi,3
jmp reroll

wisreroll:
mov edi,4
jmp reroll

lucreroll:
mov edi,5
jmp reroll

hpreroll:
mov edi,6
jmp reroll

mpreroll:
mov edi,7
jmp reroll

spreroll:
mov edi,8
jmp reroll

strrerollremoval:
cmp [strpointer],0
JE removal
mov edi,0
jmp rerollremoval

dexrerollremoval:
cmp [dexpointer],0
JE removal
mov edi,1
jmp rerollremoval

recrerollremoval:
cmp [recpointer],0
JE removal
mov edi,2
jmp rerollremoval

intrerollremoval:
cmp [intpointer],0
JE removal
mov edi,3
jmp rerollremoval

wisrerollremoval:
cmp [wispointer],0
JE removal
mov edi,4
jmp rerollremoval

lucrerollremoval:
cmp [lucpointer],0
JE removal
mov edi,5
jmp rerollremoval

hprerollremoval:
cmp [hppointer],0
JE removal
mov edi,6
jmp rerollremoval

mprerollremoval:
cmp [mppointer],0
JE removal
mov edi,7
jmp rerollremoval

sprerollremoval:
cmp [sppointer],0
JE removal
mov edi,8
jmp rerollremoval


reroll:
//PerfectRunes
cmp [rune],(int)137
JE Perfect
cmp [rune],(int)138
JE Perfect
cmp [rune],(int)139
JE Perfect
cmp [rune],(int)140
JE Perfect
cmp [rune],(int)141
JE Perfect
cmp [rune],(int)142
JE Perfect
cmp [rune],(int)143
JE Perfect
cmp [rune],(int)144
JE Perfect
cmp [rune],(int)145
JE Perfect
JMP NotPerfect
Perfect:
mov edx,[esi+30]
movzx ecx,word ptr [edx+3E]
mov bl,cl
jmp end
NotPerfect:

call 0051BD66
mov edx,[esi+30]
movzx ecx,word ptr [edx+3E]
cdq
inc ecx
idiv ecx
mov bl,dl
call 0051BD66
mov edx,[esi+30]
movzx ecx,word ptr [edx+3E]
inc ecx
cdq
idiv ecx
cmp bl,dl
jb gmcheck
mov bl,dl

gmcheck:
cmp dword ptr [esp+2C],00
jne end
call 0051BD66
mov edx,[esi+30]
movzx ecx,word ptr [edx+3E]
inc ecx
cdq
idiv ecx
cmp bl,dl
jb end
mov bl,dl

end:
movzx dx,bl
cmp [rune],(int)106
JE strrerollr
cmp [rune],(int)107
JE dexrerollr
cmp [rune],(int)108
JE recrerollr
cmp [rune],(int)109
JE intrerollr
cmp [rune],(int)110
JE wisrerollr
cmp [rune],(int)111
JE lucrerollr
cmp [rune],(int)112
JE hprerollr
cmp [rune],(int)113
JE mprerollr
cmp [rune],(int)114
JE sprerollr
//PerfectRunes
cmp [rune],(int)137
JE strrerollrPerf
cmp [rune],(int)138
JE dexrerollrPerf
cmp [rune],(int)139
JE recrerollrPerf
cmp [rune],(int)140
JE intrerollrPerf
cmp [rune],(int)141
JE wisrerollrPerf
cmp [rune],(int)142
JE lucrerollrPerf
cmp [rune],(int)143
JE hprerollrPerf
cmp [rune],(int)144
JE mprerollrPerf
cmp [rune],(int)145
JE sprerollrPerf

backend:
movzx eax,bl
cdq
mov ecx,0000000A
idiv ecx
movzx ecx,word ptr [edi*2+00581C74]
add al,30
mov [ecx+esi+4C],al
movzx eax,word ptr [edi*2+00581C74]
add dl,30
mov [eax+esi+4D],dl
Jmp 004D2C7B

strrerollr:
mov [ebp+00],dx
Jmp backend
dexrerollr:
mov [ebp+02],dx
Jmp backend
recrerollr:
mov [ebp+04],dx
Jmp backend
intrerollr:
mov [ebp+06],dx
Jmp backend
wisrerollr:
mov [ebp+08],dx
Jmp backend
lucrerollr:
mov [ebp+0A],dx
Jmp backend
hprerollr:
mov [ebp+0C],dx
Jmp backend
mprerollr:
mov [ebp+0E],dx
Jmp backend
sprerollr:
mov [ebp+10],dx
Jmp backend

//PerfectRunes
strrerollrPerf:
mov [ebp+00],dx
Jmp backend
dexrerollrPerf:
mov [ebp+02],dx
Jmp backend
recrerollrPerf:
mov [ebp+04],dx
Jmp backend
intrerollrPerf:
mov [ebp+06],dx
Jmp backend
wisrerollrPerf:
mov [ebp+08],dx
Jmp backend
lucrerollrPerf:
mov [ebp+0A],dx
Jmp backend
hprerollrPerf:
mov [ebp+0C],dx
Jmp backend
mprerollrPerf:
mov [ebp+0E],dx
Jmp backend
sprerollrPerf:
mov [ebp+10],dx
Jmp backend

rerollremoval:
mov word ptr [ebp+00],0000
movzx edx,word ptr [edi*2+00581C74]
mov byte ptr [edx+esi+4C],30
movzx eax,word ptr [edi*2+00581C74]
mov byte ptr [eax+esi+4D],30
cmp [rune],(int)115
JE strrerollremovalr
cmp [rune],(int)116
JE dexrerollremovalr
cmp [rune],(int)117
JE recrerollremovalr
cmp [rune],(int)118
JE intrerollremovalr
cmp [rune],(int)119
JE wisrerollremovalr
cmp [rune],(int)120
JE lucrerollremovalr
cmp [rune],(int)121
JE hprerollremovalr
cmp [rune],(int)122
JE mprerollremovalr
cmp [rune],(int)123
JE sprerollremovalr
Jmp 004D2C7B

strrerollremovalr:
mov byte ptr [esi+84],0
Jmp 004D2C7B

dexrerollremovalr:
mov byte ptr [esi+86],0
Jmp 004D2C7B

recrerollremovalr:
mov byte ptr [esi+88],0
Jmp 004D2C7B

intrerollremovalr:
mov byte ptr [esi+8a],0
Jmp 004D2C7B

wisrerollremovalr:
mov byte ptr [esi+8c],0
Jmp 004D2C7B

lucrerollremovalr:
mov byte ptr [esi+8e],0
Jmp 004D2C7B

hprerollremovalr:
mov byte ptr [esi+90],0
Jmp 004D2C7B

mprerollremovalr:
mov byte ptr [esi+92],0
Jmp 004D2C7B

sprerollremovalr:
mov byte ptr [esi+94],0
Jmp 004D2C7B

removal:
jmp 004D2C7B

exit:
jmp returnhere

"ps_game.exe"+D2BC7:
jmp newmem
nop
returnhere:




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
"ps_game.exe"+D2BC7:
lea ebp,[esi+00000084]
//Alt: db 8D AE 84 00 00 00
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>34</ID>
          <Description>"leader resurrection"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
0046656C: //for ulti
db 90 90

00478EA2: //lead time
db 05 88 13 00 00

[DISABLE]

0046656C:
db 90 90

00478EA2:
db 05 88 13 00 00
</AssemblerScript>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
  </CheatEntries>
  <CheatCodes>
    <CodeEntry Color="20000000">
      <Description>Change of is ps_game.exe + 665CF</Description>
      <AddressString>ps_game.exe+6656C</AddressString>
      <Before>
        <Byte>2F</Byte>
        <Byte>01</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>03</Byte>
      </Before>
      <Actual>
        <Byte>74</Byte>
        <Byte>61</Byte>
      </Actual>
      <After>
        <Byte>8B</Byte>
        <Byte>40</Byte>
        <Byte>28</Byte>
        <Byte>83</Byte>
        <Byte>B8</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of add eax,00001388</Description>
      <AddressString>ps_game.exe+78EA2</AddressString>
      <Before>
        <Byte>15</Byte>
        <Byte>D0</Byte>
        <Byte>40</Byte>
        <Byte>55</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>05</Byte>
        <Byte>88</Byte>
        <Byte>13</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>89</Byte>
        <Byte>87</Byte>
        <Byte>70</Byte>
        <Byte>14</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of is ps_game.exe + 665CF</Description>
      <AddressString>ps_game.exe+6656C</AddressString>
      <Before>
        <Byte>2F</Byte>
        <Byte>01</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>03</Byte>
      </Before>
      <Actual>
        <Byte>74</Byte>
        <Byte>61</Byte>
      </Actual>
      <After>
        <Byte>8B</Byte>
        <Byte>40</Byte>
        <Byte>28</Byte>
        <Byte>83</Byte>
        <Byte>B8</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of add eax,00001388</Description>
      <AddressString>ps_game.exe+78EA2</AddressString>
      <Before>
        <Byte>15</Byte>
        <Byte>D0</Byte>
        <Byte>40</Byte>
        <Byte>55</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>05</Byte>
        <Byte>88</Byte>
        <Byte>13</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>89</Byte>
        <Byte>87</Byte>
        <Byte>70</Byte>
        <Byte>14</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+665CF</Description>
      <AddressString>ps_game.exe+6656C</AddressString>
      <Before>
        <Byte>2F</Byte>
        <Byte>01</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>03</Byte>
      </Before>
      <Actual>
        <Byte>74</Byte>
        <Byte>61</Byte>
      </Actual>
      <After>
        <Byte>8B</Byte>
        <Byte>40</Byte>
        <Byte>28</Byte>
        <Byte>83</Byte>
        <Byte>B8</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of add eax,00001388</Description>
      <AddressString>ps_game.exe+78EA2</AddressString>
      <Before>
        <Byte>15</Byte>
        <Byte>D0</Byte>
        <Byte>40</Byte>
        <Byte>55</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>05</Byte>
        <Byte>88</Byte>
        <Byte>13</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>89</Byte>
        <Byte>87</Byte>
        <Byte>70</Byte>
        <Byte>14</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+665CF</Description>
      <AddressString>ps_game.exe+6656C</AddressString>
      <Before>
        <Byte>2F</Byte>
        <Byte>01</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>03</Byte>
      </Before>
      <Actual>
        <Byte>74</Byte>
        <Byte>61</Byte>
      </Actual>
      <After>
        <Byte>8B</Byte>
        <Byte>40</Byte>
        <Byte>28</Byte>
        <Byte>83</Byte>
        <Byte>B8</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of add eax,00001388</Description>
      <AddressString>ps_game.exe+78EA2</AddressString>
      <Before>
        <Byte>15</Byte>
        <Byte>D0</Byte>
        <Byte>40</Byte>
        <Byte>55</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>05</Byte>
        <Byte>88</Byte>
        <Byte>13</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>89</Byte>
        <Byte>87</Byte>
        <Byte>70</Byte>
        <Byte>14</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of jae ps_game.exe+6D11C</Description>
      <AddressString>ps_game.exe+6CD7D</AddressString>
      <Before>
        <Byte>6C</Byte>
        <Byte>24</Byte>
        <Byte>44</Byte>
        <Byte>3B</Byte>
        <Byte>F0</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>83</Byte>
        <Byte>99</Byte>
        <Byte>03</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>B7</Byte>
        <Byte>14</Byte>
        <Byte>55</Byte>
        <Byte>30</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of jle ps_game.exe+6E73D</Description>
      <AddressString>ps_game.exe+6E736</AddressString>
      <Before>
        <Byte>58</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>FE</Byte>
        <Byte>32</Byte>
      </Before>
      <Actual>
        <Byte>7E</Byte>
        <Byte>05</Byte>
      </Actual>
      <After>
        <Byte>BE</Byte>
        <Byte>32</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp esi,32</Description>
      <AddressString>ps_game.exe+6E733</AddressString>
      <Before>
        <Byte>35</Byte>
        <Byte>B8</Byte>
        <Byte>79</Byte>
        <Byte>58</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>FE</Byte>
        <Byte>32</Byte>
      </Actual>
      <After>
        <Byte>90</Byte>
        <Byte>90</Byte>
        <Byte>BE</Byte>
        <Byte>64</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of jae ps_game.exe+6D11C</Description>
      <AddressString>ps_game.exe+6CD7D</AddressString>
      <Before>
        <Byte>6C</Byte>
        <Byte>24</Byte>
        <Byte>44</Byte>
        <Byte>3B</Byte>
        <Byte>F0</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>83</Byte>
        <Byte>99</Byte>
        <Byte>03</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>B7</Byte>
        <Byte>14</Byte>
        <Byte>55</Byte>
        <Byte>30</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of jne ps_game.exe+7E0DA</Description>
      <AddressString>ps_game.exe+7D9B6</AddressString>
      <Before>
        <Byte>8B</Byte>
        <Byte>2D</Byte>
        <Byte>01</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>85</Byte>
        <Byte>1E</Byte>
        <Byte>07</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>83</Byte>
        <Byte>B8</Byte>
        <Byte>8C</Byte>
        <Byte>55</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+72E8C</Description>
      <AddressString>ps_game.exe+72E2A</AddressString>
      <Before>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>1A</Byte>
      </Before>
      <Actual>
        <Byte>74</Byte>
        <Byte>60</Byte>
      </Actual>
      <After>
        <Byte>8A</Byte>
        <Byte>43</Byte>
        <Byte>40</Byte>
        <Byte>3C</Byte>
        <Byte>1B</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of call ps_game.exe+F3AB0</Description>
      <AddressString>ps_game.exe+F3DD0</AddressString>
      <Before>
        <Byte>B9</Byte>
        <Byte>24</Byte>
        <Byte>37</Byte>
        <Byte>58</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>E8</Byte>
        <Byte>DB</Byte>
        <Byte>FC</Byte>
        <Byte>FF</Byte>
        <Byte>FF</Byte>
      </Actual>
      <After>
        <Byte>EB</Byte>
        <Byte>1B</Byte>
        <Byte>83</Byte>
        <Byte>FF</Byte>
        <Byte>7E</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of jmp ps_game.exe+91496</Description>
      <AddressString>ps_game.exe+91444</AddressString>
      <Before>
        <Byte>09</Byte>
        <Byte>8D</Byte>
        <Byte>54</Byte>
        <Byte>24</Byte>
        <Byte>0C</Byte>
      </Before>
      <Actual>
        <Byte>EB</Byte>
        <Byte>50</Byte>
      </Actual>
      <After>
        <Byte>B8</Byte>
        <Byte>1D</Byte>
        <Byte>05</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of jne ps_game.exe+9DC71</Description>
      <AddressString>ps_game.exe+9DB47</AddressString>
      <Before>
        <Byte>9F</Byte>
        <Byte>7C</Byte>
        <Byte>14</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>85</Byte>
        <Byte>24</Byte>
        <Byte>01</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>39</Byte>
        <Byte>B7</Byte>
        <Byte>80</Byte>
        <Byte>14</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of ja ps_game.exe+9DC71</Description>
      <AddressString>ps_game.exe+9DB53</AddressString>
      <Before>
        <Byte>B7</Byte>
        <Byte>80</Byte>
        <Byte>14</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>87</Byte>
        <Byte>18</Byte>
        <Byte>01</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>8B</Byte>
        <Byte>87</Byte>
        <Byte>F4</Byte>
        <Byte>01</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Code :lock xadd [ecx],eax</Description>
      <AddressString>kernel32.dll+4BB68</AddressString>
      <Before>
        <Byte>04</Byte>
        <Byte>8B</Byte>
        <Byte>44</Byte>
        <Byte>24</Byte>
        <Byte>08</Byte>
      </Before>
      <Actual>
        <Byte>F0</Byte>
        <Byte>0F</Byte>
        <Byte>C1</Byte>
        <Byte>01</Byte>
      </Actual>
      <After>
        <Byte>C2</Byte>
        <Byte>08</Byte>
        <Byte>00</Byte>
        <Byte>90</Byte>
        <Byte>90</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+665CF</Description>
      <AddressString>ps_game.exe+6656C</AddressString>
      <Before>
        <Byte>2F</Byte>
        <Byte>01</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>03</Byte>
      </Before>
      <Actual>
        <Byte>74</Byte>
        <Byte>61</Byte>
      </Actual>
      <After>
        <Byte>8B</Byte>
        <Byte>40</Byte>
        <Byte>28</Byte>
        <Byte>83</Byte>
        <Byte>B8</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of add eax,00001388</Description>
      <AddressString>ps_game.exe+78EA2</AddressString>
      <Before>
        <Byte>15</Byte>
        <Byte>D0</Byte>
        <Byte>40</Byte>
        <Byte>55</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>05</Byte>
        <Byte>88</Byte>
        <Byte>13</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>89</Byte>
        <Byte>87</Byte>
        <Byte>70</Byte>
        <Byte>14</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+665CF</Description>
      <AddressString>ps_game.exe+6656C</AddressString>
      <Before>
        <Byte>2F</Byte>
        <Byte>01</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>03</Byte>
      </Before>
      <Actual>
        <Byte>74</Byte>
        <Byte>61</Byte>
      </Actual>
      <After>
        <Byte>8B</Byte>
        <Byte>40</Byte>
        <Byte>28</Byte>
        <Byte>83</Byte>
        <Byte>B8</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of add eax,00001388</Description>
      <AddressString>ps_game.exe+78EA2</AddressString>
      <Before>
        <Byte>15</Byte>
        <Byte>D0</Byte>
        <Byte>40</Byte>
        <Byte>55</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>05</Byte>
        <Byte>88</Byte>
        <Byte>13</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>89</Byte>
        <Byte>87</Byte>
        <Byte>70</Byte>
        <Byte>14</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+665CF</Description>
      <AddressString>ps_game.exe+6656C</AddressString>
      <Before>
        <Byte>2F</Byte>
        <Byte>01</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>03</Byte>
      </Before>
      <Actual>
        <Byte>74</Byte>
        <Byte>61</Byte>
      </Actual>
      <After>
        <Byte>8B</Byte>
        <Byte>40</Byte>
        <Byte>28</Byte>
        <Byte>83</Byte>
        <Byte>B8</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of add eax,00001388</Description>
      <AddressString>ps_game.exe+78EA2</AddressString>
      <Before>
        <Byte>15</Byte>
        <Byte>D0</Byte>
        <Byte>40</Byte>
        <Byte>55</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>05</Byte>
        <Byte>88</Byte>
        <Byte>13</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>89</Byte>
        <Byte>87</Byte>
        <Byte>70</Byte>
        <Byte>14</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+665CF</Description>
      <AddressString>ps_game.exe+6656C</AddressString>
      <Before>
        <Byte>2F</Byte>
        <Byte>01</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>03</Byte>
      </Before>
      <Actual>
        <Byte>74</Byte>
        <Byte>61</Byte>
      </Actual>
      <After>
        <Byte>8B</Byte>
        <Byte>40</Byte>
        <Byte>28</Byte>
        <Byte>83</Byte>
        <Byte>B8</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of add eax,00001388</Description>
      <AddressString>ps_game.exe+78EA2</AddressString>
      <Before>
        <Byte>15</Byte>
        <Byte>D0</Byte>
        <Byte>40</Byte>
        <Byte>55</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>05</Byte>
        <Byte>88</Byte>
        <Byte>13</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>89</Byte>
        <Byte>87</Byte>
        <Byte>70</Byte>
        <Byte>14</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of jae ps_game.exe+6D11C</Description>
      <AddressString>ps_game.exe+6CD7D</AddressString>
      <Before>
        <Byte>6C</Byte>
        <Byte>24</Byte>
        <Byte>44</Byte>
        <Byte>3B</Byte>
        <Byte>F0</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>83</Byte>
        <Byte>99</Byte>
        <Byte>03</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>B7</Byte>
        <Byte>14</Byte>
        <Byte>55</Byte>
        <Byte>30</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of jle ps_game.exe+6E73D</Description>
      <AddressString>ps_game.exe+6E736</AddressString>
      <Before>
        <Byte>58</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>FE</Byte>
        <Byte>32</Byte>
      </Before>
      <Actual>
        <Byte>7E</Byte>
        <Byte>05</Byte>
      </Actual>
      <After>
        <Byte>BE</Byte>
        <Byte>32</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp esi,32</Description>
      <AddressString>ps_game.exe+6E733</AddressString>
      <Before>
        <Byte>35</Byte>
        <Byte>B8</Byte>
        <Byte>79</Byte>
        <Byte>58</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>FE</Byte>
        <Byte>32</Byte>
      </Actual>
      <After>
        <Byte>90</Byte>
        <Byte>90</Byte>
        <Byte>BE</Byte>
        <Byte>64</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of jae ps_game.exe+6D11C</Description>
      <AddressString>ps_game.exe+6CD7D</AddressString>
      <Before>
        <Byte>6C</Byte>
        <Byte>24</Byte>
        <Byte>44</Byte>
        <Byte>3B</Byte>
        <Byte>F0</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>83</Byte>
        <Byte>99</Byte>
        <Byte>03</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>B7</Byte>
        <Byte>14</Byte>
        <Byte>55</Byte>
        <Byte>30</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of jne ps_game.exe+7E0DA</Description>
      <AddressString>ps_game.exe+7D9B6</AddressString>
      <Before>
        <Byte>8B</Byte>
        <Byte>2D</Byte>
        <Byte>01</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>85</Byte>
        <Byte>1E</Byte>
        <Byte>07</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>83</Byte>
        <Byte>B8</Byte>
        <Byte>8C</Byte>
        <Byte>55</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+72E8C</Description>
      <AddressString>ps_game.exe+72E2A</AddressString>
      <Before>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>1A</Byte>
      </Before>
      <Actual>
        <Byte>74</Byte>
        <Byte>60</Byte>
      </Actual>
      <After>
        <Byte>8A</Byte>
        <Byte>43</Byte>
        <Byte>40</Byte>
        <Byte>3C</Byte>
        <Byte>1B</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of call ps_game.exe+F3AB0</Description>
      <AddressString>ps_game.exe+F3DD0</AddressString>
      <Before>
        <Byte>B9</Byte>
        <Byte>24</Byte>
        <Byte>37</Byte>
        <Byte>58</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>E8</Byte>
        <Byte>DB</Byte>
        <Byte>FC</Byte>
        <Byte>FF</Byte>
        <Byte>FF</Byte>
      </Actual>
      <After>
        <Byte>EB</Byte>
        <Byte>1B</Byte>
        <Byte>83</Byte>
        <Byte>FF</Byte>
        <Byte>7E</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of jmp ps_game.exe+91496</Description>
      <AddressString>ps_game.exe+91444</AddressString>
      <Before>
        <Byte>09</Byte>
        <Byte>8D</Byte>
        <Byte>54</Byte>
        <Byte>24</Byte>
        <Byte>0C</Byte>
      </Before>
      <Actual>
        <Byte>EB</Byte>
        <Byte>50</Byte>
      </Actual>
      <After>
        <Byte>B8</Byte>
        <Byte>1D</Byte>
        <Byte>05</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of jne ps_game.exe+9DC71</Description>
      <AddressString>ps_game.exe+9DB47</AddressString>
      <Before>
        <Byte>9F</Byte>
        <Byte>7C</Byte>
        <Byte>14</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>85</Byte>
        <Byte>24</Byte>
        <Byte>01</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>39</Byte>
        <Byte>B7</Byte>
        <Byte>80</Byte>
        <Byte>14</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of ja ps_game.exe+9DC71</Description>
      <AddressString>ps_game.exe+9DB53</AddressString>
      <Before>
        <Byte>B7</Byte>
        <Byte>80</Byte>
        <Byte>14</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>87</Byte>
        <Byte>18</Byte>
        <Byte>01</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>8B</Byte>
        <Byte>87</Byte>
        <Byte>F4</Byte>
        <Byte>01</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Code :lock xadd [ecx],eax</Description>
      <AddressString>kernel32.dll+4BB68</AddressString>
      <Before>
        <Byte>04</Byte>
        <Byte>8B</Byte>
        <Byte>44</Byte>
        <Byte>24</Byte>
        <Byte>08</Byte>
      </Before>
      <Actual>
        <Byte>F0</Byte>
        <Byte>0F</Byte>
        <Byte>C1</Byte>
        <Byte>01</Byte>
      </Actual>
      <After>
        <Byte>C2</Byte>
        <Byte>08</Byte>
        <Byte>00</Byte>
        <Byte>90</Byte>
        <Byte>90</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of jle ps_game.exe+6E73D</Description>
      <AddressString>ps_game.exe+6E736</AddressString>
      <Before>
        <Byte>58</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>FE</Byte>
        <Byte>32</Byte>
      </Before>
      <Actual>
        <Byte>7E</Byte>
        <Byte>05</Byte>
      </Actual>
      <After>
        <Byte>BE</Byte>
        <Byte>32</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp esi,32</Description>
      <AddressString>ps_game.exe+6E733</AddressString>
      <Before>
        <Byte>35</Byte>
        <Byte>B8</Byte>
        <Byte>79</Byte>
        <Byte>58</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>FE</Byte>
        <Byte>32</Byte>
      </Actual>
      <After>
        <Byte>90</Byte>
        <Byte>90</Byte>
        <Byte>BE</Byte>
        <Byte>64</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of jae ps_game.exe+6D11C</Description>
      <AddressString>ps_game.exe+6CD7D</AddressString>
      <Before>
        <Byte>6C</Byte>
        <Byte>24</Byte>
        <Byte>44</Byte>
        <Byte>3B</Byte>
        <Byte>F0</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>83</Byte>
        <Byte>99</Byte>
        <Byte>03</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>B7</Byte>
        <Byte>14</Byte>
        <Byte>55</Byte>
        <Byte>30</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of jne ps_game.exe+7E0DA</Description>
      <AddressString>ps_game.exe+7D9B6</AddressString>
      <Before>
        <Byte>8B</Byte>
        <Byte>2D</Byte>
        <Byte>01</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>85</Byte>
        <Byte>1E</Byte>
        <Byte>07</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>83</Byte>
        <Byte>B8</Byte>
        <Byte>8C</Byte>
        <Byte>55</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+72E8C</Description>
      <AddressString>ps_game.exe+72E2A</AddressString>
      <Before>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>1A</Byte>
      </Before>
      <Actual>
        <Byte>74</Byte>
        <Byte>60</Byte>
      </Actual>
      <After>
        <Byte>8A</Byte>
        <Byte>43</Byte>
        <Byte>40</Byte>
        <Byte>3C</Byte>
        <Byte>1B</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of call ps_game.exe+F3AB0</Description>
      <AddressString>ps_game.exe+F3DD0</AddressString>
      <Before>
        <Byte>B9</Byte>
        <Byte>24</Byte>
        <Byte>37</Byte>
        <Byte>58</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>E8</Byte>
        <Byte>DB</Byte>
        <Byte>FC</Byte>
        <Byte>FF</Byte>
        <Byte>FF</Byte>
      </Actual>
      <After>
        <Byte>EB</Byte>
        <Byte>1B</Byte>
        <Byte>83</Byte>
        <Byte>FF</Byte>
        <Byte>7E</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of jmp ps_game.exe+91496</Description>
      <AddressString>ps_game.exe+91444</AddressString>
      <Before>
        <Byte>09</Byte>
        <Byte>8D</Byte>
        <Byte>54</Byte>
        <Byte>24</Byte>
        <Byte>0C</Byte>
      </Before>
      <Actual>
        <Byte>EB</Byte>
        <Byte>50</Byte>
      </Actual>
      <After>
        <Byte>B8</Byte>
        <Byte>1D</Byte>
        <Byte>05</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of jne ps_game.exe+9DC71</Description>
      <AddressString>ps_game.exe+9DB47</AddressString>
      <Before>
        <Byte>9F</Byte>
        <Byte>7C</Byte>
        <Byte>14</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>85</Byte>
        <Byte>24</Byte>
        <Byte>01</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>39</Byte>
        <Byte>B7</Byte>
        <Byte>80</Byte>
        <Byte>14</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of ja ps_game.exe+9DC71</Description>
      <AddressString>ps_game.exe+9DB53</AddressString>
      <Before>
        <Byte>B7</Byte>
        <Byte>80</Byte>
        <Byte>14</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>87</Byte>
        <Byte>18</Byte>
        <Byte>01</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>8B</Byte>
        <Byte>87</Byte>
        <Byte>F4</Byte>
        <Byte>01</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Code :lock xadd [ecx],eax</Description>
      <AddressString>kernel32.dll+4BB68</AddressString>
      <Before>
        <Byte>04</Byte>
        <Byte>8B</Byte>
        <Byte>44</Byte>
        <Byte>24</Byte>
        <Byte>08</Byte>
      </Before>
      <Actual>
        <Byte>F0</Byte>
        <Byte>0F</Byte>
        <Byte>C1</Byte>
        <Byte>01</Byte>
      </Actual>
      <After>
        <Byte>C2</Byte>
        <Byte>08</Byte>
        <Byte>00</Byte>
        <Byte>90</Byte>
        <Byte>90</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of je ps_game.exe+BB47A</Description>
      <AddressString>ps_game.exe+BAFD4</AddressString>
      <Before>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>18</Byte>
      </Before>
      <Actual>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A0</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C9</Byte>
        <Byte>74</Byte>
        <Byte>49</Byte>
        <Byte>85</Byte>
      </After>
    </CodeEntry>
    <CodeEntry Color="20000000">
      <Description>Change of cmp eax,10</Description>
      <AddressString>ps_game.exe+BAFC8</AddressString>
      <Before>
        <Byte>86</Byte>
        <Byte>A0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>83</Byte>
        <Byte>F8</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>A9</Byte>
        <Byte>04</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
  </CheatCodes>
  <UserdefinedSymbols/>
</CheatTable>
